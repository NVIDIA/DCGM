#!/usr/bin/env python3
#
# Copyright (c) 2025-2026, NVIDIA CORPORATION.  All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os
import logging
import re
import sys
from string import Template

NVML_ENTRY_POINTS_FILE = "sdk/nvidia/nvml/nvml_entry_points.h"
COPYRIGHT_NOTICE = '''/*
 * Copyright (c) 2025-2026, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'''
AUTO_GENERATED_NOTICE = '\n/*\n * NOTE: This code is auto-generated by NvmlTaskRunnerGenerator.py\n * DO NOT EDIT MANUALLY\n */\n\n'

NVML_SAFE_WARPPER_FUNCTION_TEMPLATE = Template("""
nvmlReturn_t NvmlTaskRunner::$generatedFuncname$argList
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("$generatedFuncname", [this, $originalArgNames]() {
        return $generatedFuncnameImpl($originalArgNames);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::$generatedFuncnameImpl$argList
{
    if ($identity.generation != GetGeneration())
    {
        log_debug("$generatedFuncnameImpl: generation mismatch {}, {}", $identity.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::$originalFuncname($identityAccessNvml$argsToAccessNvml);
}
""")

NVML_BASIC_FUNCTION_TEMPLATE = Template("""
nvmlReturn_t NvmlTaskRunner::$generatedFuncname$argList
{
    return InvokeNvmlFunction(::$originalFuncname$argsToAccessNvml);
}
""")


def RemoveExtraSpaces(text):
    while text.find('  ') != -1:
        text = text.replace('  ', ' ')
    return text


def GetFunctionSignature(entryPoint, first):
    # Remove all line breaks, remove the extra whitespace on the ends, and then get
    # get rid of the parenthesis around the string
    # We are left with something in the form of:
    # funcname, tsapiFuncname, (argument list), "(argument type matching)", arg1, arg2, ...)

    # Example:
    # NVML_ENTRY_POINT(nvmlDeviceGetComputeMode,
    #    tsapiDeviceGetComputeMode,
    #    (nvmlDevice_t device, nvmlComputeMode_t *mode),
    #    "(%p, %p)",
    #    device,
    #    mode)
    # becomes:
    # m.group(1): nvmlDeviceGetComputeMode
    # m.group(2): (nvmlDevice_t device, nvmlComputeMode_t *mode)
    # m.group(3): device, mode
    entryPoint = entryPoint.replace('\n', ' ').strip()[1:-1]
    preg = re.compile(r"(nvml\w+),[^)]+(\([^)]+\)),\s+\"[^\"]+\",\s+([^)]+)")
    m = preg.search(entryPoint)
    if m:
        return RemoveExtraSpaces(m.group(1)), RemoveExtraSpaces(m.group(2)), RemoveExtraSpaces(m.group(3))
    else:
        if entryPoint == "include \"nvml.h":
            pass
        # Ignore errors on the first token because it is everything from before the first entry point
        elif not first:
            logging.debug(f"no match found in entry point = '{entryPoint}'")
        return None, None, None


class FunctionInfo:
    def __init__(self, originalFuncname, generatedFuncname, argList, originalArgNames, argNamesWithoutFirst):
        self.originalFuncname = originalFuncname  # e.g., nvmlDeviceGetPcieSpeed
        self.generatedFuncname = generatedFuncname  # e.g., NvmlDeviceGetPcieSpeed
        # e.g., (SafeNvmlHandle device, nvmlPcieSpeed_t *speed)
        self.argList = argList
        self.originalArgNames = originalArgNames  # e.g., device, speed
        self.argNamesWithoutFirst = argNamesWithoutFirst  # e.g., speed


# These device-related functions are not auto-generated, we have to manually add them to the NvmlTaskRunner.cpp if needed.
NOT_AUTO_GENERATED_FUNCTIONS = [
    "nvmlDeviceGetCount",  # no device argument
    "nvmlDeviceGetCount_v2",  # no device argument
    "nvmlDeviceOnSameBoard",  # 2 device arguments
    "nvmlDeviceGetTopologyCommonAncestor",  # 2 device arguments
    "nvmlDeviceGetP2PStatus",  # 2 device arguments
    "nvmlDeviceModifyDrainState",  # no device argument
    "nvmlDeviceQueryDrainState",  # no device argument
    "nvmlDeviceRemoveGpu",  # no device argument
    "nvmlDeviceRemoveGpu_v2",  # no device argument
    "nvmlDeviceDiscoverGpus",  # no device argument
    "nvmlDeviceGetDeviceHandleFromMigDeviceHandle",  # 1 migDevice argument
    "nvmlEventSetWait_v2",  # cannot run in the task runner because it can block
    "nvmlEventSetWait",  # cannot run in the task runner because it can block
    # should create manually to return SafeNvmlHandle
    "nvmlDeviceGetMigDeviceHandleByIndex",
    # should create manually to return SafeNvmlHandle
    "nvmlDeviceGetTopologyNearestGpus",
    "nvmlUnitGetDevices",  # should create manually to return SafeNvmlHandle
    "nvmlSystemGetTopologyGpuSet",  # should create manually to return SafeNvmlHandle
    # should create manually to return SafeComputeInstance
    "nvmlGpuInstanceGetComputeInstances",
    "nvmlDeviceGetGpuInstances",  # should create manually to return SafeGpuInstance
    "nvmlDeviceGetActiveVgpus",  # should create manually to return SafeVgpuInstance
    "nvmlDeviceGetSupportedVgpus",  # should create manually to return SafeVgpuTypeId
    "nvmlVgpuTypeGetMaxInstances",  # 1 device argument and 1 vgpuTypeId argument
]


def ProcessDeviceFunctionIfAny(funcname, argList, argNames, allDevicesFunctions):
    # GPM functions also take nvmlDevice as their first argument.
    if (not funcname.startswith("nvmlDevice") and
            funcname != "nvmlGpmMigSampleGet" and
            funcname != "nvmlGpmSampleGet" and
            funcname != "nvmlGpmQueryDeviceSupport"):
        return False
    originalFuncname = funcname
    # nvmlDeviceGetClockInfo => NvmlDeviceGetClockInfo
    generatedFuncname = "N" + funcname[1:]
    # (nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock) => (SafeNvmlHandle device, nvmlClockType_t type, unsigned int *clock)
    argList = argList.replace("(nvmlDevice_t device", "(SafeNvmlHandle device")
    # device, type, clock => type, clock
    argNamesWithoutFirst = ", ".join(argNames.split(",")[1:])
    fi = FunctionInfo(originalFuncname, generatedFuncname,
                      argList, argNames, argNamesWithoutFirst)
    allDevicesFunctions.append(fi)
    return True


def ProcessGpuInstanceFunctionIfAny(funcname, argList, argNames, gpuInstanceFunctions):
    if not funcname.startswith("nvmlGpuInstance"):
        return False
    originalFuncname = funcname
    # nvmlGpuInstanceGetInfo => NvmlGpuInstanceGetInfo
    generatedFuncname = "N" + funcname[1:]
    # (nvmlGpuInstance_t gpuInstance, nvmlGpuInstanceInfo_t *info) => (SafeGpuInstance gpuInstance, nvmlClockType_t type, unsigned int *clock)
    argList = argList.replace(
        "(nvmlGpuInstance_t gpuInstance", "(SafeGpuInstance gpuInstance")
    # gpuInstance, info => info
    argNamesWithoutFirst = ", ".join(argNames.split(",")[1:])
    fi = FunctionInfo(originalFuncname, generatedFuncname,
                      argList, argNames, argNamesWithoutFirst)
    gpuInstanceFunctions.append(fi)
    return True


def ProcessComputeInstanceFunctionIfAny(funcname, argList, argNames, computeInstanceFunctions):
    if not funcname.startswith("nvmlComputeInstance"):
        return False
    originalFuncname = funcname
    # nvmlComputeInstanceGetInfo => NvmlComputeInstanceGetInfo
    generatedFuncname = "N" + funcname[1:]
    # (nvmlComputeInstance_t computeInstance, nvmlComputeInstanceInfo_t *info) => (SafeComputeInstance computeInstance, nvmlClockType_t type, unsigned int *clock)
    argList = argList.replace(
        "(nvmlComputeInstance_t computeInstance", "(SafeComputeInstance computeInstance")
    # computeInstance, info => info
    argNamesWithoutFirst = ", ".join(argNames.split(",")[1:])
    fi = FunctionInfo(originalFuncname, generatedFuncname,
                      argList, argNames, argNamesWithoutFirst)
    computeInstanceFunctions.append(fi)
    return True


def ProcessVgpuInstanceFunctionIfAny(funcname, argList, argNames, vgpuInstanceFunctions):
    if not funcname.startswith("nvmlVgpuInstance"):
        return False
    originalFuncname = funcname
    # nvmlVgpuInstanceGetGpuPciId => NvmlVgpuInstanceGetGpuPciId
    generatedFuncname = "N" + funcname[1:]
    # (nvmlVgpuInstance_t vgpuInstance, char *vgpuPciId, unsigned int *length) => (SafeVgpuInstance vgpuInstance, char *vgpuPciId, unsigned int *length)
    argList = argList.replace(
        "(nvmlVgpuInstance_t vgpuInstance", "(SafeVgpuInstance vgpuInstance")
    # vgpuInstance, vgpuPciId, length
    argNamesWithoutFirst = ", ".join(argNames.split(",")[1:])
    fi = FunctionInfo(originalFuncname, generatedFuncname,
                      argList, argNames, argNamesWithoutFirst)
    vgpuInstanceFunctions.append(fi)
    return True


def ProcessVgpuTypeFunctionIfAny(funcname, argList, argNames, vgpuTypeFunctions):
    if not funcname.startswith("nvmlVgpuType"):
        return False
    originalFuncname = funcname
    # nvmlVgpuTypeGetName => NvmlVgpuTypeGetName
    generatedFuncname = "N" + funcname[1:]
    # (nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeName, unsigned int *size) => (SafeVgpuTypeId vgpuTypeId, char *vgpuTypeName, unsigned int *size)
    argList = argList.replace(
        "(nvmlVgpuTypeId_t vgpuTypeId", "(SafeVgpuTypeId vgpuTypeId")
    # vgpuTypeId, vgpuTypeName, size => vgpuTypeName, size
    argNamesWithoutFirst = ", ".join(argNames.split(",")[1:])
    fi = FunctionInfo(originalFuncname, generatedFuncname,
                      argList, argNames, argNamesWithoutFirst)
    vgpuTypeFunctions.append(fi)
    return True


def ProcessOtherFunction(funcname, argList, argNames, otherFunctions):
    originalFuncname = funcname
    # nvmlDeviceGetClockInfo => NvmlDeviceGetClockInfo
    generatedFuncname = "N" + funcname[1:]
    argNamesWithoutFirst = ", ".join(argNames.split(",")[1:])
    fi = FunctionInfo(originalFuncname, generatedFuncname,
                      argList, argNames, argNamesWithoutFirst)
    otherFunctions.append(fi)


def GetEntryPointsAllFunctions(entryPointsContents):
    entryPoints = entryPointsContents.split('NVML_ENTRY_POINT')
    first = True
    allDevicesFunctions = []
    gpuInstanceFunctions = []
    computeInstanceFunctions = []
    vgpuInstanceFunctions = []
    vgpuTypeFunctions = []
    otherFunctions = []
    for entryPoint in entryPoints:
        funcname, argList, argNames = GetFunctionSignature(entryPoint, first)
        first = False
        if not funcname or not argList:
            continue
        if funcname in NOT_AUTO_GENERATED_FUNCTIONS or funcname.startswith("nvmlDeviceGetHandleBy"):
            continue
        processed = ProcessDeviceFunctionIfAny(
            funcname, argList, argNames, allDevicesFunctions)
        processed = processed or ProcessGpuInstanceFunctionIfAny(
            funcname, argList, argNames, gpuInstanceFunctions)
        processed = processed or ProcessComputeInstanceFunctionIfAny(
            funcname, argList, argNames, computeInstanceFunctions)
        processed = processed or ProcessVgpuInstanceFunctionIfAny(
            funcname, argList, argNames, vgpuInstanceFunctions)
        processed = processed or ProcessVgpuTypeFunctionIfAny(
            funcname, argList, argNames, vgpuTypeFunctions)
        if not processed:
            ProcessOtherFunction(funcname, argList, argNames, otherFunctions)
    return allDevicesFunctions, gpuInstanceFunctions, computeInstanceFunctions, vgpuInstanceFunctions, vgpuTypeFunctions, otherFunctions


def GetGeneratedFunction(identity: str, identityAccessNvml: str, fi: FunctionInfo):
    '''
     This function generates the C++ code for a given FunctionInfo, producing both the main
     async (Enqueue-based) task runner method and its implementation for the NvmlTaskRunner class.
     - "identity": the variable name for safer wrapper (e.g., device).
     - "identity_access_nvml": string for code that accesses the underlying NVML handle (e.g., device.nvmlDevice, gpuInstance.gpuInstance).
     - "fi": FunctionInfo instance holding function naming and signature details.
     The generated C++ methods include:
       1. <func>: Checks if new tasks are blocked, enqueues the NVML operation as a task, and returns when completed.
       2. <func>Impl: Implements the operation by verifying generation, logging on mismatches, and calling the original NVML function.
    '''
    generatedFuncname = fi.generatedFuncname
    argList = fi.argList
    originalArgNames = fi.originalArgNames
    originalFuncname = fi.originalFuncname
    argNamesWithoutFirst = fi.argNamesWithoutFirst

    functionTemplate = NVML_SAFE_WARPPER_FUNCTION_TEMPLATE.substitute(
        generatedFuncname=generatedFuncname,
        generatedFuncnameImpl=generatedFuncname + "Impl",
        argList=argList,
        originalArgNames=originalArgNames,
        originalFuncname=originalFuncname,
        argNamesWithoutFirst=argNamesWithoutFirst,
        identity=identity,
        identityAccessNvml=identityAccessNvml,
        argsToAccessNvml=f'{", " + argNamesWithoutFirst if argNamesWithoutFirst else ""}')
    return functionTemplate


def WriteDeviceFunctions(file, allDevicesFunctions):
    for fi in allDevicesFunctions:
        functionTemplate = GetGeneratedFunction(
            "device", "device.nvmlDevice", fi)
        file.write(functionTemplate)


def WriteGpuInstanceFunctions(file, gpuInstanceFunctions):
    for fi in gpuInstanceFunctions:
        functionTemplate = GetGeneratedFunction(
            "gpuInstance", "gpuInstance.gpuInstance", fi)
        file.write(functionTemplate)


def WriteComputeInstanceFunctions(file, computeInstanceFunctions):
    for fi in computeInstanceFunctions:
        functionTemplate = GetGeneratedFunction(
            "computeInstance", "computeInstance.computeInstance", fi)
        file.write(functionTemplate)


def WriteVgpuInstanceFunctions(file, vgpuInstanceFunctions):
    for fi in vgpuInstanceFunctions:
        functionTemplate = GetGeneratedFunction(
            "vgpuInstance", "vgpuInstance.vgpuInstance", fi)
        file.write(functionTemplate)


def WriteVgpuTypeFunctions(file, vgpuTypeFunctions):
    for fi in vgpuTypeFunctions:
        functionTemplate = GetGeneratedFunction(
            "vgpuTypeId", "vgpuTypeId.vgpuTypeId", fi)
        file.write(functionTemplate)


def WriteOtherFunctions(file, nonDevicesFunctions):
    for fi in nonDevicesFunctions:
        originalFuncname = fi.originalFuncname
        generatedFuncname = fi.generatedFuncname
        argList = fi.argList
        originalArgNames = fi.originalArgNames
        argsToAccessNvml = f'{", " + originalArgNames if originalArgNames else ""}'
        functionTemplate = NVML_BASIC_FUNCTION_TEMPLATE.substitute(
            generatedFuncname=generatedFuncname,
            argList=argList,
            originalFuncname=originalFuncname,
            argsToAccessNvml=argsToAccessNvml)
        file.write(functionTemplate)


def WriteCppFile(allDevicesFunctions, gpuInstanceFunctions, computeInstanceFunctions, vgpuInstanceFunctions, vgpuTypeFunctions, otherFunctions, outputFolder):
    with open(outputFolder + "NvmlTaskRunnerGenerated.cpp", "w") as file:
        file.write(COPYRIGHT_NOTICE)
        file.write(AUTO_GENERATED_NOTICE)
        file.write(
            '#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored "-Wdeprecated-declarations"\n')
        file.write('// clang-format off\n')
        file.write("#include \"NvmlTaskRunner.hpp\"\n")
        WriteDeviceFunctions(file, allDevicesFunctions)
        WriteGpuInstanceFunctions(file, gpuInstanceFunctions)
        WriteComputeInstanceFunctions(file, computeInstanceFunctions)
        WriteVgpuInstanceFunctions(file, vgpuInstanceFunctions)
        WriteVgpuTypeFunctions(file, vgpuTypeFunctions)
        WriteOtherFunctions(file, otherFunctions)
        file.write('#pragma GCC diagnostic pop\n')


def WriteHeaderFiles(allDevicesFunctions, gpuInstanceFunctions, computeInstanceFunctions, vgpuInstanceFunctions, vgpuTypeFunctions, otherFunctions, outputFolder):
    with open(outputFolder + "NvmlTaskRunnerGeneratedPrivate.h", "w") as file:
        file.write(COPYRIGHT_NOTICE)
        file.write(AUTO_GENERATED_NOTICE)
        file.write('// clang-format off\n')
        for fi in allDevicesFunctions:
            file.write(
                f"nvmlReturn_t {fi.generatedFuncname}Impl{fi.argList};\n")

        for fi in gpuInstanceFunctions:
            file.write(
                f"nvmlReturn_t {fi.generatedFuncname}Impl{fi.argList};\n")

        for fi in computeInstanceFunctions:
            file.write(
                f"nvmlReturn_t {fi.generatedFuncname}Impl{fi.argList};\n")

        for fi in vgpuInstanceFunctions:
            file.write(
                f"nvmlReturn_t {fi.generatedFuncname}Impl{fi.argList};\n")

        for fi in vgpuTypeFunctions:
            file.write(
                f"nvmlReturn_t {fi.generatedFuncname}Impl{fi.argList};\n")

        for fi in otherFunctions:
            file.write(
                f"nvmlReturn_t {fi.generatedFuncname}Impl{fi.argList};\n")

    with open(outputFolder + "NvmlTaskRunnerGeneratedPublic.h", "w") as file:
        file.write(COPYRIGHT_NOTICE)
        file.write(AUTO_GENERATED_NOTICE)
        file.write('// clang-format off\n')
        for fi in allDevicesFunctions:
            file.write(f"nvmlReturn_t {fi.generatedFuncname}{fi.argList};\n")

        for fi in gpuInstanceFunctions:
            file.write(f"nvmlReturn_t {fi.generatedFuncname}{fi.argList};\n")

        for fi in computeInstanceFunctions:
            file.write(f"nvmlReturn_t {fi.generatedFuncname}{fi.argList};\n")

        for fi in vgpuInstanceFunctions:
            file.write(f"nvmlReturn_t {fi.generatedFuncname}{fi.argList};\n")

        for fi in vgpuTypeFunctions:
            file.write(f"nvmlReturn_t {fi.generatedFuncname}{fi.argList};\n")

        for fi in otherFunctions:
            file.write(f"nvmlReturn_t {fi.generatedFuncname}{fi.argList};\n")


def IsInDcgmRoot():
    return os.path.exists("./dcgmlib") and os.path.exists("./dcgmi") and os.path.exists("./nvml-injection")


def main():
    description = "NvmlTaskRunner methods generator.\n\n" \
                  "The NvmlTaskRunner class is designed to act as a transparent wrapper for NVML functions that execute within the task runner context. "\
                  "Since many of its methods are nearly identical, this is the script that automatically generates the code for them.\n\n" \
                  "This script generates the following files:\n" \
                  "- NvmlTaskRunnerGenerated.cpp\n" \
                  "- NvmlTaskRunnerGeneratedPrivate.h\n" \
                  "- NvmlTaskRunnerGeneratedPublic.h\n\n" \
                  "Example:\n" \
                  "\t# dcgmlib/src/NvmlTaskRunnerGenerator.py -i sdk/nvidia/nvml/nvml_entry_points.h -o dcgmlib/src/"
    parser = argparse.ArgumentParser(
        formatter_class=argparse.RawDescriptionHelpFormatter, description=description)
    parser.add_argument('-i', '--input-file',
                        default=NVML_ENTRY_POINTS_FILE, dest='inputPath')
    parser.add_argument('-o', '--output-folder',
                        default='dcgmlib/src/', dest='outputFolder')
    args = parser.parse_args()

    if not IsInDcgmRoot():
        logging.error(
            "Please run this script from the top-level DCGM directory.")
        sys.exit(1)

    with open(args.inputPath, 'r') as file:
        entryPointsContents = file.read()
    allDevicesFunctions, gpuInstanceFunctions, computeInstanceFunctions, vgpuInstanceFunctions, vgpuTypeFunctions, otherFunctions = GetEntryPointsAllFunctions(
        entryPointsContents)
    WriteCppFile(allDevicesFunctions, gpuInstanceFunctions, computeInstanceFunctions,
                 vgpuInstanceFunctions, vgpuTypeFunctions, otherFunctions, args.outputFolder)
    WriteHeaderFiles(allDevicesFunctions, gpuInstanceFunctions, computeInstanceFunctions,
                     vgpuInstanceFunctions, vgpuTypeFunctions, otherFunctions, args.outputFolder)


if __name__ == "__main__":
    main()
