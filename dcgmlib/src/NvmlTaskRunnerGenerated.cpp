/*
 * Copyright (c) 2025-2026, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * NOTE: This code is auto-generated by NvmlTaskRunnerGenerator.py
 * DO NOT EDIT MANUALLY
 */

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"
// clang-format off
#include "NvmlTaskRunner.hpp"

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetClockInfo(SafeNvmlHandle device, nvmlClockType_t type, unsigned int *clock)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetClockInfo", [this, device, type, clock]() {
        return NvmlDeviceGetClockInfoImpl(device, type, clock);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetClockInfoImpl(SafeNvmlHandle device, nvmlClockType_t type, unsigned int *clock)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetClockInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetClockInfo(device.nvmlDevice,  type,  clock);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxClockInfo(SafeNvmlHandle device, nvmlClockType_t type, unsigned int *clock)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMaxClockInfo", [this, device, type, clock]() {
        return NvmlDeviceGetMaxClockInfoImpl(device, type, clock);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxClockInfoImpl(SafeNvmlHandle device, nvmlClockType_t type, unsigned int *clock)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMaxClockInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMaxClockInfo(device.nvmlDevice,  type,  clock);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeMode(SafeNvmlHandle device, nvmlComputeMode_t *mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetComputeMode", [this, device, mode]() {
        return NvmlDeviceGetComputeModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeModeImpl(SafeNvmlHandle device, nvmlComputeMode_t *mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetComputeModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetComputeMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetComputeMode(SafeNvmlHandle device, nvmlComputeMode_t mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetComputeMode", [this, device, mode]() {
        return NvmlDeviceSetComputeModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetComputeModeImpl(SafeNvmlHandle device, nvmlComputeMode_t mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetComputeModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetComputeMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCudaComputeCapability(SafeNvmlHandle device, int *major, int *minor)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCudaComputeCapability", [this, device, major, minor]() {
        return NvmlDeviceGetCudaComputeCapabilityImpl(device, major, minor);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCudaComputeCapabilityImpl(SafeNvmlHandle device, int *major, int *minor)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCudaComputeCapabilityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCudaComputeCapability(device.nvmlDevice,  major,  minor);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetDriverModel(SafeNvmlHandle device, nvmlDriverModel_t driverModel, unsigned int flags)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetDriverModel", [this, device, driverModel, flags]() {
        return NvmlDeviceSetDriverModelImpl(device, driverModel, flags);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetDriverModelImpl(SafeNvmlHandle device, nvmlDriverModel_t driverModel, unsigned int flags)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetDriverModelImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetDriverModel(device.nvmlDevice,  driverModel,  flags);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDriverModel(SafeNvmlHandle device, nvmlDriverModel_t *current, nvmlDriverModel_t *pending)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDriverModel", [this, device, current, pending]() {
        return NvmlDeviceGetDriverModelImpl(device, current, pending);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDriverModelImpl(SafeNvmlHandle device, nvmlDriverModel_t *current, nvmlDriverModel_t *pending)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDriverModelImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDriverModel(device.nvmlDevice,  current,  pending);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetInforomVersion(SafeNvmlHandle device, nvmlInforomObject_t object, char *version, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetInforomVersion", [this, device, object, version, length]() {
        return NvmlDeviceGetInforomVersionImpl(device, object, version, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetInforomVersionImpl(SafeNvmlHandle device, nvmlInforomObject_t object, char *version, unsigned int length)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetInforomVersionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetInforomVersion(device.nvmlDevice,  object,  version,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetInforomImageVersion(SafeNvmlHandle device, char *version, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetInforomImageVersion", [this, device, version, length]() {
        return NvmlDeviceGetInforomImageVersionImpl(device, version, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetInforomImageVersionImpl(SafeNvmlHandle device, char *version, unsigned int length)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetInforomImageVersionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetInforomImageVersion(device.nvmlDevice,  version,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDisplayMode(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDisplayMode", [this, device, mode]() {
        return NvmlDeviceGetDisplayModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDisplayModeImpl(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDisplayModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDisplayMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEccMode(SafeNvmlHandle device, nvmlEnableState_t *current, nvmlEnableState_t *pending)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetEccMode", [this, device, current, pending]() {
        return NvmlDeviceGetEccModeImpl(device, current, pending);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEccModeImpl(SafeNvmlHandle device, nvmlEnableState_t *current, nvmlEnableState_t *pending)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetEccModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetEccMode(device.nvmlDevice,  current,  pending);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDefaultEccMode(SafeNvmlHandle device, nvmlEnableState_t *defaultMode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDefaultEccMode", [this, device, defaultMode]() {
        return NvmlDeviceGetDefaultEccModeImpl(device, defaultMode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDefaultEccModeImpl(SafeNvmlHandle device, nvmlEnableState_t *defaultMode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDefaultEccModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDefaultEccMode(device.nvmlDevice,  defaultMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBoardId(SafeNvmlHandle device, unsigned int *boardId)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetBoardId", [this, device, boardId]() {
        return NvmlDeviceGetBoardIdImpl(device, boardId);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBoardIdImpl(SafeNvmlHandle device, unsigned int *boardId)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetBoardIdImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetBoardId(device.nvmlDevice,  boardId);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMultiGpuBoard(SafeNvmlHandle device, unsigned int *multiGpuBool)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMultiGpuBoard", [this, device, multiGpuBool]() {
        return NvmlDeviceGetMultiGpuBoardImpl(device, multiGpuBool);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMultiGpuBoardImpl(SafeNvmlHandle device, unsigned int *multiGpuBool)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMultiGpuBoardImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMultiGpuBoard(device.nvmlDevice,  multiGpuBool);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDetailedEccErrors(SafeNvmlHandle device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, nvmlEccErrorCounts_t *eccCounts)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDetailedEccErrors", [this, device, errorType, counterType, eccCounts]() {
        return NvmlDeviceGetDetailedEccErrorsImpl(device, errorType, counterType, eccCounts);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDetailedEccErrorsImpl(SafeNvmlHandle device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, nvmlEccErrorCounts_t *eccCounts)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDetailedEccErrorsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDetailedEccErrors(device.nvmlDevice,  errorType,  counterType,  eccCounts);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTotalEccErrors(SafeNvmlHandle device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, unsigned long long *eccCounts)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetTotalEccErrors", [this, device, errorType, counterType, eccCounts]() {
        return NvmlDeviceGetTotalEccErrorsImpl(device, errorType, counterType, eccCounts);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTotalEccErrorsImpl(SafeNvmlHandle device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, unsigned long long *eccCounts)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetTotalEccErrorsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetTotalEccErrors(device.nvmlDevice,  errorType,  counterType,  eccCounts);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetEccMode(SafeNvmlHandle device, nvmlEnableState_t ecc)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetEccMode", [this, device, ecc]() {
        return NvmlDeviceSetEccModeImpl(device, ecc);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetEccModeImpl(SafeNvmlHandle device, nvmlEnableState_t ecc)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetEccModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetEccMode(device.nvmlDevice,  ecc);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceClearEccErrorCounts(SafeNvmlHandle device, nvmlEccCounterType_t counterType)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceClearEccErrorCounts", [this, device, counterType]() {
        return NvmlDeviceClearEccErrorCountsImpl(device, counterType);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceClearEccErrorCountsImpl(SafeNvmlHandle device, nvmlEccCounterType_t counterType)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceClearEccErrorCountsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceClearEccErrorCounts(device.nvmlDevice,  counterType);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetName(SafeNvmlHandle device, char *name, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetName", [this, device, name, length]() {
        return NvmlDeviceGetNameImpl(device, name, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNameImpl(SafeNvmlHandle device, char *name, unsigned int length)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNameImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetName(device.nvmlDevice,  name,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBrand(SafeNvmlHandle device, nvmlBrandType_t *type)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetBrand", [this, device, type]() {
        return NvmlDeviceGetBrandImpl(device, type);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBrandImpl(SafeNvmlHandle device, nvmlBrandType_t *type)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetBrandImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetBrand(device.nvmlDevice,  type);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSerial(SafeNvmlHandle device, char *serial, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSerial", [this, device, serial, length]() {
        return NvmlDeviceGetSerialImpl(device, serial, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSerialImpl(SafeNvmlHandle device, char *serial, unsigned int length)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSerialImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSerial(device.nvmlDevice,  serial,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBoardPartNumber(SafeNvmlHandle device, char *partNumber, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetBoardPartNumber", [this, device, partNumber, length]() {
        return NvmlDeviceGetBoardPartNumberImpl(device, partNumber, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBoardPartNumberImpl(SafeNvmlHandle device, char *partNumber, unsigned int length)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetBoardPartNumberImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetBoardPartNumber(device.nvmlDevice,  partNumber,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryAffinity(SafeNvmlHandle device, unsigned int nodeSetSize, unsigned long *nodeSet, nvmlAffinityScope_t scope)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMemoryAffinity", [this, device, nodeSetSize, nodeSet, scope]() {
        return NvmlDeviceGetMemoryAffinityImpl(device, nodeSetSize, nodeSet, scope);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryAffinityImpl(SafeNvmlHandle device, unsigned int nodeSetSize, unsigned long *nodeSet, nvmlAffinityScope_t scope)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMemoryAffinityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMemoryAffinity(device.nvmlDevice,  nodeSetSize,  nodeSet,  scope);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCpuAffinityWithinScope(SafeNvmlHandle device, unsigned int cpuSetSize, unsigned long *cpuSet, nvmlAffinityScope_t scope)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCpuAffinityWithinScope", [this, device, cpuSetSize, cpuSet, scope]() {
        return NvmlDeviceGetCpuAffinityWithinScopeImpl(device, cpuSetSize, cpuSet, scope);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCpuAffinityWithinScopeImpl(SafeNvmlHandle device, unsigned int cpuSetSize, unsigned long *cpuSet, nvmlAffinityScope_t scope)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCpuAffinityWithinScopeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCpuAffinityWithinScope(device.nvmlDevice,  cpuSetSize,  cpuSet,  scope);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCpuAffinity(SafeNvmlHandle device, unsigned int cpuSetSize, unsigned long *cpuSet)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCpuAffinity", [this, device, cpuSetSize, cpuSet]() {
        return NvmlDeviceGetCpuAffinityImpl(device, cpuSetSize, cpuSet);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCpuAffinityImpl(SafeNvmlHandle device, unsigned int cpuSetSize, unsigned long *cpuSet)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCpuAffinityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCpuAffinity(device.nvmlDevice,  cpuSetSize,  cpuSet);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetCpuAffinity(SafeNvmlHandle device)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetCpuAffinity", [this, device]() {
        return NvmlDeviceSetCpuAffinityImpl(device);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetCpuAffinityImpl(SafeNvmlHandle device)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetCpuAffinityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetCpuAffinity(device.nvmlDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceClearCpuAffinity(SafeNvmlHandle device)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceClearCpuAffinity", [this, device]() {
        return NvmlDeviceClearCpuAffinityImpl(device);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceClearCpuAffinityImpl(SafeNvmlHandle device)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceClearCpuAffinityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceClearCpuAffinity(device.nvmlDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetUUID(SafeNvmlHandle device, char *uuid, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetUUID", [this, device, uuid, length]() {
        return NvmlDeviceGetUUIDImpl(device, uuid, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetUUIDImpl(SafeNvmlHandle device, char *uuid, unsigned int length)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetUUIDImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetUUID(device.nvmlDevice,  uuid,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryInfo(SafeNvmlHandle device, nvmlMemory_t *memory)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMemoryInfo", [this, device, memory]() {
        return NvmlDeviceGetMemoryInfoImpl(device, memory);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryInfoImpl(SafeNvmlHandle device, nvmlMemory_t *memory)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMemoryInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMemoryInfo(device.nvmlDevice,  memory);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryInfo_v2(SafeNvmlHandle device, nvmlMemory_v2_t *memory)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMemoryInfo_v2", [this, device, memory]() {
        return NvmlDeviceGetMemoryInfo_v2Impl(device, memory);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryInfo_v2Impl(SafeNvmlHandle device, nvmlMemory_v2_t *memory)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMemoryInfo_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMemoryInfo_v2(device.nvmlDevice,  memory);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPciInfo(SafeNvmlHandle device, nvmlPciInfo_t *pci)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPciInfo", [this, device, pci]() {
        return NvmlDeviceGetPciInfoImpl(device, pci);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPciInfoImpl(SafeNvmlHandle device, nvmlPciInfo_t *pci)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPciInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPciInfo(device.nvmlDevice,  pci);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPciInfo_v2(SafeNvmlHandle device, nvmlPciInfo_t *pci)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPciInfo_v2", [this, device, pci]() {
        return NvmlDeviceGetPciInfo_v2Impl(device, pci);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPciInfo_v2Impl(SafeNvmlHandle device, nvmlPciInfo_t *pci)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPciInfo_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPciInfo_v2(device.nvmlDevice,  pci);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPciInfo_v3(SafeNvmlHandle device, nvmlPciInfo_t *pci)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPciInfo_v3", [this, device, pci]() {
        return NvmlDeviceGetPciInfo_v3Impl(device, pci);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPciInfo_v3Impl(SafeNvmlHandle device, nvmlPciInfo_t *pci)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPciInfo_v3Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPciInfo_v3(device.nvmlDevice,  pci);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPersistenceMode(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPersistenceMode", [this, device, mode]() {
        return NvmlDeviceGetPersistenceModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPersistenceModeImpl(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPersistenceModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPersistenceMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetPersistenceMode(SafeNvmlHandle device, nvmlEnableState_t mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetPersistenceMode", [this, device, mode]() {
        return NvmlDeviceSetPersistenceModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetPersistenceModeImpl(SafeNvmlHandle device, nvmlEnableState_t mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetPersistenceModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetPersistenceMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBAR1MemoryInfo(SafeNvmlHandle device, nvmlBAR1Memory_t *bar1Memory)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetBAR1MemoryInfo", [this, device, bar1Memory]() {
        return NvmlDeviceGetBAR1MemoryInfoImpl(device, bar1Memory);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBAR1MemoryInfoImpl(SafeNvmlHandle device, nvmlBAR1Memory_t *bar1Memory)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetBAR1MemoryInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetBAR1MemoryInfo(device.nvmlDevice,  bar1Memory);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetUnrepairableMemoryFlag(SafeNvmlHandle device, nvmlUnrepairableMemoryStatus_t *unrepairableMemoryStatus)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetUnrepairableMemoryFlag", [this, device, unrepairableMemoryStatus]() {
        return NvmlDeviceGetUnrepairableMemoryFlagImpl(device, unrepairableMemoryStatus);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetUnrepairableMemoryFlagImpl(SafeNvmlHandle device, nvmlUnrepairableMemoryStatus_t *unrepairableMemoryStatus)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetUnrepairableMemoryFlagImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetUnrepairableMemoryFlag(device.nvmlDevice,  unrepairableMemoryStatus);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetViolationStatus(SafeNvmlHandle device, nvmlPerfPolicyType_t perfPolicyType, nvmlViolationTime_t *violTime)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetViolationStatus", [this, device, perfPolicyType, violTime]() {
        return NvmlDeviceGetViolationStatusImpl(device, perfPolicyType, violTime);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetViolationStatusImpl(SafeNvmlHandle device, nvmlPerfPolicyType_t perfPolicyType, nvmlViolationTime_t *violTime)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetViolationStatusImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetViolationStatus(device.nvmlDevice,  perfPolicyType,  violTime);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerState(SafeNvmlHandle device, nvmlPstates_t *pState)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPowerState", [this, device, pState]() {
        return NvmlDeviceGetPowerStateImpl(device, pState);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerStateImpl(SafeNvmlHandle device, nvmlPstates_t *pState)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPowerStateImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPowerState(device.nvmlDevice,  pState);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPerformanceState(SafeNvmlHandle device, nvmlPstates_t *pState)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPerformanceState", [this, device, pState]() {
        return NvmlDeviceGetPerformanceStateImpl(device, pState);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPerformanceStateImpl(SafeNvmlHandle device, nvmlPstates_t *pState)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPerformanceStateImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPerformanceState(device.nvmlDevice,  pState);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerUsage(SafeNvmlHandle device, unsigned int *power)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPowerUsage", [this, device, power]() {
        return NvmlDeviceGetPowerUsageImpl(device, power);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerUsageImpl(SafeNvmlHandle device, unsigned int *power)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPowerUsageImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPowerUsage(device.nvmlDevice,  power);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTotalEnergyConsumption(SafeNvmlHandle device, unsigned long long *energy)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetTotalEnergyConsumption", [this, device, energy]() {
        return NvmlDeviceGetTotalEnergyConsumptionImpl(device, energy);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTotalEnergyConsumptionImpl(SafeNvmlHandle device, unsigned long long *energy)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetTotalEnergyConsumptionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetTotalEnergyConsumption(device.nvmlDevice,  energy);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementMode(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPowerManagementMode", [this, device, mode]() {
        return NvmlDeviceGetPowerManagementModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementModeImpl(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPowerManagementModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPowerManagementMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementLimit(SafeNvmlHandle device, unsigned int *limit)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPowerManagementLimit", [this, device, limit]() {
        return NvmlDeviceGetPowerManagementLimitImpl(device, limit);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementLimitImpl(SafeNvmlHandle device, unsigned int *limit)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPowerManagementLimitImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPowerManagementLimit(device.nvmlDevice,  limit);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTemperature(SafeNvmlHandle device, nvmlTemperatureSensors_t sensorType, unsigned int *temp)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetTemperature", [this, device, sensorType, temp]() {
        return NvmlDeviceGetTemperatureImpl(device, sensorType, temp);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTemperatureImpl(SafeNvmlHandle device, nvmlTemperatureSensors_t sensorType, unsigned int *temp)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetTemperatureImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetTemperature(device.nvmlDevice,  sensorType,  temp);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTemperatureThreshold(SafeNvmlHandle device, nvmlTemperatureThresholds_t thresholdType, unsigned int *temp)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetTemperatureThreshold", [this, device, thresholdType, temp]() {
        return NvmlDeviceGetTemperatureThresholdImpl(device, thresholdType, temp);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTemperatureThresholdImpl(SafeNvmlHandle device, nvmlTemperatureThresholds_t thresholdType, unsigned int *temp)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetTemperatureThresholdImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetTemperatureThreshold(device.nvmlDevice,  thresholdType,  temp);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetTemperatureThreshold(SafeNvmlHandle device, nvmlTemperatureThresholds_t thresholdType, int *temp)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetTemperatureThreshold", [this, device, thresholdType, temp]() {
        return NvmlDeviceSetTemperatureThresholdImpl(device, thresholdType, temp);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetTemperatureThresholdImpl(SafeNvmlHandle device, nvmlTemperatureThresholds_t thresholdType, int *temp)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetTemperatureThresholdImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetTemperatureThreshold(device.nvmlDevice,  thresholdType,  temp);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMarginTemperature(SafeNvmlHandle device, nvmlMarginTemperature_t *marginTempInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMarginTemperature", [this, device, marginTempInfo]() {
        return NvmlDeviceGetMarginTemperatureImpl(device, marginTempInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMarginTemperatureImpl(SafeNvmlHandle device, nvmlMarginTemperature_t *marginTempInfo)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMarginTemperatureImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMarginTemperature(device.nvmlDevice,  marginTempInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFanSpeed(SafeNvmlHandle device, unsigned int *speed)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetFanSpeed", [this, device, speed]() {
        return NvmlDeviceGetFanSpeedImpl(device, speed);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFanSpeedImpl(SafeNvmlHandle device, unsigned int *speed)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetFanSpeedImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetFanSpeed(device.nvmlDevice,  speed);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFanSpeed_v2(SafeNvmlHandle device, unsigned int fan, unsigned int *speed)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetFanSpeed_v2", [this, device, fan, speed]() {
        return NvmlDeviceGetFanSpeed_v2Impl(device, fan, speed);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFanSpeed_v2Impl(SafeNvmlHandle device, unsigned int fan, unsigned int *speed)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetFanSpeed_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetFanSpeed_v2(device.nvmlDevice,  fan,  speed);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTargetFanSpeed(SafeNvmlHandle device, unsigned int fan, unsigned int *targetSpeed)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetTargetFanSpeed", [this, device, fan, targetSpeed]() {
        return NvmlDeviceGetTargetFanSpeedImpl(device, fan, targetSpeed);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetTargetFanSpeedImpl(SafeNvmlHandle device, unsigned int fan, unsigned int *targetSpeed)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetTargetFanSpeedImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetTargetFanSpeed(device.nvmlDevice,  fan,  targetSpeed);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNumFans(SafeNvmlHandle device, unsigned int *numFans)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNumFans", [this, device, numFans]() {
        return NvmlDeviceGetNumFansImpl(device, numFans);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNumFansImpl(SafeNvmlHandle device, unsigned int *numFans)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNumFansImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNumFans(device.nvmlDevice,  numFans);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetUtilizationRates(SafeNvmlHandle device, nvmlUtilization_t *utilization)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetUtilizationRates", [this, device, utilization]() {
        return NvmlDeviceGetUtilizationRatesImpl(device, utilization);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetUtilizationRatesImpl(SafeNvmlHandle device, nvmlUtilization_t *utilization)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetUtilizationRatesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetUtilizationRates(device.nvmlDevice,  utilization);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderUtilization(SafeNvmlHandle device, unsigned int *utilization, unsigned int *samplingPeriodUs)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetEncoderUtilization", [this, device, utilization, samplingPeriodUs]() {
        return NvmlDeviceGetEncoderUtilizationImpl(device, utilization, samplingPeriodUs);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderUtilizationImpl(SafeNvmlHandle device, unsigned int *utilization, unsigned int *samplingPeriodUs)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetEncoderUtilizationImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetEncoderUtilization(device.nvmlDevice,  utilization,  samplingPeriodUs);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDecoderUtilization(SafeNvmlHandle device, unsigned int *utilization, unsigned int *samplingPeriodUs)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDecoderUtilization", [this, device, utilization, samplingPeriodUs]() {
        return NvmlDeviceGetDecoderUtilizationImpl(device, utilization, samplingPeriodUs);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDecoderUtilizationImpl(SafeNvmlHandle device, unsigned int *utilization, unsigned int *samplingPeriodUs)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDecoderUtilizationImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDecoderUtilization(device.nvmlDevice,  utilization,  samplingPeriodUs);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxPcieLinkGeneration(SafeNvmlHandle device, unsigned int *maxLinkGen)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMaxPcieLinkGeneration", [this, device, maxLinkGen]() {
        return NvmlDeviceGetMaxPcieLinkGenerationImpl(device, maxLinkGen);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxPcieLinkGenerationImpl(SafeNvmlHandle device, unsigned int *maxLinkGen)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMaxPcieLinkGenerationImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMaxPcieLinkGeneration(device.nvmlDevice,  maxLinkGen);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxPcieLinkWidth(SafeNvmlHandle device, unsigned int *maxLinkWidth)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMaxPcieLinkWidth", [this, device, maxLinkWidth]() {
        return NvmlDeviceGetMaxPcieLinkWidthImpl(device, maxLinkWidth);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxPcieLinkWidthImpl(SafeNvmlHandle device, unsigned int *maxLinkWidth)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMaxPcieLinkWidthImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMaxPcieLinkWidth(device.nvmlDevice,  maxLinkWidth);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrPcieLinkGeneration(SafeNvmlHandle device, unsigned int *currLinkGen)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCurrPcieLinkGeneration", [this, device, currLinkGen]() {
        return NvmlDeviceGetCurrPcieLinkGenerationImpl(device, currLinkGen);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrPcieLinkGenerationImpl(SafeNvmlHandle device, unsigned int *currLinkGen)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCurrPcieLinkGenerationImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCurrPcieLinkGeneration(device.nvmlDevice,  currLinkGen);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrPcieLinkWidth(SafeNvmlHandle device, unsigned int *currLinkWidth)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCurrPcieLinkWidth", [this, device, currLinkWidth]() {
        return NvmlDeviceGetCurrPcieLinkWidthImpl(device, currLinkWidth);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrPcieLinkWidthImpl(SafeNvmlHandle device, unsigned int *currLinkWidth)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCurrPcieLinkWidthImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCurrPcieLinkWidth(device.nvmlDevice,  currLinkWidth);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVbiosVersion(SafeNvmlHandle device, char *version, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetVbiosVersion", [this, device, version, length]() {
        return NvmlDeviceGetVbiosVersionImpl(device, version, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVbiosVersionImpl(SafeNvmlHandle device, char *version, unsigned int length)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetVbiosVersionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetVbiosVersion(device.nvmlDevice,  version,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBridgeChipInfo(SafeNvmlHandle device, nvmlBridgeChipHierarchy_t *bridgeHierarchy)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetBridgeChipInfo", [this, device, bridgeHierarchy]() {
        return NvmlDeviceGetBridgeChipInfoImpl(device, bridgeHierarchy);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBridgeChipInfoImpl(SafeNvmlHandle device, nvmlBridgeChipHierarchy_t *bridgeHierarchy)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetBridgeChipInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetBridgeChipInfo(device.nvmlDevice,  bridgeHierarchy);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceRegisterEvents(SafeNvmlHandle device, unsigned long long eventTypes, nvmlEventSet_t set)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceRegisterEvents", [this, device, eventTypes, set]() {
        return NvmlDeviceRegisterEventsImpl(device, eventTypes, set);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceRegisterEventsImpl(SafeNvmlHandle device, unsigned long long eventTypes, nvmlEventSet_t set)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceRegisterEventsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceRegisterEvents(device.nvmlDevice,  eventTypes,  set);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedEventTypes(SafeNvmlHandle device, unsigned long long *eventTypes)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSupportedEventTypes", [this, device, eventTypes]() {
        return NvmlDeviceGetSupportedEventTypesImpl(device, eventTypes);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedEventTypesImpl(SafeNvmlHandle device, unsigned long long *eventTypes)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSupportedEventTypesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSupportedEventTypes(device.nvmlDevice,  eventTypes);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeRunningProcesses(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v1_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetComputeRunningProcesses", [this, device, infoCount, infos]() {
        return NvmlDeviceGetComputeRunningProcessesImpl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeRunningProcessesImpl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v1_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetComputeRunningProcessesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetComputeRunningProcesses(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeRunningProcesses_v2(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v2_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetComputeRunningProcesses_v2", [this, device, infoCount, infos]() {
        return NvmlDeviceGetComputeRunningProcesses_v2Impl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeRunningProcesses_v2Impl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v2_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetComputeRunningProcesses_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetComputeRunningProcesses_v2(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeRunningProcesses_v3(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetComputeRunningProcesses_v3", [this, device, infoCount, infos]() {
        return NvmlDeviceGetComputeRunningProcesses_v3Impl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeRunningProcesses_v3Impl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetComputeRunningProcesses_v3Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetComputeRunningProcesses_v3(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGraphicsRunningProcesses(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v1_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGraphicsRunningProcesses", [this, device, infoCount, infos]() {
        return NvmlDeviceGetGraphicsRunningProcessesImpl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGraphicsRunningProcessesImpl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v1_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGraphicsRunningProcessesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGraphicsRunningProcesses(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGraphicsRunningProcesses_v2(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v2_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGraphicsRunningProcesses_v2", [this, device, infoCount, infos]() {
        return NvmlDeviceGetGraphicsRunningProcesses_v2Impl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGraphicsRunningProcesses_v2Impl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v2_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGraphicsRunningProcesses_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGraphicsRunningProcesses_v2(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGraphicsRunningProcesses_v3(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGraphicsRunningProcesses_v3", [this, device, infoCount, infos]() {
        return NvmlDeviceGetGraphicsRunningProcesses_v3Impl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGraphicsRunningProcesses_v3Impl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGraphicsRunningProcesses_v3Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGraphicsRunningProcesses_v3(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMPSComputeRunningProcesses(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v1_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMPSComputeRunningProcesses", [this, device, infoCount, infos]() {
        return NvmlDeviceGetMPSComputeRunningProcessesImpl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMPSComputeRunningProcessesImpl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v1_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMPSComputeRunningProcessesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMPSComputeRunningProcesses(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMPSComputeRunningProcesses_v2(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v2_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMPSComputeRunningProcesses_v2", [this, device, infoCount, infos]() {
        return NvmlDeviceGetMPSComputeRunningProcesses_v2Impl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMPSComputeRunningProcesses_v2Impl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_v2_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMPSComputeRunningProcesses_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMPSComputeRunningProcesses_v2(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMPSComputeRunningProcesses_v3(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_t *infos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMPSComputeRunningProcesses_v3", [this, device, infoCount, infos]() {
        return NvmlDeviceGetMPSComputeRunningProcesses_v3Impl(device, infoCount, infos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMPSComputeRunningProcesses_v3Impl(SafeNvmlHandle device, unsigned int *infoCount, nvmlProcessInfo_t *infos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMPSComputeRunningProcesses_v3Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMPSComputeRunningProcesses_v3(device.nvmlDevice,  infoCount,  infos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetInforomConfigurationChecksum(SafeNvmlHandle device, unsigned int *checksum)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetInforomConfigurationChecksum", [this, device, checksum]() {
        return NvmlDeviceGetInforomConfigurationChecksumImpl(device, checksum);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetInforomConfigurationChecksumImpl(SafeNvmlHandle device, unsigned int *checksum)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetInforomConfigurationChecksumImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetInforomConfigurationChecksum(device.nvmlDevice,  checksum);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceValidateInforom(SafeNvmlHandle device)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceValidateInforom", [this, device]() {
        return NvmlDeviceValidateInforomImpl(device);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceValidateInforomImpl(SafeNvmlHandle device)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceValidateInforomImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceValidateInforom(device.nvmlDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuOperationMode(SafeNvmlHandle device, nvmlGpuOperationMode_t *current, nvmlGpuOperationMode_t *pending)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuOperationMode", [this, device, current, pending]() {
        return NvmlDeviceGetGpuOperationModeImpl(device, current, pending);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuOperationModeImpl(SafeNvmlHandle device, nvmlGpuOperationMode_t *current, nvmlGpuOperationMode_t *pending)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuOperationModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuOperationMode(device.nvmlDevice,  current,  pending);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetGpuOperationMode(SafeNvmlHandle device, nvmlGpuOperationMode_t mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetGpuOperationMode", [this, device, mode]() {
        return NvmlDeviceSetGpuOperationModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetGpuOperationModeImpl(SafeNvmlHandle device, nvmlGpuOperationMode_t mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetGpuOperationModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetGpuOperationMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDisplayActive(SafeNvmlHandle device, nvmlEnableState_t *isActive)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDisplayActive", [this, device, isActive]() {
        return NvmlDeviceGetDisplayActiveImpl(device, isActive);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDisplayActiveImpl(SafeNvmlHandle device, nvmlEnableState_t *isActive)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDisplayActiveImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDisplayActive(device.nvmlDevice,  isActive);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryErrorCounter(SafeNvmlHandle device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, nvmlMemoryLocation_t locationType, unsigned long long *count)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMemoryErrorCounter", [this, device, errorType, counterType, locationType, count]() {
        return NvmlDeviceGetMemoryErrorCounterImpl(device, errorType, counterType, locationType, count);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryErrorCounterImpl(SafeNvmlHandle device, nvmlMemoryErrorType_t errorType, nvmlEccCounterType_t counterType, nvmlMemoryLocation_t locationType, unsigned long long *count)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMemoryErrorCounterImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMemoryErrorCounter(device.nvmlDevice,  errorType,  counterType,  locationType,  count);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSramEccErrorStatus(SafeNvmlHandle device, nvmlEccSramErrorStatus_t *status)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSramEccErrorStatus", [this, device, status]() {
        return NvmlDeviceGetSramEccErrorStatusImpl(device, status);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSramEccErrorStatusImpl(SafeNvmlHandle device, nvmlEccSramErrorStatus_t *status)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSramEccErrorStatusImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSramEccErrorStatus(device.nvmlDevice,  status);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetGpuLockedClocks(SafeNvmlHandle device, unsigned int minGpuClockMHz, unsigned int maxGpuClockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetGpuLockedClocks", [this, device, minGpuClockMHz, maxGpuClockMHz]() {
        return NvmlDeviceSetGpuLockedClocksImpl(device, minGpuClockMHz, maxGpuClockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetGpuLockedClocksImpl(SafeNvmlHandle device, unsigned int minGpuClockMHz, unsigned int maxGpuClockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetGpuLockedClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetGpuLockedClocks(device.nvmlDevice,  minGpuClockMHz,  maxGpuClockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetGpuLockedClocks(SafeNvmlHandle device)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceResetGpuLockedClocks", [this, device]() {
        return NvmlDeviceResetGpuLockedClocksImpl(device);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetGpuLockedClocksImpl(SafeNvmlHandle device)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceResetGpuLockedClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceResetGpuLockedClocks(device.nvmlDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetMemoryLockedClocks(SafeNvmlHandle device, unsigned int minMemClockMHz, unsigned int maxMemClockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetMemoryLockedClocks", [this, device, minMemClockMHz, maxMemClockMHz]() {
        return NvmlDeviceSetMemoryLockedClocksImpl(device, minMemClockMHz, maxMemClockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetMemoryLockedClocksImpl(SafeNvmlHandle device, unsigned int minMemClockMHz, unsigned int maxMemClockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetMemoryLockedClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetMemoryLockedClocks(device.nvmlDevice,  minMemClockMHz,  maxMemClockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetMemoryLockedClocks(SafeNvmlHandle device)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceResetMemoryLockedClocks", [this, device]() {
        return NvmlDeviceResetMemoryLockedClocksImpl(device);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetMemoryLockedClocksImpl(SafeNvmlHandle device)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceResetMemoryLockedClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceResetMemoryLockedClocks(device.nvmlDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetApplicationsClocks(SafeNvmlHandle device, unsigned int memClockMHz, unsigned int graphicsClockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetApplicationsClocks", [this, device, memClockMHz, graphicsClockMHz]() {
        return NvmlDeviceSetApplicationsClocksImpl(device, memClockMHz, graphicsClockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetApplicationsClocksImpl(SafeNvmlHandle device, unsigned int memClockMHz, unsigned int graphicsClockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetApplicationsClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetApplicationsClocks(device.nvmlDevice,  memClockMHz,  graphicsClockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetApplicationsClock(SafeNvmlHandle device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetApplicationsClock", [this, device, clockType, clockMHz]() {
        return NvmlDeviceGetApplicationsClockImpl(device, clockType, clockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetApplicationsClockImpl(SafeNvmlHandle device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetApplicationsClockImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetApplicationsClock(device.nvmlDevice,  clockType,  clockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxCustomerBoostClock(SafeNvmlHandle device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMaxCustomerBoostClock", [this, device, clockType, clockMHz]() {
        return NvmlDeviceGetMaxCustomerBoostClockImpl(device, clockType, clockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxCustomerBoostClockImpl(SafeNvmlHandle device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMaxCustomerBoostClockImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMaxCustomerBoostClock(device.nvmlDevice,  clockType,  clockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetClock(SafeNvmlHandle device, nvmlClockType_t clockType, nvmlClockId_t clockId, unsigned int *clockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetClock", [this, device, clockType, clockId, clockMHz]() {
        return NvmlDeviceGetClockImpl(device, clockType, clockId, clockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetClockImpl(SafeNvmlHandle device, nvmlClockType_t clockType, nvmlClockId_t clockId, unsigned int *clockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetClockImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetClock(device.nvmlDevice,  clockType,  clockId,  clockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDefaultApplicationsClock(SafeNvmlHandle device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDefaultApplicationsClock", [this, device, clockType, clockMHz]() {
        return NvmlDeviceGetDefaultApplicationsClockImpl(device, clockType, clockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDefaultApplicationsClockImpl(SafeNvmlHandle device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDefaultApplicationsClockImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDefaultApplicationsClock(device.nvmlDevice,  clockType,  clockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetApplicationsClocks(SafeNvmlHandle device)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceResetApplicationsClocks", [this, device]() {
        return NvmlDeviceResetApplicationsClocksImpl(device);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetApplicationsClocksImpl(SafeNvmlHandle device)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceResetApplicationsClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceResetApplicationsClocks(device.nvmlDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedMemoryClocks(SafeNvmlHandle device, unsigned int *count, unsigned int *clocksMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSupportedMemoryClocks", [this, device, count, clocksMHz]() {
        return NvmlDeviceGetSupportedMemoryClocksImpl(device, count, clocksMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedMemoryClocksImpl(SafeNvmlHandle device, unsigned int *count, unsigned int *clocksMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSupportedMemoryClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSupportedMemoryClocks(device.nvmlDevice,  count,  clocksMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedGraphicsClocks(SafeNvmlHandle device, unsigned int memoryClockMHz, unsigned int *count, unsigned int *clocksMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSupportedGraphicsClocks", [this, device, memoryClockMHz, count, clocksMHz]() {
        return NvmlDeviceGetSupportedGraphicsClocksImpl(device, memoryClockMHz, count, clocksMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedGraphicsClocksImpl(SafeNvmlHandle device, unsigned int memoryClockMHz, unsigned int *count, unsigned int *clocksMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSupportedGraphicsClocksImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSupportedGraphicsClocks(device.nvmlDevice,  memoryClockMHz,  count,  clocksMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAutoBoostedClocksEnabled(SafeNvmlHandle device, nvmlEnableState_t *isEnabled, nvmlEnableState_t *defaultIsEnabled)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAutoBoostedClocksEnabled", [this, device, isEnabled, defaultIsEnabled]() {
        return NvmlDeviceGetAutoBoostedClocksEnabledImpl(device, isEnabled, defaultIsEnabled);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAutoBoostedClocksEnabledImpl(SafeNvmlHandle device, nvmlEnableState_t *isEnabled, nvmlEnableState_t *defaultIsEnabled)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAutoBoostedClocksEnabledImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAutoBoostedClocksEnabled(device.nvmlDevice,  isEnabled,  defaultIsEnabled);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetAutoBoostedClocksEnabled(SafeNvmlHandle device, nvmlEnableState_t enabled)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetAutoBoostedClocksEnabled", [this, device, enabled]() {
        return NvmlDeviceSetAutoBoostedClocksEnabledImpl(device, enabled);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetAutoBoostedClocksEnabledImpl(SafeNvmlHandle device, nvmlEnableState_t enabled)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetAutoBoostedClocksEnabledImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetAutoBoostedClocksEnabled(device.nvmlDevice,  enabled);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetDefaultAutoBoostedClocksEnabled(SafeNvmlHandle device, nvmlEnableState_t enabled, unsigned int flags)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetDefaultAutoBoostedClocksEnabled", [this, device, enabled, flags]() {
        return NvmlDeviceSetDefaultAutoBoostedClocksEnabledImpl(device, enabled, flags);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetDefaultAutoBoostedClocksEnabledImpl(SafeNvmlHandle device, nvmlEnableState_t enabled, unsigned int flags)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetDefaultAutoBoostedClocksEnabledImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetDefaultAutoBoostedClocksEnabled(device.nvmlDevice,  enabled,  flags);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementLimitConstraints(SafeNvmlHandle device, unsigned int *minLimit, unsigned int *maxLimit)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPowerManagementLimitConstraints", [this, device, minLimit, maxLimit]() {
        return NvmlDeviceGetPowerManagementLimitConstraintsImpl(device, minLimit, maxLimit);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementLimitConstraintsImpl(SafeNvmlHandle device, unsigned int *minLimit, unsigned int *maxLimit)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPowerManagementLimitConstraintsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPowerManagementLimitConstraints(device.nvmlDevice,  minLimit,  maxLimit);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementDefaultLimit(SafeNvmlHandle device, unsigned int *defaultLimit)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPowerManagementDefaultLimit", [this, device, defaultLimit]() {
        return NvmlDeviceGetPowerManagementDefaultLimitImpl(device, defaultLimit);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerManagementDefaultLimitImpl(SafeNvmlHandle device, unsigned int *defaultLimit)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPowerManagementDefaultLimitImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPowerManagementDefaultLimit(device.nvmlDevice,  defaultLimit);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetPowerManagementLimit(SafeNvmlHandle device, unsigned int limit)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetPowerManagementLimit", [this, device, limit]() {
        return NvmlDeviceSetPowerManagementLimitImpl(device, limit);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetPowerManagementLimitImpl(SafeNvmlHandle device, unsigned int limit)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetPowerManagementLimitImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetPowerManagementLimit(device.nvmlDevice,  limit);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrentClocksEventReasons(SafeNvmlHandle device, unsigned long long *clocksEventReasons)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCurrentClocksEventReasons", [this, device, clocksEventReasons]() {
        return NvmlDeviceGetCurrentClocksEventReasonsImpl(device, clocksEventReasons);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrentClocksEventReasonsImpl(SafeNvmlHandle device, unsigned long long *clocksEventReasons)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCurrentClocksEventReasonsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCurrentClocksEventReasons(device.nvmlDevice,  clocksEventReasons);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrentClocksThrottleReasons(SafeNvmlHandle device, unsigned long long *clocksThrottleReasons)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCurrentClocksThrottleReasons", [this, device, clocksThrottleReasons]() {
        return NvmlDeviceGetCurrentClocksThrottleReasonsImpl(device, clocksThrottleReasons);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCurrentClocksThrottleReasonsImpl(SafeNvmlHandle device, unsigned long long *clocksThrottleReasons)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCurrentClocksThrottleReasonsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCurrentClocksThrottleReasons(device.nvmlDevice,  clocksThrottleReasons);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedClocksEventReasons(SafeNvmlHandle device, unsigned long long *supportedClocksEventReasons)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSupportedClocksEventReasons", [this, device, supportedClocksEventReasons]() {
        return NvmlDeviceGetSupportedClocksEventReasonsImpl(device, supportedClocksEventReasons);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedClocksEventReasonsImpl(SafeNvmlHandle device, unsigned long long *supportedClocksEventReasons)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSupportedClocksEventReasonsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSupportedClocksEventReasons(device.nvmlDevice,  supportedClocksEventReasons);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedClocksThrottleReasons(SafeNvmlHandle device, unsigned long long *supportedClocksThrottleReasons)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSupportedClocksThrottleReasons", [this, device, supportedClocksThrottleReasons]() {
        return NvmlDeviceGetSupportedClocksThrottleReasonsImpl(device, supportedClocksThrottleReasons);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedClocksThrottleReasonsImpl(SafeNvmlHandle device, unsigned long long *supportedClocksThrottleReasons)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSupportedClocksThrottleReasonsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSupportedClocksThrottleReasons(device.nvmlDevice,  supportedClocksThrottleReasons);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetIndex(SafeNvmlHandle device, unsigned int *index)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetIndex", [this, device, index]() {
        return NvmlDeviceGetIndexImpl(device, index);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetIndexImpl(SafeNvmlHandle device, unsigned int *index)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetIndexImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetIndex(device.nvmlDevice,  index);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingMode(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAccountingMode", [this, device, mode]() {
        return NvmlDeviceGetAccountingModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingModeImpl(SafeNvmlHandle device, nvmlEnableState_t *mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAccountingModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAccountingMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetAccountingMode(SafeNvmlHandle device, nvmlEnableState_t mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetAccountingMode", [this, device, mode]() {
        return NvmlDeviceSetAccountingModeImpl(device, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetAccountingModeImpl(SafeNvmlHandle device, nvmlEnableState_t mode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetAccountingModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetAccountingMode(device.nvmlDevice,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceClearAccountingPids(SafeNvmlHandle device)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceClearAccountingPids", [this, device]() {
        return NvmlDeviceClearAccountingPidsImpl(device);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceClearAccountingPidsImpl(SafeNvmlHandle device)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceClearAccountingPidsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceClearAccountingPids(device.nvmlDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingStats(SafeNvmlHandle device, unsigned int pid, nvmlAccountingStats_t *stats)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAccountingStats", [this, device, pid, stats]() {
        return NvmlDeviceGetAccountingStatsImpl(device, pid, stats);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingStatsImpl(SafeNvmlHandle device, unsigned int pid, nvmlAccountingStats_t *stats)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAccountingStatsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAccountingStats(device.nvmlDevice,  pid,  stats);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingPids(SafeNvmlHandle device, unsigned int *count, unsigned int *pids)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAccountingPids", [this, device, count, pids]() {
        return NvmlDeviceGetAccountingPidsImpl(device, count, pids);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingPidsImpl(SafeNvmlHandle device, unsigned int *count, unsigned int *pids)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAccountingPidsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAccountingPids(device.nvmlDevice,  count,  pids);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingBufferSize(SafeNvmlHandle device, unsigned int *bufferSize)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAccountingBufferSize", [this, device, bufferSize]() {
        return NvmlDeviceGetAccountingBufferSizeImpl(device, bufferSize);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAccountingBufferSizeImpl(SafeNvmlHandle device, unsigned int *bufferSize)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAccountingBufferSizeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAccountingBufferSize(device.nvmlDevice,  bufferSize);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRetiredPages(SafeNvmlHandle device, nvmlPageRetirementCause_t sourceFilter, unsigned int *count, unsigned long long *addresses)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetRetiredPages", [this, device, sourceFilter, count, addresses]() {
        return NvmlDeviceGetRetiredPagesImpl(device, sourceFilter, count, addresses);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRetiredPagesImpl(SafeNvmlHandle device, nvmlPageRetirementCause_t sourceFilter, unsigned int *count, unsigned long long *addresses)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetRetiredPagesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetRetiredPages(device.nvmlDevice,  sourceFilter,  count,  addresses);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRetiredPages_v2(SafeNvmlHandle device, nvmlPageRetirementCause_t sourceFilter, unsigned int *count, unsigned long long *addresses, unsigned long long *timestamps)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetRetiredPages_v2", [this, device, sourceFilter, count, addresses, timestamps]() {
        return NvmlDeviceGetRetiredPages_v2Impl(device, sourceFilter, count, addresses, timestamps);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRetiredPages_v2Impl(SafeNvmlHandle device, nvmlPageRetirementCause_t sourceFilter, unsigned int *count, unsigned long long *addresses, unsigned long long *timestamps)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetRetiredPages_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetRetiredPages_v2(device.nvmlDevice,  sourceFilter,  count,  addresses,  timestamps);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRetiredPagesPendingStatus(SafeNvmlHandle device, nvmlEnableState_t *isPending)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetRetiredPagesPendingStatus", [this, device, isPending]() {
        return NvmlDeviceGetRetiredPagesPendingStatusImpl(device, isPending);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRetiredPagesPendingStatusImpl(SafeNvmlHandle device, nvmlEnableState_t *isPending)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetRetiredPagesPendingStatusImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetRetiredPagesPendingStatus(device.nvmlDevice,  isPending);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetAPIRestriction(SafeNvmlHandle device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t isRestricted)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetAPIRestriction", [this, device, apiType, isRestricted]() {
        return NvmlDeviceSetAPIRestrictionImpl(device, apiType, isRestricted);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetAPIRestrictionImpl(SafeNvmlHandle device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t isRestricted)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetAPIRestrictionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetAPIRestriction(device.nvmlDevice,  apiType,  isRestricted);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAPIRestriction(SafeNvmlHandle device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t *isRestricted)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAPIRestriction", [this, device, apiType, isRestricted]() {
        return NvmlDeviceGetAPIRestrictionImpl(device, apiType, isRestricted);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAPIRestrictionImpl(SafeNvmlHandle device, nvmlRestrictedAPI_t apiType, nvmlEnableState_t *isRestricted)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAPIRestrictionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAPIRestriction(device.nvmlDevice,  apiType,  isRestricted);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMinorNumber(SafeNvmlHandle device, unsigned int *minorNumber)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMinorNumber", [this, device, minorNumber]() {
        return NvmlDeviceGetMinorNumberImpl(device, minorNumber);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMinorNumberImpl(SafeNvmlHandle device, unsigned int *minorNumber)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMinorNumberImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMinorNumber(device.nvmlDevice,  minorNumber);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEnforcedPowerLimit(SafeNvmlHandle device, unsigned int *limit)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetEnforcedPowerLimit", [this, device, limit]() {
        return NvmlDeviceGetEnforcedPowerLimitImpl(device, limit);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEnforcedPowerLimitImpl(SafeNvmlHandle device, unsigned int *limit)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetEnforcedPowerLimitImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetEnforcedPowerLimit(device.nvmlDevice,  limit);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSamples(SafeNvmlHandle device, nvmlSamplingType_t type, unsigned long long lastSeenTimeStamp, nvmlValueType_t *sampleValType, unsigned int *sampleCount, nvmlSample_t *samples)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSamples", [this, device, type, lastSeenTimeStamp, sampleValType, sampleCount, samples]() {
        return NvmlDeviceGetSamplesImpl(device, type, lastSeenTimeStamp, sampleValType, sampleCount, samples);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSamplesImpl(SafeNvmlHandle device, nvmlSamplingType_t type, unsigned long long lastSeenTimeStamp, nvmlValueType_t *sampleValType, unsigned int *sampleCount, nvmlSample_t *samples)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSamplesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSamples(device.nvmlDevice,  type,  lastSeenTimeStamp,  sampleValType,  sampleCount,  samples);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieThroughput(SafeNvmlHandle device, nvmlPcieUtilCounter_t counter, unsigned int *value)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPcieThroughput", [this, device, counter, value]() {
        return NvmlDeviceGetPcieThroughputImpl(device, counter, value);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieThroughputImpl(SafeNvmlHandle device, nvmlPcieUtilCounter_t counter, unsigned int *value)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPcieThroughputImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPcieThroughput(device.nvmlDevice,  counter,  value);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieReplayCounter(SafeNvmlHandle device, unsigned int *value)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPcieReplayCounter", [this, device, value]() {
        return NvmlDeviceGetPcieReplayCounterImpl(device, value);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieReplayCounterImpl(SafeNvmlHandle device, unsigned int *value)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPcieReplayCounterImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPcieReplayCounter(device.nvmlDevice,  value);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkState(SafeNvmlHandle device, unsigned int link, nvmlEnableState_t *isActive)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkState", [this, device, link, isActive]() {
        return NvmlDeviceGetNvLinkStateImpl(device, link, isActive);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkStateImpl(SafeNvmlHandle device, unsigned int link, nvmlEnableState_t *isActive)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkStateImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkState(device.nvmlDevice,  link,  isActive);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkVersion(SafeNvmlHandle device, unsigned int link, unsigned int *version)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkVersion", [this, device, link, version]() {
        return NvmlDeviceGetNvLinkVersionImpl(device, link, version);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkVersionImpl(SafeNvmlHandle device, unsigned int link, unsigned int *version)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkVersionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkVersion(device.nvmlDevice,  link,  version);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkRemotePciInfo(SafeNvmlHandle device, unsigned int link, nvmlPciInfo_t *pci)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkRemotePciInfo", [this, device, link, pci]() {
        return NvmlDeviceGetNvLinkRemotePciInfoImpl(device, link, pci);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkRemotePciInfoImpl(SafeNvmlHandle device, unsigned int link, nvmlPciInfo_t *pci)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkRemotePciInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkRemotePciInfo(device.nvmlDevice,  link,  pci);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkRemotePciInfo_v2(SafeNvmlHandle device, unsigned int link, nvmlPciInfo_t *pci)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkRemotePciInfo_v2", [this, device, link, pci]() {
        return NvmlDeviceGetNvLinkRemotePciInfo_v2Impl(device, link, pci);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkRemotePciInfo_v2Impl(SafeNvmlHandle device, unsigned int link, nvmlPciInfo_t *pci)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkRemotePciInfo_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkRemotePciInfo_v2(device.nvmlDevice,  link,  pci);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkRemoteDeviceType(SafeNvmlHandle device, unsigned int link, nvmlIntNvLinkDeviceType_t *pNvLinkDeviceType)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkRemoteDeviceType", [this, device, link, pNvLinkDeviceType]() {
        return NvmlDeviceGetNvLinkRemoteDeviceTypeImpl(device, link, pNvLinkDeviceType);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkRemoteDeviceTypeImpl(SafeNvmlHandle device, unsigned int link, nvmlIntNvLinkDeviceType_t *pNvLinkDeviceType)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkRemoteDeviceTypeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkRemoteDeviceType(device.nvmlDevice,  link,  pNvLinkDeviceType);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkCapability(SafeNvmlHandle device, unsigned int link, nvmlNvLinkCapability_t capability, unsigned int *capResult)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkCapability", [this, device, link, capability, capResult]() {
        return NvmlDeviceGetNvLinkCapabilityImpl(device, link, capability, capResult);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkCapabilityImpl(SafeNvmlHandle device, unsigned int link, nvmlNvLinkCapability_t capability, unsigned int *capResult)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkCapabilityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkCapability(device.nvmlDevice,  link,  capability,  capResult);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkErrorCounter(SafeNvmlHandle device, unsigned int link, nvmlNvLinkErrorCounter_t counter, unsigned long long *counterValue)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkErrorCounter", [this, device, link, counter, counterValue]() {
        return NvmlDeviceGetNvLinkErrorCounterImpl(device, link, counter, counterValue);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkErrorCounterImpl(SafeNvmlHandle device, unsigned int link, nvmlNvLinkErrorCounter_t counter, unsigned long long *counterValue)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkErrorCounterImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkErrorCounter(device.nvmlDevice,  link,  counter,  counterValue);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetNvLinkErrorCounters(SafeNvmlHandle device, unsigned int link)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceResetNvLinkErrorCounters", [this, device, link]() {
        return NvmlDeviceResetNvLinkErrorCountersImpl(device, link);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetNvLinkErrorCountersImpl(SafeNvmlHandle device, unsigned int link)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceResetNvLinkErrorCountersImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceResetNvLinkErrorCounters(device.nvmlDevice,  link);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetNvLinkUtilizationControl(SafeNvmlHandle device, unsigned int link, unsigned int counter, nvmlNvLinkUtilizationControl_t *control, unsigned int reset)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetNvLinkUtilizationControl", [this, device, link, counter, control, reset]() {
        return NvmlDeviceSetNvLinkUtilizationControlImpl(device, link, counter, control, reset);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetNvLinkUtilizationControlImpl(SafeNvmlHandle device, unsigned int link, unsigned int counter, nvmlNvLinkUtilizationControl_t *control, unsigned int reset)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetNvLinkUtilizationControlImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetNvLinkUtilizationControl(device.nvmlDevice,  link,  counter,  control,  reset);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkUtilizationControl(SafeNvmlHandle device, unsigned int link, unsigned int counter, nvmlNvLinkUtilizationControl_t *control)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkUtilizationControl", [this, device, link, counter, control]() {
        return NvmlDeviceGetNvLinkUtilizationControlImpl(device, link, counter, control);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkUtilizationControlImpl(SafeNvmlHandle device, unsigned int link, unsigned int counter, nvmlNvLinkUtilizationControl_t *control)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkUtilizationControlImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkUtilizationControl(device.nvmlDevice,  link,  counter,  control);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkUtilizationCounter(SafeNvmlHandle device, unsigned int link, unsigned int counter, unsigned long long *rxcounter, unsigned long long *txcounter)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNvLinkUtilizationCounter", [this, device, link, counter, rxcounter, txcounter]() {
        return NvmlDeviceGetNvLinkUtilizationCounterImpl(device, link, counter, rxcounter, txcounter);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNvLinkUtilizationCounterImpl(SafeNvmlHandle device, unsigned int link, unsigned int counter, unsigned long long *rxcounter, unsigned long long *txcounter)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNvLinkUtilizationCounterImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNvLinkUtilizationCounter(device.nvmlDevice,  link,  counter,  rxcounter,  txcounter);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceFreezeNvLinkUtilizationCounter(SafeNvmlHandle device, unsigned int link, unsigned int counter, nvmlEnableState_t freeze)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceFreezeNvLinkUtilizationCounter", [this, device, link, counter, freeze]() {
        return NvmlDeviceFreezeNvLinkUtilizationCounterImpl(device, link, counter, freeze);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceFreezeNvLinkUtilizationCounterImpl(SafeNvmlHandle device, unsigned int link, unsigned int counter, nvmlEnableState_t freeze)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceFreezeNvLinkUtilizationCounterImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceFreezeNvLinkUtilizationCounter(device.nvmlDevice,  link,  counter,  freeze);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetNvLinkUtilizationCounter(SafeNvmlHandle device, unsigned int link, unsigned int counter)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceResetNvLinkUtilizationCounter", [this, device, link, counter]() {
        return NvmlDeviceResetNvLinkUtilizationCounterImpl(device, link, counter);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceResetNvLinkUtilizationCounterImpl(SafeNvmlHandle device, unsigned int link, unsigned int counter)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceResetNvLinkUtilizationCounterImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceResetNvLinkUtilizationCounter(device.nvmlDevice,  link,  counter);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVirtualizationMode(SafeNvmlHandle device, nvmlGpuVirtualizationMode_t *pVirtualMode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetVirtualizationMode", [this, device, pVirtualMode]() {
        return NvmlDeviceGetVirtualizationModeImpl(device, pVirtualMode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVirtualizationModeImpl(SafeNvmlHandle device, nvmlGpuVirtualizationMode_t *pVirtualMode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetVirtualizationModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetVirtualizationMode(device.nvmlDevice,  pVirtualMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetVirtualizationMode(SafeNvmlHandle device, nvmlGpuVirtualizationMode_t virtualMode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetVirtualizationMode", [this, device, virtualMode]() {
        return NvmlDeviceSetVirtualizationModeImpl(device, virtualMode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetVirtualizationModeImpl(SafeNvmlHandle device, nvmlGpuVirtualizationMode_t virtualMode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetVirtualizationModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetVirtualizationMode(device.nvmlDevice,  virtualMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCreatableVgpus(SafeNvmlHandle device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetCreatableVgpus", [this, device, vgpuCount, vgpuTypeIds]() {
        return NvmlDeviceGetCreatableVgpusImpl(device, vgpuCount, vgpuTypeIds);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetCreatableVgpusImpl(SafeNvmlHandle device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetCreatableVgpusImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetCreatableVgpus(device.nvmlDevice,  vgpuCount,  vgpuTypeIds);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVgpuUtilization(SafeNvmlHandle device, unsigned long long lastSeenTimeStamp, nvmlValueType_t *sampleValType, unsigned int *vgpuInstanceSamplesCount, nvmlVgpuInstanceUtilizationSample_t *utilizationSamples)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetVgpuUtilization", [this, device, lastSeenTimeStamp, sampleValType, vgpuInstanceSamplesCount, utilizationSamples]() {
        return NvmlDeviceGetVgpuUtilizationImpl(device, lastSeenTimeStamp, sampleValType, vgpuInstanceSamplesCount, utilizationSamples);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVgpuUtilizationImpl(SafeNvmlHandle device, unsigned long long lastSeenTimeStamp, nvmlValueType_t *sampleValType, unsigned int *vgpuInstanceSamplesCount, nvmlVgpuInstanceUtilizationSample_t *utilizationSamples)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetVgpuUtilizationImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetVgpuUtilization(device.nvmlDevice,  lastSeenTimeStamp,  sampleValType,  vgpuInstanceSamplesCount,  utilizationSamples);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGspFirmwareVersion(SafeNvmlHandle device, char *version)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGspFirmwareVersion", [this, device, version]() {
        return NvmlDeviceGetGspFirmwareVersionImpl(device, version);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGspFirmwareVersionImpl(SafeNvmlHandle device, char *version)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGspFirmwareVersionImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGspFirmwareVersion(device.nvmlDevice,  version);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGspFirmwareMode(SafeNvmlHandle device, unsigned int *isEnabled, unsigned int *defaultMode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGspFirmwareMode", [this, device, isEnabled, defaultMode]() {
        return NvmlDeviceGetGspFirmwareModeImpl(device, isEnabled, defaultMode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGspFirmwareModeImpl(SafeNvmlHandle device, unsigned int *isEnabled, unsigned int *defaultMode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGspFirmwareModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGspFirmwareMode(device.nvmlDevice,  isEnabled,  defaultMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVgpuMetadata(SafeNvmlHandle device, nvmlVgpuPgpuMetadata_t *pgpuMetadata, unsigned int *bufferSize)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetVgpuMetadata", [this, device, pgpuMetadata, bufferSize]() {
        return NvmlDeviceGetVgpuMetadataImpl(device, pgpuMetadata, bufferSize);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVgpuMetadataImpl(SafeNvmlHandle device, nvmlVgpuPgpuMetadata_t *pgpuMetadata, unsigned int *bufferSize)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetVgpuMetadataImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetVgpuMetadata(device.nvmlDevice,  pgpuMetadata,  bufferSize);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPgpuMetadataString(SafeNvmlHandle device, char *pgpuMetadata, unsigned int *bufferSize)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPgpuMetadataString", [this, device, pgpuMetadata, bufferSize]() {
        return NvmlDeviceGetPgpuMetadataStringImpl(device, pgpuMetadata, bufferSize);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPgpuMetadataStringImpl(SafeNvmlHandle device, char *pgpuMetadata, unsigned int *bufferSize)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPgpuMetadataStringImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPgpuMetadataString(device.nvmlDevice,  pgpuMetadata,  bufferSize);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeatures(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGridLicensableFeatures", [this, device, pGridLicensableFeatures]() {
        return NvmlDeviceGetGridLicensableFeaturesImpl(device, pGridLicensableFeatures);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeaturesImpl(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGridLicensableFeaturesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGridLicensableFeatures(device.nvmlDevice,  pGridLicensableFeatures);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeatures_v2(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGridLicensableFeatures_v2", [this, device, pGridLicensableFeatures]() {
        return NvmlDeviceGetGridLicensableFeatures_v2Impl(device, pGridLicensableFeatures);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeatures_v2Impl(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGridLicensableFeatures_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGridLicensableFeatures_v2(device.nvmlDevice,  pGridLicensableFeatures);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeatures_v3(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGridLicensableFeatures_v3", [this, device, pGridLicensableFeatures]() {
        return NvmlDeviceGetGridLicensableFeatures_v3Impl(device, pGridLicensableFeatures);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeatures_v3Impl(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGridLicensableFeatures_v3Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGridLicensableFeatures_v3(device.nvmlDevice,  pGridLicensableFeatures);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeatures_v4(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGridLicensableFeatures_v4", [this, device, pGridLicensableFeatures]() {
        return NvmlDeviceGetGridLicensableFeatures_v4Impl(device, pGridLicensableFeatures);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGridLicensableFeatures_v4Impl(SafeNvmlHandle device, nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGridLicensableFeatures_v4Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGridLicensableFeatures_v4(device.nvmlDevice,  pGridLicensableFeatures);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderCapacity(SafeNvmlHandle device, nvmlEncoderType_t encoderQueryType, unsigned int *pEncoderCapacity)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetEncoderCapacity", [this, device, encoderQueryType, pEncoderCapacity]() {
        return NvmlDeviceGetEncoderCapacityImpl(device, encoderQueryType, pEncoderCapacity);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderCapacityImpl(SafeNvmlHandle device, nvmlEncoderType_t encoderQueryType, unsigned int *pEncoderCapacity)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetEncoderCapacityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetEncoderCapacity(device.nvmlDevice,  encoderQueryType,  pEncoderCapacity);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderStats(SafeNvmlHandle device, unsigned int *sessionCount, unsigned int *averageFps, unsigned int *averageLatency)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetEncoderStats", [this, device, sessionCount, averageFps, averageLatency]() {
        return NvmlDeviceGetEncoderStatsImpl(device, sessionCount, averageFps, averageLatency);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderStatsImpl(SafeNvmlHandle device, unsigned int *sessionCount, unsigned int *averageFps, unsigned int *averageLatency)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetEncoderStatsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetEncoderStats(device.nvmlDevice,  sessionCount,  averageFps,  averageLatency);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderSessions(SafeNvmlHandle device, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfos)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetEncoderSessions", [this, device, sessionCount, sessionInfos]() {
        return NvmlDeviceGetEncoderSessionsImpl(device, sessionCount, sessionInfos);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetEncoderSessionsImpl(SafeNvmlHandle device, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfos)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetEncoderSessionsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetEncoderSessions(device.nvmlDevice,  sessionCount,  sessionInfos);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFBCStats(SafeNvmlHandle device, nvmlFBCStats_t *fbcStats)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetFBCStats", [this, device, fbcStats]() {
        return NvmlDeviceGetFBCStatsImpl(device, fbcStats);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFBCStatsImpl(SafeNvmlHandle device, nvmlFBCStats_t *fbcStats)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetFBCStatsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetFBCStats(device.nvmlDevice,  fbcStats);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFBCSessions(SafeNvmlHandle device, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetFBCSessions", [this, device, sessionCount, sessionInfo]() {
        return NvmlDeviceGetFBCSessionsImpl(device, sessionCount, sessionInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFBCSessionsImpl(SafeNvmlHandle device, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetFBCSessionsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetFBCSessions(device.nvmlDevice,  sessionCount,  sessionInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFieldValues(SafeNvmlHandle device, int valuesCount, nvmlFieldValue_t *values)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetFieldValues", [this, device, valuesCount, values]() {
        return NvmlDeviceGetFieldValuesImpl(device, valuesCount, values);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetFieldValuesImpl(SafeNvmlHandle device, int valuesCount, nvmlFieldValue_t *values)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetFieldValuesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetFieldValues(device.nvmlDevice,  valuesCount,  values);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVgpuProcessUtilization(SafeNvmlHandle device, unsigned long long lastSeenTimeStamp, unsigned int *vgpuProcessSamplesCount, nvmlVgpuProcessUtilizationSample_t *utilizationSamples)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetVgpuProcessUtilization", [this, device, lastSeenTimeStamp, vgpuProcessSamplesCount, utilizationSamples]() {
        return NvmlDeviceGetVgpuProcessUtilizationImpl(device, lastSeenTimeStamp, vgpuProcessSamplesCount, utilizationSamples);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetVgpuProcessUtilizationImpl(SafeNvmlHandle device, unsigned long long lastSeenTimeStamp, unsigned int *vgpuProcessSamplesCount, nvmlVgpuProcessUtilizationSample_t *utilizationSamples)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetVgpuProcessUtilizationImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetVgpuProcessUtilization(device.nvmlDevice,  lastSeenTimeStamp,  vgpuProcessSamplesCount,  utilizationSamples);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetProcessUtilization(SafeNvmlHandle device, nvmlProcessUtilizationSample_t *utilization, unsigned int *processSamplesCount, unsigned long long lastSeenTimeStamp)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetProcessUtilization", [this, device, utilization, processSamplesCount, lastSeenTimeStamp]() {
        return NvmlDeviceGetProcessUtilizationImpl(device, utilization, processSamplesCount, lastSeenTimeStamp);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetProcessUtilizationImpl(SafeNvmlHandle device, nvmlProcessUtilizationSample_t *utilization, unsigned int *processSamplesCount, unsigned long long lastSeenTimeStamp)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetProcessUtilizationImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetProcessUtilization(device.nvmlDevice,  utilization,  processSamplesCount,  lastSeenTimeStamp);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceReadWritePRM_v1(SafeNvmlHandle device, nvmlPRMTLV_v1_t *buffer)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceReadWritePRM_v1", [this, device, buffer]() {
        return NvmlDeviceReadWritePRM_v1Impl(device, buffer);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceReadWritePRM_v1Impl(SafeNvmlHandle device, nvmlPRMTLV_v1_t *buffer)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceReadWritePRM_v1Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceReadWritePRM_v1(device.nvmlDevice,  buffer);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetHostVgpuMode(SafeNvmlHandle device, nvmlHostVgpuMode_t *pHostVgpuMode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetHostVgpuMode", [this, device, pHostVgpuMode]() {
        return NvmlDeviceGetHostVgpuModeImpl(device, pHostVgpuMode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetHostVgpuModeImpl(SafeNvmlHandle device, nvmlHostVgpuMode_t *pHostVgpuMode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetHostVgpuModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetHostVgpuMode(device.nvmlDevice,  pHostVgpuMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetMigMode(SafeNvmlHandle device, unsigned int mode, nvmlReturn_t *activationStatus)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetMigMode", [this, device, mode, activationStatus]() {
        return NvmlDeviceSetMigModeImpl(device, mode, activationStatus);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetMigModeImpl(SafeNvmlHandle device, unsigned int mode, nvmlReturn_t *activationStatus)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetMigModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetMigMode(device.nvmlDevice,  mode,  activationStatus);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMigMode(SafeNvmlHandle device, unsigned int *currentMode, unsigned int *pendingMode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMigMode", [this, device, currentMode, pendingMode]() {
        return NvmlDeviceGetMigModeImpl(device, currentMode, pendingMode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMigModeImpl(SafeNvmlHandle device, unsigned int *currentMode, unsigned int *pendingMode)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMigModeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMigMode(device.nvmlDevice,  currentMode,  pendingMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceProfileInfo(SafeNvmlHandle device, unsigned int profile, nvmlGpuInstanceProfileInfo_t *info)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuInstanceProfileInfo", [this, device, profile, info]() {
        return NvmlDeviceGetGpuInstanceProfileInfoImpl(device, profile, info);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceProfileInfoImpl(SafeNvmlHandle device, unsigned int profile, nvmlGpuInstanceProfileInfo_t *info)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuInstanceProfileInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuInstanceProfileInfo(device.nvmlDevice,  profile,  info);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceProfileInfoV(SafeNvmlHandle device, unsigned int profile, nvmlGpuInstanceProfileInfo_v2_t *info)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuInstanceProfileInfoV", [this, device, profile, info]() {
        return NvmlDeviceGetGpuInstanceProfileInfoVImpl(device, profile, info);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceProfileInfoVImpl(SafeNvmlHandle device, unsigned int profile, nvmlGpuInstanceProfileInfo_v2_t *info)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuInstanceProfileInfoVImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuInstanceProfileInfoV(device.nvmlDevice,  profile,  info);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceRemainingCapacity(SafeNvmlHandle device, unsigned int profileId, unsigned int *count)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuInstanceRemainingCapacity", [this, device, profileId, count]() {
        return NvmlDeviceGetGpuInstanceRemainingCapacityImpl(device, profileId, count);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceRemainingCapacityImpl(SafeNvmlHandle device, unsigned int profileId, unsigned int *count)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuInstanceRemainingCapacityImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuInstanceRemainingCapacity(device.nvmlDevice,  profileId,  count);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstancePossiblePlacements(SafeNvmlHandle device, unsigned int profileId, nvmlGpuInstancePlacement_t *placements, unsigned int *count)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuInstancePossiblePlacements", [this, device, profileId, placements, count]() {
        return NvmlDeviceGetGpuInstancePossiblePlacementsImpl(device, profileId, placements, count);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstancePossiblePlacementsImpl(SafeNvmlHandle device, unsigned int profileId, nvmlGpuInstancePlacement_t *placements, unsigned int *count)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuInstancePossiblePlacementsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuInstancePossiblePlacements(device.nvmlDevice,  profileId,  placements,  count);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstancePossiblePlacements_v2(SafeNvmlHandle device, unsigned int profileId, nvmlGpuInstancePlacement_t *placements, unsigned int *count)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuInstancePossiblePlacements_v2", [this, device, profileId, placements, count]() {
        return NvmlDeviceGetGpuInstancePossiblePlacements_v2Impl(device, profileId, placements, count);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstancePossiblePlacements_v2Impl(SafeNvmlHandle device, unsigned int profileId, nvmlGpuInstancePlacement_t *placements, unsigned int *count)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuInstancePossiblePlacements_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuInstancePossiblePlacements_v2(device.nvmlDevice,  profileId,  placements,  count);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceCreateGpuInstance(SafeNvmlHandle device, unsigned int profileId, nvmlGpuInstance_t *gpuInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceCreateGpuInstance", [this, device, profileId, gpuInstance]() {
        return NvmlDeviceCreateGpuInstanceImpl(device, profileId, gpuInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceCreateGpuInstanceImpl(SafeNvmlHandle device, unsigned int profileId, nvmlGpuInstance_t *gpuInstance)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceCreateGpuInstanceImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceCreateGpuInstance(device.nvmlDevice,  profileId,  gpuInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceCreateGpuInstanceWithPlacement(SafeNvmlHandle device, unsigned int profileId, const nvmlGpuInstancePlacement_t *placement, nvmlGpuInstance_t *gpuInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceCreateGpuInstanceWithPlacement", [this, device, profileId, placement, gpuInstance]() {
        return NvmlDeviceCreateGpuInstanceWithPlacementImpl(device, profileId, placement, gpuInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceCreateGpuInstanceWithPlacementImpl(SafeNvmlHandle device, unsigned int profileId, const nvmlGpuInstancePlacement_t *placement, nvmlGpuInstance_t *gpuInstance)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceCreateGpuInstanceWithPlacementImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceCreateGpuInstanceWithPlacement(device.nvmlDevice,  profileId,  placement,  gpuInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceById(SafeNvmlHandle device, unsigned int id, nvmlGpuInstance_t *gpuInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuInstanceById", [this, device, id, gpuInstance]() {
        return NvmlDeviceGetGpuInstanceByIdImpl(device, id, gpuInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceByIdImpl(SafeNvmlHandle device, unsigned int id, nvmlGpuInstance_t *gpuInstance)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuInstanceByIdImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuInstanceById(device.nvmlDevice,  id,  gpuInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceIsMigDeviceHandle(SafeNvmlHandle device, unsigned int *isMigDevice)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceIsMigDeviceHandle", [this, device, isMigDevice]() {
        return NvmlDeviceIsMigDeviceHandleImpl(device, isMigDevice);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceIsMigDeviceHandleImpl(SafeNvmlHandle device, unsigned int *isMigDevice)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceIsMigDeviceHandleImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceIsMigDeviceHandle(device.nvmlDevice,  isMigDevice);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceId(SafeNvmlHandle device, unsigned int *id)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuInstanceId", [this, device, id]() {
        return NvmlDeviceGetGpuInstanceIdImpl(device, id);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuInstanceIdImpl(SafeNvmlHandle device, unsigned int *id)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuInstanceIdImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuInstanceId(device.nvmlDevice,  id);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeInstanceId(SafeNvmlHandle device, unsigned int *id)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetComputeInstanceId", [this, device, id]() {
        return NvmlDeviceGetComputeInstanceIdImpl(device, id);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetComputeInstanceIdImpl(SafeNvmlHandle device, unsigned int *id)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetComputeInstanceIdImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetComputeInstanceId(device.nvmlDevice,  id);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxMigDeviceCount(SafeNvmlHandle device, unsigned int *migDeviceCount)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMaxMigDeviceCount", [this, device, migDeviceCount]() {
        return NvmlDeviceGetMaxMigDeviceCountImpl(device, migDeviceCount);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMaxMigDeviceCountImpl(SafeNvmlHandle device, unsigned int *migDeviceCount)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMaxMigDeviceCountImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMaxMigDeviceCount(device.nvmlDevice,  migDeviceCount);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAttributes(SafeNvmlHandle device, nvmlDeviceAttributes_t *attributes)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAttributes", [this, device, attributes]() {
        return NvmlDeviceGetAttributesImpl(device, attributes);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAttributesImpl(SafeNvmlHandle device, nvmlDeviceAttributes_t *attributes)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAttributesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAttributes(device.nvmlDevice,  attributes);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAttributes_v2(SafeNvmlHandle device, nvmlDeviceAttributes_t *attributes)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAttributes_v2", [this, device, attributes]() {
        return NvmlDeviceGetAttributes_v2Impl(device, attributes);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAttributes_v2Impl(SafeNvmlHandle device, nvmlDeviceAttributes_t *attributes)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAttributes_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAttributes_v2(device.nvmlDevice,  attributes);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRemappedRows(SafeNvmlHandle device, unsigned int *corrRows, unsigned int *uncRows, unsigned int *isPending, unsigned int *failureOccurred)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetRemappedRows", [this, device, corrRows, uncRows, isPending, failureOccurred]() {
        return NvmlDeviceGetRemappedRowsImpl(device, corrRows, uncRows, isPending, failureOccurred);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRemappedRowsImpl(SafeNvmlHandle device, unsigned int *corrRows, unsigned int *uncRows, unsigned int *isPending, unsigned int *failureOccurred)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetRemappedRowsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetRemappedRows(device.nvmlDevice,  corrRows,  uncRows,  isPending,  failureOccurred);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRowRemapperHistogram(SafeNvmlHandle device, nvmlRowRemapperHistogramValues_t *values)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetRowRemapperHistogram", [this, device, values]() {
        return NvmlDeviceGetRowRemapperHistogramImpl(device, values);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetRowRemapperHistogramImpl(SafeNvmlHandle device, nvmlRowRemapperHistogramValues_t *values)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetRowRemapperHistogramImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetRowRemapperHistogram(device.nvmlDevice,  values);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBusType(SafeNvmlHandle device, nvmlBusType_t *type)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetBusType", [this, device, type]() {
        return NvmlDeviceGetBusTypeImpl(device, type);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetBusTypeImpl(SafeNvmlHandle device, nvmlBusType_t *type)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetBusTypeImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetBusType(device.nvmlDevice,  type);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetIrqNum(SafeNvmlHandle device, unsigned int *irqNum)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetIrqNum", [this, device, irqNum]() {
        return NvmlDeviceGetIrqNumImpl(device, irqNum);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetIrqNumImpl(SafeNvmlHandle device, unsigned int *irqNum)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetIrqNumImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetIrqNum(device.nvmlDevice,  irqNum);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNumGpuCores(SafeNvmlHandle device, unsigned int *numCores)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetNumGpuCores", [this, device, numCores]() {
        return NvmlDeviceGetNumGpuCoresImpl(device, numCores);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetNumGpuCoresImpl(SafeNvmlHandle device, unsigned int *numCores)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetNumGpuCoresImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetNumGpuCores(device.nvmlDevice,  numCores);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerSource(SafeNvmlHandle device, nvmlPowerSource_t *powerSource)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPowerSource", [this, device, powerSource]() {
        return NvmlDeviceGetPowerSourceImpl(device, powerSource);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPowerSourceImpl(SafeNvmlHandle device, nvmlPowerSource_t *powerSource)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPowerSourceImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPowerSource(device.nvmlDevice,  powerSource);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryBusWidth(SafeNvmlHandle device, unsigned int *busWidth)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMemoryBusWidth", [this, device, busWidth]() {
        return NvmlDeviceGetMemoryBusWidthImpl(device, busWidth);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemoryBusWidthImpl(SafeNvmlHandle device, unsigned int *busWidth)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMemoryBusWidthImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMemoryBusWidth(device.nvmlDevice,  busWidth);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieLinkMaxSpeed(SafeNvmlHandle device, unsigned int *maxSpeed)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPcieLinkMaxSpeed", [this, device, maxSpeed]() {
        return NvmlDeviceGetPcieLinkMaxSpeedImpl(device, maxSpeed);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieLinkMaxSpeedImpl(SafeNvmlHandle device, unsigned int *maxSpeed)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPcieLinkMaxSpeedImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPcieLinkMaxSpeed(device.nvmlDevice,  maxSpeed);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAdaptiveClockInfoStatus(SafeNvmlHandle device, unsigned int *adaptiveClockStatus)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetAdaptiveClockInfoStatus", [this, device, adaptiveClockStatus]() {
        return NvmlDeviceGetAdaptiveClockInfoStatusImpl(device, adaptiveClockStatus);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetAdaptiveClockInfoStatusImpl(SafeNvmlHandle device, unsigned int *adaptiveClockStatus)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetAdaptiveClockInfoStatusImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetAdaptiveClockInfoStatus(device.nvmlDevice,  adaptiveClockStatus);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieSpeed(SafeNvmlHandle device, unsigned int *pcieSpeed)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPcieSpeed", [this, device, pcieSpeed]() {
        return NvmlDeviceGetPcieSpeedImpl(device, pcieSpeed);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPcieSpeedImpl(SafeNvmlHandle device, unsigned int *pcieSpeed)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPcieSpeedImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPcieSpeed(device.nvmlDevice,  pcieSpeed);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDynamicPstatesInfo(SafeNvmlHandle device, nvmlGpuDynamicPstatesInfo_t *pDynamicPstatesInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetDynamicPstatesInfo", [this, device, pDynamicPstatesInfo]() {
        return NvmlDeviceGetDynamicPstatesInfoImpl(device, pDynamicPstatesInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetDynamicPstatesInfoImpl(SafeNvmlHandle device, nvmlGpuDynamicPstatesInfo_t *pDynamicPstatesInfo)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetDynamicPstatesInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetDynamicPstatesInfo(device.nvmlDevice,  pDynamicPstatesInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetFanSpeed_v2(SafeNvmlHandle device, unsigned int fan, unsigned int speed)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetFanSpeed_v2", [this, device, fan, speed]() {
        return NvmlDeviceSetFanSpeed_v2Impl(device, fan, speed);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetFanSpeed_v2Impl(SafeNvmlHandle device, unsigned int fan, unsigned int speed)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetFanSpeed_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetFanSpeed_v2(device.nvmlDevice,  fan,  speed);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetDefaultFanSpeed_v2(SafeNvmlHandle device, unsigned int fan)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetDefaultFanSpeed_v2", [this, device, fan]() {
        return NvmlDeviceSetDefaultFanSpeed_v2Impl(device, fan);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetDefaultFanSpeed_v2Impl(SafeNvmlHandle device, unsigned int fan)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetDefaultFanSpeed_v2Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetDefaultFanSpeed_v2(device.nvmlDevice,  fan);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetThermalSettings(SafeNvmlHandle device, unsigned int sensorIndex, nvmlGpuThermalSettings_t *pThermalSettings)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetThermalSettings", [this, device, sensorIndex, pThermalSettings]() {
        return NvmlDeviceGetThermalSettingsImpl(device, sensorIndex, pThermalSettings);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetThermalSettingsImpl(SafeNvmlHandle device, unsigned int sensorIndex, nvmlGpuThermalSettings_t *pThermalSettings)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetThermalSettingsImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetThermalSettings(device.nvmlDevice,  sensorIndex,  pThermalSettings);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMinMaxClockOfPState(SafeNvmlHandle device, nvmlClockType_t type, nvmlPstates_t pstate, unsigned int *minClockMHz, unsigned int *maxClockMHz)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMinMaxClockOfPState", [this, device, type, pstate, minClockMHz, maxClockMHz]() {
        return NvmlDeviceGetMinMaxClockOfPStateImpl(device, type, pstate, minClockMHz, maxClockMHz);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMinMaxClockOfPStateImpl(SafeNvmlHandle device, nvmlClockType_t type, nvmlPstates_t pstate, unsigned int *minClockMHz, unsigned int *maxClockMHz)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMinMaxClockOfPStateImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMinMaxClockOfPState(device.nvmlDevice,  type,  pstate,  minClockMHz,  maxClockMHz);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedPerformanceStates(SafeNvmlHandle device, nvmlPstates_t *pstates, unsigned int size)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetSupportedPerformanceStates", [this, device, pstates, size]() {
        return NvmlDeviceGetSupportedPerformanceStatesImpl(device, pstates, size);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetSupportedPerformanceStatesImpl(SafeNvmlHandle device, nvmlPstates_t *pstates, unsigned int size)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetSupportedPerformanceStatesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetSupportedPerformanceStates(device.nvmlDevice,  pstates,  size);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpcClkVfOffset(SafeNvmlHandle device, int *offset)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpcClkVfOffset", [this, device, offset]() {
        return NvmlDeviceGetGpcClkVfOffsetImpl(device, offset);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpcClkVfOffsetImpl(SafeNvmlHandle device, int *offset)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpcClkVfOffsetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpcClkVfOffset(device.nvmlDevice,  offset);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetGpcClkVfOffset(SafeNvmlHandle device, int offset)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetGpcClkVfOffset", [this, device, offset]() {
        return NvmlDeviceSetGpcClkVfOffsetImpl(device, offset);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetGpcClkVfOffsetImpl(SafeNvmlHandle device, int offset)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetGpcClkVfOffsetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetGpcClkVfOffset(device.nvmlDevice,  offset);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemClkVfOffset(SafeNvmlHandle device, int *offset)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMemClkVfOffset", [this, device, offset]() {
        return NvmlDeviceGetMemClkVfOffsetImpl(device, offset);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemClkVfOffsetImpl(SafeNvmlHandle device, int *offset)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMemClkVfOffsetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMemClkVfOffset(device.nvmlDevice,  offset);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetMemClkVfOffset(SafeNvmlHandle device, int offset)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceSetMemClkVfOffset", [this, device, offset]() {
        return NvmlDeviceSetMemClkVfOffsetImpl(device, offset);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceSetMemClkVfOffsetImpl(SafeNvmlHandle device, int offset)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceSetMemClkVfOffsetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceSetMemClkVfOffset(device.nvmlDevice,  offset);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMinMaxFanSpeed(SafeNvmlHandle device, unsigned int *min, unsigned int *max)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMinMaxFanSpeed", [this, device, min, max]() {
        return NvmlDeviceGetMinMaxFanSpeedImpl(device, min, max);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMinMaxFanSpeedImpl(SafeNvmlHandle device, unsigned int *min, unsigned int *max)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMinMaxFanSpeedImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMinMaxFanSpeed(device.nvmlDevice,  min,  max);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpcClkMinMaxVfOffset(SafeNvmlHandle device, int *minOffset, int *maxOffset)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpcClkMinMaxVfOffset", [this, device, minOffset, maxOffset]() {
        return NvmlDeviceGetGpcClkMinMaxVfOffsetImpl(device, minOffset, maxOffset);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpcClkMinMaxVfOffsetImpl(SafeNvmlHandle device, int *minOffset, int *maxOffset)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpcClkMinMaxVfOffsetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpcClkMinMaxVfOffset(device.nvmlDevice,  minOffset,  maxOffset);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemClkMinMaxVfOffset(SafeNvmlHandle device, int *minOffset, int *maxOffset)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetMemClkMinMaxVfOffset", [this, device, minOffset, maxOffset]() {
        return NvmlDeviceGetMemClkMinMaxVfOffsetImpl(device, minOffset, maxOffset);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetMemClkMinMaxVfOffsetImpl(SafeNvmlHandle device, int *minOffset, int *maxOffset)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetMemClkMinMaxVfOffsetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetMemClkMinMaxVfOffset(device.nvmlDevice,  minOffset,  maxOffset);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmSampleGet(SafeNvmlHandle device, nvmlGpmSample_t gpmSample)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpmSampleGet", [this, device, gpmSample]() {
        return NvmlGpmSampleGetImpl(device, gpmSample);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmSampleGetImpl(SafeNvmlHandle device, nvmlGpmSample_t gpmSample)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlGpmSampleGetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpmSampleGet(device.nvmlDevice,  gpmSample);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmMigSampleGet(SafeNvmlHandle device, unsigned int gpuInstanceId, nvmlGpmSample_t gpmSample)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpmMigSampleGet", [this, device, gpuInstanceId, gpmSample]() {
        return NvmlGpmMigSampleGetImpl(device, gpuInstanceId, gpmSample);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmMigSampleGetImpl(SafeNvmlHandle device, unsigned int gpuInstanceId, nvmlGpmSample_t gpmSample)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlGpmMigSampleGetImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpmMigSampleGet(device.nvmlDevice,  gpuInstanceId,  gpmSample);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmQueryDeviceSupport(SafeNvmlHandle device, nvmlGpmSupport_t *gpmSupport)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpmQueryDeviceSupport", [this, device, gpmSupport]() {
        return NvmlGpmQueryDeviceSupportImpl(device, gpmSupport);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmQueryDeviceSupportImpl(SafeNvmlHandle device, nvmlGpmSupport_t *gpmSupport)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlGpmQueryDeviceSupportImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpmQueryDeviceSupport(device.nvmlDevice,  gpmSupport);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuFabricInfo(SafeNvmlHandle device, nvmlGpuFabricInfo_t *gpuFabricInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuFabricInfo", [this, device, gpuFabricInfo]() {
        return NvmlDeviceGetGpuFabricInfoImpl(device, gpuFabricInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuFabricInfoImpl(SafeNvmlHandle device, nvmlGpuFabricInfo_t *gpuFabricInfo)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuFabricInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuFabricInfo(device.nvmlDevice,  gpuFabricInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuFabricInfoV(SafeNvmlHandle device, nvmlGpuFabricInfoV_t *gpuFabricInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetGpuFabricInfoV", [this, device, gpuFabricInfo]() {
        return NvmlDeviceGetGpuFabricInfoVImpl(device, gpuFabricInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetGpuFabricInfoVImpl(SafeNvmlHandle device, nvmlGpuFabricInfoV_t *gpuFabricInfo)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetGpuFabricInfoVImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetGpuFabricInfoV(device.nvmlDevice,  gpuFabricInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetArchitecture(SafeNvmlHandle device, nvmlDeviceArchitecture_t *arch)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetArchitecture", [this, device, arch]() {
        return NvmlDeviceGetArchitectureImpl(device, arch);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetArchitectureImpl(SafeNvmlHandle device, nvmlDeviceArchitecture_t *arch)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetArchitectureImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetArchitecture(device.nvmlDevice,  arch);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileGetProfilesInfo(SafeNvmlHandle device, nvmlWorkloadPowerProfileProfilesInfo_t *profilesInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceWorkloadPowerProfileGetProfilesInfo", [this, device, profilesInfo]() {
        return NvmlDeviceWorkloadPowerProfileGetProfilesInfoImpl(device, profilesInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileGetProfilesInfoImpl(SafeNvmlHandle device, nvmlWorkloadPowerProfileProfilesInfo_t *profilesInfo)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceWorkloadPowerProfileGetProfilesInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceWorkloadPowerProfileGetProfilesInfo(device.nvmlDevice,  profilesInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileGetCurrentProfiles(SafeNvmlHandle device, nvmlWorkloadPowerProfileCurrentProfiles_t *currentProfiles)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceWorkloadPowerProfileGetCurrentProfiles", [this, device, currentProfiles]() {
        return NvmlDeviceWorkloadPowerProfileGetCurrentProfilesImpl(device, currentProfiles);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileGetCurrentProfilesImpl(SafeNvmlHandle device, nvmlWorkloadPowerProfileCurrentProfiles_t *currentProfiles)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceWorkloadPowerProfileGetCurrentProfilesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceWorkloadPowerProfileGetCurrentProfiles(device.nvmlDevice,  currentProfiles);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileSetRequestedProfiles(SafeNvmlHandle device, nvmlWorkloadPowerProfileRequestedProfiles_t *requestedProfiles)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceWorkloadPowerProfileSetRequestedProfiles", [this, device, requestedProfiles]() {
        return NvmlDeviceWorkloadPowerProfileSetRequestedProfilesImpl(device, requestedProfiles);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileSetRequestedProfilesImpl(SafeNvmlHandle device, nvmlWorkloadPowerProfileRequestedProfiles_t *requestedProfiles)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceWorkloadPowerProfileSetRequestedProfilesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceWorkloadPowerProfileSetRequestedProfiles(device.nvmlDevice,  requestedProfiles);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileClearRequestedProfiles(SafeNvmlHandle device, nvmlWorkloadPowerProfileRequestedProfiles_t *requestedProfiles)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceWorkloadPowerProfileClearRequestedProfiles", [this, device, requestedProfiles]() {
        return NvmlDeviceWorkloadPowerProfileClearRequestedProfilesImpl(device, requestedProfiles);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileClearRequestedProfilesImpl(SafeNvmlHandle device, nvmlWorkloadPowerProfileRequestedProfiles_t *requestedProfiles)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceWorkloadPowerProfileClearRequestedProfilesImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceWorkloadPowerProfileClearRequestedProfiles(device.nvmlDevice,  requestedProfiles);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileUpdateProfiles_v1(SafeNvmlHandle device, nvmlWorkloadPowerProfileUpdateProfiles_v1_t *updateProfiles)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceWorkloadPowerProfileUpdateProfiles_v1", [this, device, updateProfiles]() {
        return NvmlDeviceWorkloadPowerProfileUpdateProfiles_v1Impl(device, updateProfiles);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceWorkloadPowerProfileUpdateProfiles_v1Impl(SafeNvmlHandle device, nvmlWorkloadPowerProfileUpdateProfiles_v1_t *updateProfiles)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceWorkloadPowerProfileUpdateProfiles_v1Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceWorkloadPowerProfileUpdateProfiles_v1(device.nvmlDevice,  updateProfiles);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPlatformInfo(SafeNvmlHandle device, nvmlPlatformInfo_t *platformInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceGetPlatformInfo", [this, device, platformInfo]() {
        return NvmlDeviceGetPlatformInfoImpl(device, platformInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceGetPlatformInfoImpl(SafeNvmlHandle device, nvmlPlatformInfo_t *platformInfo)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceGetPlatformInfoImpl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceGetPlatformInfo(device.nvmlDevice,  platformInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceReadPRMCounters_v1(SafeNvmlHandle device, nvmlPRMCounterList_v1_t *counterList)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlDeviceReadPRMCounters_v1", [this, device, counterList]() {
        return NvmlDeviceReadPRMCounters_v1Impl(device, counterList);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlDeviceReadPRMCounters_v1Impl(SafeNvmlHandle device, nvmlPRMCounterList_v1_t *counterList)
{
    if (device.generation != GetGeneration())
    {
        log_debug("NvmlDeviceReadPRMCounters_v1Impl: generation mismatch {}, {}", device.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlDeviceReadPRMCounters_v1(device.nvmlDevice,  counterList);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceDestroy(SafeGpuInstance gpuInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpuInstanceDestroy", [this, gpuInstance]() {
        return NvmlGpuInstanceDestroyImpl(gpuInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceDestroyImpl(SafeGpuInstance gpuInstance)
{
    if (gpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlGpuInstanceDestroyImpl: generation mismatch {}, {}", gpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpuInstanceDestroy(gpuInstance.gpuInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetInfo(SafeGpuInstance gpuInstance, nvmlGpuInstanceInfo_t *info)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpuInstanceGetInfo", [this, gpuInstance, info]() {
        return NvmlGpuInstanceGetInfoImpl(gpuInstance, info);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetInfoImpl(SafeGpuInstance gpuInstance, nvmlGpuInstanceInfo_t *info)
{
    if (gpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlGpuInstanceGetInfoImpl: generation mismatch {}, {}", gpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpuInstanceGetInfo(gpuInstance.gpuInstance,  info);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceProfileInfo(SafeGpuInstance gpuInstance, unsigned int profile, unsigned int engProfile, nvmlComputeInstanceProfileInfo_t *info)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpuInstanceGetComputeInstanceProfileInfo", [this, gpuInstance, profile, engProfile, info]() {
        return NvmlGpuInstanceGetComputeInstanceProfileInfoImpl(gpuInstance, profile, engProfile, info);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceProfileInfoImpl(SafeGpuInstance gpuInstance, unsigned int profile, unsigned int engProfile, nvmlComputeInstanceProfileInfo_t *info)
{
    if (gpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlGpuInstanceGetComputeInstanceProfileInfoImpl: generation mismatch {}, {}", gpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpuInstanceGetComputeInstanceProfileInfo(gpuInstance.gpuInstance,  profile,  engProfile,  info);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceProfileInfoV(SafeGpuInstance gpuInstance, unsigned int profile, unsigned int engProfile, nvmlComputeInstanceProfileInfo_v2_t *info)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpuInstanceGetComputeInstanceProfileInfoV", [this, gpuInstance, profile, engProfile, info]() {
        return NvmlGpuInstanceGetComputeInstanceProfileInfoVImpl(gpuInstance, profile, engProfile, info);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceProfileInfoVImpl(SafeGpuInstance gpuInstance, unsigned int profile, unsigned int engProfile, nvmlComputeInstanceProfileInfo_v2_t *info)
{
    if (gpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlGpuInstanceGetComputeInstanceProfileInfoVImpl: generation mismatch {}, {}", gpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpuInstanceGetComputeInstanceProfileInfoV(gpuInstance.gpuInstance,  profile,  engProfile,  info);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceRemainingCapacity(SafeGpuInstance gpuInstance, unsigned int profileId, unsigned int *count)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpuInstanceGetComputeInstanceRemainingCapacity", [this, gpuInstance, profileId, count]() {
        return NvmlGpuInstanceGetComputeInstanceRemainingCapacityImpl(gpuInstance, profileId, count);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceRemainingCapacityImpl(SafeGpuInstance gpuInstance, unsigned int profileId, unsigned int *count)
{
    if (gpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlGpuInstanceGetComputeInstanceRemainingCapacityImpl: generation mismatch {}, {}", gpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpuInstanceGetComputeInstanceRemainingCapacity(gpuInstance.gpuInstance,  profileId,  count);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceCreateComputeInstance(SafeGpuInstance gpuInstance, unsigned int profileId, nvmlComputeInstance_t *computeInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpuInstanceCreateComputeInstance", [this, gpuInstance, profileId, computeInstance]() {
        return NvmlGpuInstanceCreateComputeInstanceImpl(gpuInstance, profileId, computeInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceCreateComputeInstanceImpl(SafeGpuInstance gpuInstance, unsigned int profileId, nvmlComputeInstance_t *computeInstance)
{
    if (gpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlGpuInstanceCreateComputeInstanceImpl: generation mismatch {}, {}", gpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpuInstanceCreateComputeInstance(gpuInstance.gpuInstance,  profileId,  computeInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceById(SafeGpuInstance gpuInstance, unsigned int id, nvmlComputeInstance_t *computeInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlGpuInstanceGetComputeInstanceById", [this, gpuInstance, id, computeInstance]() {
        return NvmlGpuInstanceGetComputeInstanceByIdImpl(gpuInstance, id, computeInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlGpuInstanceGetComputeInstanceByIdImpl(SafeGpuInstance gpuInstance, unsigned int id, nvmlComputeInstance_t *computeInstance)
{
    if (gpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlGpuInstanceGetComputeInstanceByIdImpl: generation mismatch {}, {}", gpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlGpuInstanceGetComputeInstanceById(gpuInstance.gpuInstance,  id,  computeInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlComputeInstanceDestroy(SafeComputeInstance computeInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlComputeInstanceDestroy", [this, computeInstance]() {
        return NvmlComputeInstanceDestroyImpl(computeInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlComputeInstanceDestroyImpl(SafeComputeInstance computeInstance)
{
    if (computeInstance.generation != GetGeneration())
    {
        log_debug("NvmlComputeInstanceDestroyImpl: generation mismatch {}, {}", computeInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlComputeInstanceDestroy(computeInstance.computeInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlComputeInstanceGetInfo(SafeComputeInstance computeInstance, nvmlComputeInstanceInfo_t *info)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlComputeInstanceGetInfo", [this, computeInstance, info]() {
        return NvmlComputeInstanceGetInfoImpl(computeInstance, info);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlComputeInstanceGetInfoImpl(SafeComputeInstance computeInstance, nvmlComputeInstanceInfo_t *info)
{
    if (computeInstance.generation != GetGeneration())
    {
        log_debug("NvmlComputeInstanceGetInfoImpl: generation mismatch {}, {}", computeInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlComputeInstanceGetInfo(computeInstance.computeInstance,  info);
}

nvmlReturn_t NvmlTaskRunner::NvmlComputeInstanceGetInfo_v2(SafeComputeInstance computeInstance, nvmlComputeInstanceInfo_t *info)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlComputeInstanceGetInfo_v2", [this, computeInstance, info]() {
        return NvmlComputeInstanceGetInfo_v2Impl(computeInstance, info);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlComputeInstanceGetInfo_v2Impl(SafeComputeInstance computeInstance, nvmlComputeInstanceInfo_t *info)
{
    if (computeInstance.generation != GetGeneration())
    {
        log_debug("NvmlComputeInstanceGetInfo_v2Impl: generation mismatch {}, {}", computeInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlComputeInstanceGetInfo_v2(computeInstance.computeInstance,  info);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetVmID(SafeVgpuInstance vgpuInstance, char *vmId, unsigned int size, nvmlVgpuVmIdType_t *vmIdType)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetVmID", [this, vgpuInstance, vmId, size, vmIdType]() {
        return NvmlVgpuInstanceGetVmIDImpl(vgpuInstance, vmId, size, vmIdType);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetVmIDImpl(SafeVgpuInstance vgpuInstance, char *vmId, unsigned int size, nvmlVgpuVmIdType_t *vmIdType)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetVmIDImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetVmID(vgpuInstance.vgpuInstance,  vmId,  size,  vmIdType);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetUUID(SafeVgpuInstance vgpuInstance, char *uuid, unsigned int size)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetUUID", [this, vgpuInstance, uuid, size]() {
        return NvmlVgpuInstanceGetUUIDImpl(vgpuInstance, uuid, size);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetUUIDImpl(SafeVgpuInstance vgpuInstance, char *uuid, unsigned int size)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetUUIDImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetUUID(vgpuInstance.vgpuInstance,  uuid,  size);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetMdevUUID(SafeVgpuInstance vgpuInstance, char *mdevUuid, unsigned int size)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetMdevUUID", [this, vgpuInstance, mdevUuid, size]() {
        return NvmlVgpuInstanceGetMdevUUIDImpl(vgpuInstance, mdevUuid, size);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetMdevUUIDImpl(SafeVgpuInstance vgpuInstance, char *mdevUuid, unsigned int size)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetMdevUUIDImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetMdevUUID(vgpuInstance.vgpuInstance,  mdevUuid,  size);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetVmDriverVersion(SafeVgpuInstance vgpuInstance, char *version, unsigned int length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetVmDriverVersion", [this, vgpuInstance, version, length]() {
        return NvmlVgpuInstanceGetVmDriverVersionImpl(vgpuInstance, version, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetVmDriverVersionImpl(SafeVgpuInstance vgpuInstance, char *version, unsigned int length)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetVmDriverVersionImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetVmDriverVersion(vgpuInstance.vgpuInstance,  version,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFbUsage(SafeVgpuInstance vgpuInstance, unsigned long long *fbUsage)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetFbUsage", [this, vgpuInstance, fbUsage]() {
        return NvmlVgpuInstanceGetFbUsageImpl(vgpuInstance, fbUsage);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFbUsageImpl(SafeVgpuInstance vgpuInstance, unsigned long long *fbUsage)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetFbUsageImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetFbUsage(vgpuInstance.vgpuInstance,  fbUsage);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetLicenseStatus(SafeVgpuInstance vgpuInstance, unsigned int *licensed)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetLicenseStatus", [this, vgpuInstance, licensed]() {
        return NvmlVgpuInstanceGetLicenseStatusImpl(vgpuInstance, licensed);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetLicenseStatusImpl(SafeVgpuInstance vgpuInstance, unsigned int *licensed)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetLicenseStatusImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetLicenseStatus(vgpuInstance.vgpuInstance,  licensed);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetLicenseInfo(SafeVgpuInstance vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetLicenseInfo", [this, vgpuInstance, licenseInfo]() {
        return NvmlVgpuInstanceGetLicenseInfoImpl(vgpuInstance, licenseInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetLicenseInfoImpl(SafeVgpuInstance vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetLicenseInfoImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetLicenseInfo(vgpuInstance.vgpuInstance,  licenseInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetLicenseInfo_v2(SafeVgpuInstance vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetLicenseInfo_v2", [this, vgpuInstance, licenseInfo]() {
        return NvmlVgpuInstanceGetLicenseInfo_v2Impl(vgpuInstance, licenseInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetLicenseInfo_v2Impl(SafeVgpuInstance vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetLicenseInfo_v2Impl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetLicenseInfo_v2(vgpuInstance.vgpuInstance,  licenseInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetType(SafeVgpuInstance vgpuInstance, unsigned int *vgpuTypeId)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetType", [this, vgpuInstance, vgpuTypeId]() {
        return NvmlVgpuInstanceGetTypeImpl(vgpuInstance, vgpuTypeId);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetTypeImpl(SafeVgpuInstance vgpuInstance, unsigned int *vgpuTypeId)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetTypeImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetType(vgpuInstance.vgpuInstance,  vgpuTypeId);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFrameRateLimit(SafeVgpuInstance vgpuInstance, unsigned int *frameRateLimit)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetFrameRateLimit", [this, vgpuInstance, frameRateLimit]() {
        return NvmlVgpuInstanceGetFrameRateLimitImpl(vgpuInstance, frameRateLimit);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFrameRateLimitImpl(SafeVgpuInstance vgpuInstance, unsigned int *frameRateLimit)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetFrameRateLimitImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetFrameRateLimit(vgpuInstance.vgpuInstance,  frameRateLimit);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEccMode(SafeVgpuInstance vgpuInstance, nvmlEnableState_t *eccMode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetEccMode", [this, vgpuInstance, eccMode]() {
        return NvmlVgpuInstanceGetEccModeImpl(vgpuInstance, eccMode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEccModeImpl(SafeVgpuInstance vgpuInstance, nvmlEnableState_t *eccMode)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetEccModeImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetEccMode(vgpuInstance.vgpuInstance,  eccMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEncoderCapacity(SafeVgpuInstance vgpuInstance, unsigned int *encoderCapacity)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetEncoderCapacity", [this, vgpuInstance, encoderCapacity]() {
        return NvmlVgpuInstanceGetEncoderCapacityImpl(vgpuInstance, encoderCapacity);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEncoderCapacityImpl(SafeVgpuInstance vgpuInstance, unsigned int *encoderCapacity)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetEncoderCapacityImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetEncoderCapacity(vgpuInstance.vgpuInstance,  encoderCapacity);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceSetEncoderCapacity(SafeVgpuInstance vgpuInstance, unsigned int encoderCapacity)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceSetEncoderCapacity", [this, vgpuInstance, encoderCapacity]() {
        return NvmlVgpuInstanceSetEncoderCapacityImpl(vgpuInstance, encoderCapacity);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceSetEncoderCapacityImpl(SafeVgpuInstance vgpuInstance, unsigned int encoderCapacity)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceSetEncoderCapacityImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceSetEncoderCapacity(vgpuInstance.vgpuInstance,  encoderCapacity);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetMetadata(SafeVgpuInstance vgpuInstance, nvmlVgpuMetadata_t *vgpuMetadata, unsigned int *bufferSize)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetMetadata", [this, vgpuInstance, vgpuMetadata, bufferSize]() {
        return NvmlVgpuInstanceGetMetadataImpl(vgpuInstance, vgpuMetadata, bufferSize);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetMetadataImpl(SafeVgpuInstance vgpuInstance, nvmlVgpuMetadata_t *vgpuMetadata, unsigned int *bufferSize)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetMetadataImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetMetadata(vgpuInstance.vgpuInstance,  vgpuMetadata,  bufferSize);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetGpuPciId(SafeVgpuInstance vgpuInstance, char *vgpuPciId, unsigned int *length)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetGpuPciId", [this, vgpuInstance, vgpuPciId, length]() {
        return NvmlVgpuInstanceGetGpuPciIdImpl(vgpuInstance, vgpuPciId, length);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetGpuPciIdImpl(SafeVgpuInstance vgpuInstance, char *vgpuPciId, unsigned int *length)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetGpuPciIdImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetGpuPciId(vgpuInstance.vgpuInstance,  vgpuPciId,  length);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetGpuInstanceId(SafeVgpuInstance vgpuInstance, unsigned int *gpuInstanceId)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetGpuInstanceId", [this, vgpuInstance, gpuInstanceId]() {
        return NvmlVgpuInstanceGetGpuInstanceIdImpl(vgpuInstance, gpuInstanceId);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetGpuInstanceIdImpl(SafeVgpuInstance vgpuInstance, unsigned int *gpuInstanceId)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetGpuInstanceIdImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetGpuInstanceId(vgpuInstance.vgpuInstance,  gpuInstanceId);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEncoderStats(SafeVgpuInstance vgpuInstance, unsigned int *sessionCount, unsigned int *averageFps, unsigned int *averageLatency)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetEncoderStats", [this, vgpuInstance, sessionCount, averageFps, averageLatency]() {
        return NvmlVgpuInstanceGetEncoderStatsImpl(vgpuInstance, sessionCount, averageFps, averageLatency);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEncoderStatsImpl(SafeVgpuInstance vgpuInstance, unsigned int *sessionCount, unsigned int *averageFps, unsigned int *averageLatency)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetEncoderStatsImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetEncoderStats(vgpuInstance.vgpuInstance,  sessionCount,  averageFps,  averageLatency);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEncoderSessions(SafeVgpuInstance vgpuInstance, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetEncoderSessions", [this, vgpuInstance, sessionCount, sessionInfo]() {
        return NvmlVgpuInstanceGetEncoderSessionsImpl(vgpuInstance, sessionCount, sessionInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetEncoderSessionsImpl(SafeVgpuInstance vgpuInstance, unsigned int *sessionCount, nvmlEncoderSessionInfo_t *sessionInfo)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetEncoderSessionsImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetEncoderSessions(vgpuInstance.vgpuInstance,  sessionCount,  sessionInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFBCStats(SafeVgpuInstance vgpuInstance, nvmlFBCStats_t *fbcStats)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetFBCStats", [this, vgpuInstance, fbcStats]() {
        return NvmlVgpuInstanceGetFBCStatsImpl(vgpuInstance, fbcStats);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFBCStatsImpl(SafeVgpuInstance vgpuInstance, nvmlFBCStats_t *fbcStats)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetFBCStatsImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetFBCStats(vgpuInstance.vgpuInstance,  fbcStats);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFBCSessions(SafeVgpuInstance vgpuInstance, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetFBCSessions", [this, vgpuInstance, sessionCount, sessionInfo]() {
        return NvmlVgpuInstanceGetFBCSessionsImpl(vgpuInstance, sessionCount, sessionInfo);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetFBCSessionsImpl(SafeVgpuInstance vgpuInstance, unsigned int *sessionCount, nvmlFBCSessionInfo_t *sessionInfo)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetFBCSessionsImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetFBCSessions(vgpuInstance.vgpuInstance,  sessionCount,  sessionInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetAccountingMode(SafeVgpuInstance vgpuInstance, nvmlEnableState_t *mode)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetAccountingMode", [this, vgpuInstance, mode]() {
        return NvmlVgpuInstanceGetAccountingModeImpl(vgpuInstance, mode);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetAccountingModeImpl(SafeVgpuInstance vgpuInstance, nvmlEnableState_t *mode)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetAccountingModeImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetAccountingMode(vgpuInstance.vgpuInstance,  mode);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetAccountingPids(SafeVgpuInstance vgpuInstance, unsigned int *count, unsigned int *pids)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetAccountingPids", [this, vgpuInstance, count, pids]() {
        return NvmlVgpuInstanceGetAccountingPidsImpl(vgpuInstance, count, pids);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetAccountingPidsImpl(SafeVgpuInstance vgpuInstance, unsigned int *count, unsigned int *pids)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetAccountingPidsImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetAccountingPids(vgpuInstance.vgpuInstance,  count,  pids);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetAccountingStats(SafeVgpuInstance vgpuInstance, unsigned int pid, nvmlAccountingStats_t *stats)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceGetAccountingStats", [this, vgpuInstance, pid, stats]() {
        return NvmlVgpuInstanceGetAccountingStatsImpl(vgpuInstance, pid, stats);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceGetAccountingStatsImpl(SafeVgpuInstance vgpuInstance, unsigned int pid, nvmlAccountingStats_t *stats)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceGetAccountingStatsImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceGetAccountingStats(vgpuInstance.vgpuInstance,  pid,  stats);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceClearAccountingPids(SafeVgpuInstance vgpuInstance)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuInstanceClearAccountingPids", [this, vgpuInstance]() {
        return NvmlVgpuInstanceClearAccountingPidsImpl(vgpuInstance);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuInstanceClearAccountingPidsImpl(SafeVgpuInstance vgpuInstance)
{
    if (vgpuInstance.generation != GetGeneration())
    {
        log_debug("NvmlVgpuInstanceClearAccountingPidsImpl: generation mismatch {}, {}", vgpuInstance.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuInstanceClearAccountingPids(vgpuInstance.vgpuInstance);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetClass(SafeVgpuTypeId vgpuTypeId, char *vgpuTypeClass, unsigned int *size)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetClass", [this, vgpuTypeId, vgpuTypeClass, size]() {
        return NvmlVgpuTypeGetClassImpl(vgpuTypeId, vgpuTypeClass, size);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetClassImpl(SafeVgpuTypeId vgpuTypeId, char *vgpuTypeClass, unsigned int *size)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetClassImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetClass(vgpuTypeId.vgpuTypeId,  vgpuTypeClass,  size);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetName(SafeVgpuTypeId vgpuTypeId, char *vgpuTypeName, unsigned int *size)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetName", [this, vgpuTypeId, vgpuTypeName, size]() {
        return NvmlVgpuTypeGetNameImpl(vgpuTypeId, vgpuTypeName, size);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetNameImpl(SafeVgpuTypeId vgpuTypeId, char *vgpuTypeName, unsigned int *size)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetNameImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetName(vgpuTypeId.vgpuTypeId,  vgpuTypeName,  size);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetGpuInstanceProfileId(SafeVgpuTypeId vgpuTypeId, unsigned int *gpuInstanceProfileId)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetGpuInstanceProfileId", [this, vgpuTypeId, gpuInstanceProfileId]() {
        return NvmlVgpuTypeGetGpuInstanceProfileIdImpl(vgpuTypeId, gpuInstanceProfileId);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetGpuInstanceProfileIdImpl(SafeVgpuTypeId vgpuTypeId, unsigned int *gpuInstanceProfileId)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetGpuInstanceProfileIdImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetGpuInstanceProfileId(vgpuTypeId.vgpuTypeId,  gpuInstanceProfileId);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetDeviceID(SafeVgpuTypeId vgpuTypeId, unsigned long long *deviceID, unsigned long long *subsystemID)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetDeviceID", [this, vgpuTypeId, deviceID, subsystemID]() {
        return NvmlVgpuTypeGetDeviceIDImpl(vgpuTypeId, deviceID, subsystemID);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetDeviceIDImpl(SafeVgpuTypeId vgpuTypeId, unsigned long long *deviceID, unsigned long long *subsystemID)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetDeviceIDImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetDeviceID(vgpuTypeId.vgpuTypeId,  deviceID,  subsystemID);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetFramebufferSize(SafeVgpuTypeId vgpuTypeId, unsigned long long *fbSize)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetFramebufferSize", [this, vgpuTypeId, fbSize]() {
        return NvmlVgpuTypeGetFramebufferSizeImpl(vgpuTypeId, fbSize);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetFramebufferSizeImpl(SafeVgpuTypeId vgpuTypeId, unsigned long long *fbSize)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetFramebufferSizeImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetFramebufferSize(vgpuTypeId.vgpuTypeId,  fbSize);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetNumDisplayHeads(SafeVgpuTypeId vgpuTypeId, unsigned int *numDisplayHeads)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetNumDisplayHeads", [this, vgpuTypeId, numDisplayHeads]() {
        return NvmlVgpuTypeGetNumDisplayHeadsImpl(vgpuTypeId, numDisplayHeads);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetNumDisplayHeadsImpl(SafeVgpuTypeId vgpuTypeId, unsigned int *numDisplayHeads)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetNumDisplayHeadsImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetNumDisplayHeads(vgpuTypeId.vgpuTypeId,  numDisplayHeads);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetResolution(SafeVgpuTypeId vgpuTypeId, unsigned int displayIndex, unsigned int *xdim, unsigned int *ydim)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetResolution", [this, vgpuTypeId, displayIndex, xdim, ydim]() {
        return NvmlVgpuTypeGetResolutionImpl(vgpuTypeId, displayIndex, xdim, ydim);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetResolutionImpl(SafeVgpuTypeId vgpuTypeId, unsigned int displayIndex, unsigned int *xdim, unsigned int *ydim)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetResolutionImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetResolution(vgpuTypeId.vgpuTypeId,  displayIndex,  xdim,  ydim);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetLicense(SafeVgpuTypeId vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetLicense", [this, vgpuTypeId, vgpuTypeLicenseString, size]() {
        return NvmlVgpuTypeGetLicenseImpl(vgpuTypeId, vgpuTypeLicenseString, size);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetLicenseImpl(SafeVgpuTypeId vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetLicenseImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetLicense(vgpuTypeId.vgpuTypeId,  vgpuTypeLicenseString,  size);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetFrameRateLimit(SafeVgpuTypeId vgpuTypeId, unsigned int *frameRateLimit)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetFrameRateLimit", [this, vgpuTypeId, frameRateLimit]() {
        return NvmlVgpuTypeGetFrameRateLimitImpl(vgpuTypeId, frameRateLimit);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetFrameRateLimitImpl(SafeVgpuTypeId vgpuTypeId, unsigned int *frameRateLimit)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetFrameRateLimitImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetFrameRateLimit(vgpuTypeId.vgpuTypeId,  frameRateLimit);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetMaxInstancesPerVm(SafeVgpuTypeId vgpuTypeId, unsigned int *vgpuInstanceCountPerVm)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetMaxInstancesPerVm", [this, vgpuTypeId, vgpuInstanceCountPerVm]() {
        return NvmlVgpuTypeGetMaxInstancesPerVmImpl(vgpuTypeId, vgpuInstanceCountPerVm);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetMaxInstancesPerVmImpl(SafeVgpuTypeId vgpuTypeId, unsigned int *vgpuInstanceCountPerVm)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetMaxInstancesPerVmImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetMaxInstancesPerVm(vgpuTypeId.vgpuTypeId,  vgpuInstanceCountPerVm);
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetCapabilities(SafeVgpuTypeId vgpuTypeId, nvmlVgpuCapability_t capability, unsigned int *capResult)
{
    std::shared_lock<std::shared_mutex> guard(m_sharedMutex);
    if (m_blockNewTasks)
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    m_ongoingTasks.fetch_add(1, std::memory_order_release);
    guard.unlock();
    DcgmNs::Defer defer([this]() {
        auto numTask = m_ongoingTasks.fetch_sub(1, std::memory_order_acq_rel);
        if (numTask == 1)
        {
            m_ongoingTasksCv.notify_one();
        }
    });
    auto task = Enqueue(DcgmNs::make_task("NvmlVgpuTypeGetCapabilities", [this, vgpuTypeId, capability, capResult]() {
        return NvmlVgpuTypeGetCapabilitiesImpl(vgpuTypeId, capability, capResult);
    }));
    if (!task.has_value())
    {
        return NVML_ERROR_UNINITIALIZED;
    }
    return task->get();
}

nvmlReturn_t NvmlTaskRunner::NvmlVgpuTypeGetCapabilitiesImpl(SafeVgpuTypeId vgpuTypeId, nvmlVgpuCapability_t capability, unsigned int *capResult)
{
    if (vgpuTypeId.generation != GetGeneration())
    {
        log_debug("NvmlVgpuTypeGetCapabilitiesImpl: generation mismatch {}, {}", vgpuTypeId.generation, GetGeneration());
        return NVML_ERROR_UNINITIALIZED;
    }
    return ::nvmlVgpuTypeGetCapabilities(vgpuTypeId.vgpuTypeId,  capability,  capResult);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemGetDriverVersion(char *version, unsigned int length)
{
    return InvokeNvmlFunction(::nvmlSystemGetDriverVersion, version, length);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemGetNVMLVersion(char *version, unsigned int length)
{
    return InvokeNvmlFunction(::nvmlSystemGetNVMLVersion, version, length);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemGetCudaDriverVersion(int *cudaDriverVersion)
{
    return InvokeNvmlFunction(::nvmlSystemGetCudaDriverVersion, cudaDriverVersion);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemGetCudaDriverVersion_v2(int *cudaDriverVersion)
{
    return InvokeNvmlFunction(::nvmlSystemGetCudaDriverVersion_v2, cudaDriverVersion);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitGetCount(unsigned int *unitCount)
{
    return InvokeNvmlFunction(::nvmlUnitGetCount, unitCount);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitGetFanSpeedInfo(nvmlUnit_t unit, nvmlUnitFanSpeeds_t *fanSpeeds)
{
    return InvokeNvmlFunction(::nvmlUnitGetFanSpeedInfo, unit, fanSpeeds);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitGetHandleByIndex(unsigned int index, nvmlUnit_t *unit)
{
    return InvokeNvmlFunction(::nvmlUnitGetHandleByIndex, index, unit);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitGetLedState(nvmlUnit_t unit, nvmlLedState_t *state)
{
    return InvokeNvmlFunction(::nvmlUnitGetLedState, unit, state);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitSetLedState(nvmlUnit_t unit, nvmlLedColor_t color)
{
    return InvokeNvmlFunction(::nvmlUnitSetLedState, unit, color);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitGetPsuInfo(nvmlUnit_t unit, nvmlPSUInfo_t *psu)
{
    return InvokeNvmlFunction(::nvmlUnitGetPsuInfo, unit, psu);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitGetTemperature(nvmlUnit_t unit, unsigned int type, unsigned int *temp)
{
    return InvokeNvmlFunction(::nvmlUnitGetTemperature, unit, type, temp);
}

nvmlReturn_t NvmlTaskRunner::NvmlUnitGetUnitInfo(nvmlUnit_t unit, nvmlUnitInfo_t *info)
{
    return InvokeNvmlFunction(::nvmlUnitGetUnitInfo, unit, info);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemGetHicVersion(unsigned int *hwbcCount, nvmlHwbcEntry_t *hwbcEntries)
{
    return InvokeNvmlFunction(::nvmlSystemGetHicVersion, hwbcCount, hwbcEntries);
}

nvmlReturn_t NvmlTaskRunner::NvmlEventSetCreate(nvmlEventSet_t * set)
{
    return InvokeNvmlFunction(::nvmlEventSetCreate, set);
}

nvmlReturn_t NvmlTaskRunner::NvmlEventSetFree(nvmlEventSet_t set)
{
    return InvokeNvmlFunction(::nvmlEventSetFree, set);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemGetProcessName(unsigned int pid, char *name, unsigned int length)
{
    return InvokeNvmlFunction(::nvmlSystemGetProcessName, pid, name, length);
}

nvmlReturn_t NvmlTaskRunner::NvmlGetVgpuCompatibility(nvmlVgpuMetadata_t * vgpuMetadata, nvmlVgpuPgpuMetadata_t *pgpuMetadata, nvmlVgpuPgpuCompatibility_t *compatibilityInfo)
{
    return InvokeNvmlFunction(::nvmlGetVgpuCompatibility, vgpuMetadata, pgpuMetadata, compatibilityInfo);
}

nvmlReturn_t NvmlTaskRunner::NvmlGetExcludedDeviceCount(unsigned int *deviceCount)
{
    return InvokeNvmlFunction(::nvmlGetExcludedDeviceCount, deviceCount);
}

nvmlReturn_t NvmlTaskRunner::NvmlGetExcludedDeviceInfoByIndex(unsigned int index, nvmlExcludedDeviceInfo_t *info)
{
    return InvokeNvmlFunction(::nvmlGetExcludedDeviceInfoByIndex, index, info);
}

nvmlReturn_t NvmlTaskRunner::NvmlGetVgpuVersion(nvmlVgpuVersion_t * supported, nvmlVgpuVersion_t *current)
{
    return InvokeNvmlFunction(::nvmlGetVgpuVersion, supported, current);
}

nvmlReturn_t NvmlTaskRunner::NvmlSetVgpuVersion(nvmlVgpuVersion_t * vgpuVersion)
{
    return InvokeNvmlFunction(::nvmlSetVgpuVersion, vgpuVersion);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemGetConfComputeState(nvmlConfComputeSystemState_t * ccMode)
{
    return InvokeNvmlFunction(::nvmlSystemGetConfComputeState, ccMode);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmMetricsGet(nvmlGpmMetricsGet_t * metricsGet)
{
    return InvokeNvmlFunction(::nvmlGpmMetricsGet, metricsGet);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmSampleAlloc(nvmlGpmSample_t * gpmSample)
{
    return InvokeNvmlFunction(::nvmlGpmSampleAlloc, gpmSample);
}

nvmlReturn_t NvmlTaskRunner::NvmlGpmSampleFree(nvmlGpmSample_t gpmSample)
{
    return InvokeNvmlFunction(::nvmlGpmSampleFree, gpmSample);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemEventSetCreate(nvmlSystemEventSetCreateRequest_t * request)
{
    return InvokeNvmlFunction(::nvmlSystemEventSetCreate, request);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemEventSetFree(nvmlSystemEventSetFreeRequest_t * request)
{
    return InvokeNvmlFunction(::nvmlSystemEventSetFree, request);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemRegisterEvents(nvmlSystemRegisterEventRequest_t * request)
{
    return InvokeNvmlFunction(::nvmlSystemRegisterEvents, request);
}

nvmlReturn_t NvmlTaskRunner::NvmlSystemEventSetWait(nvmlSystemEventSetWaitRequest_t * request)
{
    return InvokeNvmlFunction(::nvmlSystemEventSetWait, request);
}
#pragma GCC diagnostic pop
