/*
 * Copyright (c) 2025, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * NOTE: This code is auto-generated by generate_nvml_stubs.py
 * DO NOT EDIT MANUALLY
 */


#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-parameter"

// clang-format off
#include "InjectedNvml.h"
#include "nvml.h"
#include "PassThruNvml.h"

#ifdef __cplusplus
extern "C"
{
#endif

bool GLOBAL_PASS_THROUGH_MODE = false;

nvmlReturn_t nvmlDeviceGetClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetClockInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(type));
        preparedValues.push_back(InjectionArgument(clock));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ClockInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ClockInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMaxClockInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(type));
        preparedValues.push_back(InjectionArgument(clock));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MaxClockInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MaxClockInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeMode(nvmlDevice_t device, nvmlComputeMode_t *mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetComputeMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(mode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetComputeMode(nvmlDevice_t device, nvmlComputeMode_t mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetComputeMode");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(mode);
        return injectedNvml->DeviceSet(device, "ComputeMode", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCudaComputeCapability(nvmlDevice_t device, int *major, int *minor)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCudaComputeCapability");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(major));
        preparedValues.push_back(InjectionArgument(minor));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CudaComputeCapability", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CudaComputeCapability", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetDriverModel(nvmlDevice_t device, nvmlDriverModel_t driverModel, unsigned int flags)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetDriverModel");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(driverModel));
        args.push_back(InjectionArgument(flags));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DriverModel", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DriverModel", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDriverModel(nvmlDevice_t device, nvmlDriverModel_t *current, nvmlDriverModel_t *pending)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDriverModel");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(current));
        preparedValues.push_back(InjectionArgument(pending));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DriverModel", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DriverModel", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCount(unsigned int *deviceCount)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCount");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(deviceCount);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("Count"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByIndex(unsigned int index, nvmlDevice_t *device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetHandleByIndex");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument identifier(index);
        *device = injectedNvml->GetNvmlDevice(identifier, "Index");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleBySerial(const char *serial, nvmlDevice_t *device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetHandleBySerial");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument identifier(serial);
        *device = injectedNvml->GetNvmlDevice(identifier, "Serial");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByUUID(const char *uuid, nvmlDevice_t *device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetHandleByUUID");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument identifier(uuid);
        *device = injectedNvml->GetNvmlDevice(identifier, "UUID");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByPciBusId(const char *pciBusId, nvmlDevice_t *device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetHandleByPciBusId");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument identifier(pciBusId);
        *device = injectedNvml->GetNvmlDevice(identifier, "PciBusId");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByPciBusId_v2(const char *pciBusId, nvmlDevice_t *device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetHandleByPciBusId_v2");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument identifier(pciBusId);
        *device = injectedNvml->GetNvmlDevice(identifier, "PciBusId");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetInforomVersion(nvmlDevice_t device,
                                         nvmlInforomObject_t object,
                                         char *version,
                                         unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetInforomVersion");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "InforomVersion", InjectionArgument(object));
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(version, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetInforomImageVersion(nvmlDevice_t device, char *version, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetInforomImageVersion");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "InforomImageVersion");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(version, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDisplayMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDisplayMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(mode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DisplayMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DisplayMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEccMode(nvmlDevice_t device, nvmlEnableState_t *current, nvmlEnableState_t *pending)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetEccMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(current));
        preparedValues.push_back(InjectionArgument(pending));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EccMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EccMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDefaultEccMode(nvmlDevice_t device, nvmlEnableState_t *defaultMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDefaultEccMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(defaultMode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DefaultEccMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DefaultEccMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBoardId(nvmlDevice_t device, unsigned int *boardId)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetBoardId");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(boardId));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "BoardId", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "BoardId", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMultiGpuBoard(nvmlDevice_t device, unsigned int *multiGpuBool)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMultiGpuBoard");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(multiGpuBool));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MultiGpuBoard", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MultiGpuBoard", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDetailedEccErrors(nvmlDevice_t device,
                                            nvmlMemoryErrorType_t errorType,
                                            nvmlEccCounterType_t counterType,
                                            nvmlEccErrorCounts_t *eccCounts)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDetailedEccErrors");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(errorType));
        args.push_back(InjectionArgument(counterType));
        preparedValues.push_back(InjectionArgument(eccCounts));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DetailedEccErrors", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DetailedEccErrors", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTotalEccErrors(nvmlDevice_t device,
                                         nvmlMemoryErrorType_t errorType,
                                         nvmlEccCounterType_t counterType,
                                         unsigned long long *eccCounts)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetTotalEccErrors");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(errorType));
        args.push_back(InjectionArgument(counterType));
        preparedValues.push_back(InjectionArgument(eccCounts));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "TotalEccErrors", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "TotalEccErrors", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetEccMode(nvmlDevice_t device, nvmlEnableState_t ecc)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetEccMode");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(ecc);
        return injectedNvml->DeviceSet(device, "EccMode", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceClearEccErrorCounts(nvmlDevice_t device, nvmlEccCounterType_t counterType)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceClearEccErrorCounts");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(counterType));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EccErrorCounts", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EccErrorCounts", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetName(nvmlDevice_t device, char *name, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetName");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "Name");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(name, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBrand(nvmlDevice_t device, nvmlBrandType_t *type)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetBrand");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(type));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Brand", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Brand", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSerial(nvmlDevice_t device, char *serial, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSerial");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "Serial");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(serial, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBoardPartNumber(nvmlDevice_t device, char *partNumber, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetBoardPartNumber");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "BoardPartNumber");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(partNumber, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryAffinity(nvmlDevice_t device,
                                         unsigned int nodeSetSize,
                                         unsigned long *nodeSet,
                                         nvmlAffinityScope_t scope)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMemoryAffinity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(nodeSet));
        args.push_back(InjectionArgument(scope));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemoryAffinity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemoryAffinity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCpuAffinityWithinScope(nvmlDevice_t device,
                                                 unsigned int cpuSetSize,
                                                 unsigned long *cpuSet,
                                                 nvmlAffinityScope_t scope)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCpuAffinityWithinScope");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(cpuSet));
        args.push_back(InjectionArgument(scope));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CpuAffinityWithinScope", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CpuAffinityWithinScope", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCpuAffinity(nvmlDevice_t device, unsigned int cpuSetSize, unsigned long *cpuSet)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCpuAffinity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(cpuSet));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CpuAffinity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CpuAffinity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetCpuAffinity(nvmlDevice_t device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetCpuAffinity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CpuAffinity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CpuAffinity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceClearCpuAffinity(nvmlDevice_t device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceClearCpuAffinity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CpuAffinity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CpuAffinity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetUUID(nvmlDevice_t device, char *uuid, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetUUID");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "UUID");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(uuid, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryInfo(nvmlDevice_t device, nvmlMemory_t *memory)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMemoryInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(memory));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemoryInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemoryInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryInfo_v2(nvmlDevice_t device, nvmlMemory_v2_t *memory)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMemoryInfo_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(memory));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemoryInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemoryInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPciInfo(nvmlDevice_t device, nvmlPciInfo_t *pci)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPciInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pci));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PciInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PciInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPciInfo_v2(nvmlDevice_t device, nvmlPciInfo_t *pci)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPciInfo_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pci));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PciInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PciInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPciInfo_v3(nvmlDevice_t device, nvmlPciInfo_t *pci)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPciInfo_v3");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pci));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PciInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PciInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPersistenceMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(mode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PersistenceMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PersistenceMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetPersistenceMode");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(mode);
        return injectedNvml->DeviceSet(device, "PersistenceMode", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBAR1MemoryInfo(nvmlDevice_t device, nvmlBAR1Memory_t *bar1Memory)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetBAR1MemoryInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(bar1Memory));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "BAR1MemoryInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "BAR1MemoryInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetViolationStatus(nvmlDevice_t device,
                                          nvmlPerfPolicyType_t perfPolicyType,
                                          nvmlViolationTime_t *violTime)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetViolationStatus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(perfPolicyType));
        preparedValues.push_back(InjectionArgument(violTime));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ViolationStatus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ViolationStatus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerState(nvmlDevice_t device, nvmlPstates_t *pState)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pState));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPerformanceState(nvmlDevice_t device, nvmlPstates_t *pState)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPerformanceState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pState));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PerformanceState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PerformanceState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerUsage(nvmlDevice_t device, unsigned int *power)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerUsage");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(power));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerUsage", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerUsage", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerMode(nvmlDevice_t device, unsigned int *powerModeId)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(powerModeId));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedPowerModes(nvmlDevice_t device, unsigned int *supportedPowerModes)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedPowerModes");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(supportedPowerModes));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedPowerModes", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedPowerModes", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetPowerMode(nvmlDevice_t device, unsigned int powerModeId)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetPowerMode");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(powerModeId);
        return injectedNvml->DeviceSet(device, "PowerMode", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTotalEnergyConsumption(nvmlDevice_t device, unsigned long long *energy)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetTotalEnergyConsumption");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(energy));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "TotalEnergyConsumption", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "TotalEnergyConsumption", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerManagementMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(mode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerManagementMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerManagementMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int *limit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerManagementLimit");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(limit));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerManagementLimit", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerManagementLimit", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTemperature(nvmlDevice_t device, nvmlTemperatureSensors_t sensorType, unsigned int *temp)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetTemperature");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(sensorType));
        preparedValues.push_back(InjectionArgument(temp));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Temperature", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Temperature", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTemperatureThreshold(nvmlDevice_t device,
                                               nvmlTemperatureThresholds_t thresholdType,
                                               unsigned int *temp)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetTemperatureThreshold");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(thresholdType));
        preparedValues.push_back(InjectionArgument(temp));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "TemperatureThreshold", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "TemperatureThreshold", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetTemperatureThreshold(nvmlDevice_t device,
                                               nvmlTemperatureThresholds_t thresholdType,
                                               int *temp)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetTemperatureThreshold");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument extraKey(thresholdType);
        InjectionArgument value(temp);
        return injectedNvml->DeviceSet(device, "TemperatureThreshold", {extraKey}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMarginTemperature(nvmlDevice_t device, nvmlMarginTemperature_t *marginTempInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMarginTemperature");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(marginTempInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MarginTemperature", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MarginTemperature", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFanSpeed(nvmlDevice_t device, unsigned int *speed)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetFanSpeed");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(speed));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FanSpeed", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FanSpeed", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFanSpeed_v2(nvmlDevice_t device, unsigned int fan, unsigned int *speed)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetFanSpeed_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(fan));
        preparedValues.push_back(InjectionArgument(speed));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FanSpeed", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FanSpeed", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTargetFanSpeed(nvmlDevice_t device, unsigned int fan, unsigned int *targetSpeed)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetTargetFanSpeed");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(fan));
        preparedValues.push_back(InjectionArgument(targetSpeed));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "TargetFanSpeed", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "TargetFanSpeed", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNumFans(nvmlDevice_t device, unsigned int *numFans)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNumFans");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(numFans));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NumFans", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NumFans", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetUtilizationRates(nvmlDevice_t device, nvmlUtilization_t *utilization)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetUtilizationRates");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(utilization));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "UtilizationRates", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "UtilizationRates", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderUtilization(nvmlDevice_t device,
                                             unsigned int *utilization,
                                             unsigned int *samplingPeriodUs)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetEncoderUtilization");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(utilization));
        preparedValues.push_back(InjectionArgument(samplingPeriodUs));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderUtilization", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderUtilization", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDecoderUtilization(nvmlDevice_t device,
                                             unsigned int *utilization,
                                             unsigned int *samplingPeriodUs)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDecoderUtilization");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(utilization));
        preparedValues.push_back(InjectionArgument(samplingPeriodUs));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DecoderUtilization", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DecoderUtilization", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice_t device, unsigned int *maxLinkGen)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMaxPcieLinkGeneration");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(maxLinkGen));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MaxPcieLinkGeneration", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MaxPcieLinkGeneration", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice_t device, unsigned int *maxLinkWidth)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMaxPcieLinkWidth");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(maxLinkWidth));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MaxPcieLinkWidth", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MaxPcieLinkWidth", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice_t device, unsigned int *currLinkGen)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCurrPcieLinkGeneration");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(currLinkGen));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CurrPcieLinkGeneration", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CurrPcieLinkGeneration", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice_t device, unsigned int *currLinkWidth)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCurrPcieLinkWidth");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(currLinkWidth));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CurrPcieLinkWidth", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CurrPcieLinkWidth", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetDriverVersion(char *version, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetDriverVersion");
        // The following snippet is generated from generate_getter_functions
        std::string str    = injectedNvml->ObjectlessGet("DriverVersion").AsString();
        snprintf(version, length, "%s", str.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetNVMLVersion(char *version, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetNVMLVersion");
        // The following snippet is generated from generate_getter_functions
        std::string str    = injectedNvml->ObjectlessGet("NVMLVersion").AsString();
        snprintf(version, length, "%s", str.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetCudaDriverVersion(int *cudaDriverVersion)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetCudaDriverVersion");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(cudaDriverVersion);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("CudaDriverVersion"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetCudaDriverVersion_v2(int *cudaDriverVersion)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetCudaDriverVersion_v2");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(cudaDriverVersion);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("CudaDriverVersion"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetCount(unsigned int *unitCount)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetCount");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(unitCount);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("Count"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetFanSpeedInfo(nvmlUnit_t unit, nvmlUnitFanSpeeds_t *fanSpeeds)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetFanSpeedInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(unit));
        preparedValues.push_back(InjectionArgument(fanSpeeds));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FanSpeedInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FanSpeedInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetHandleByIndex(unsigned int index, nvmlUnit_t *unit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetHandleByIndex");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(index));
        preparedValues.push_back(InjectionArgument(unit));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "HandleByIndex", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "HandleByIndex", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetLedState(nvmlUnit_t unit, nvmlLedState_t *state)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetLedState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(unit));
        preparedValues.push_back(InjectionArgument(state));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "LedState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "LedState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitSetLedState(nvmlUnit_t unit, nvmlLedColor_t color)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitSetLedState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(unit));
        args.push_back(InjectionArgument(color));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "LedState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "LedState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetPsuInfo(nvmlUnit_t unit, nvmlPSUInfo_t *psu)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetPsuInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(unit));
        preparedValues.push_back(InjectionArgument(psu));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PsuInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PsuInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetTemperature(nvmlUnit_t unit, unsigned int type, unsigned int *temp)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetTemperature");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(unit));
        args.push_back(InjectionArgument(type));
        preparedValues.push_back(InjectionArgument(temp));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Temperature", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Temperature", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetUnitInfo(nvmlUnit_t unit, nvmlUnitInfo_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetUnitInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(unit));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "UnitInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "UnitInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetDevices(nvmlUnit_t unit, unsigned int *deviceCount, nvmlDevice_t *devices)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlUnitGetDevices");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(unit));
        preparedValues.push_back(InjectionArgument(deviceCount));
        preparedValues.push_back(InjectionArgument(devices));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Devices", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Devices", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVbiosVersion(nvmlDevice_t device, char *version, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetVbiosVersion");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "VbiosVersion");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(version, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBridgeChipInfo(nvmlDevice_t device, nvmlBridgeChipHierarchy_t *bridgeHierarchy)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetBridgeChipInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(bridgeHierarchy));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "BridgeChipInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "BridgeChipInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetHicVersion(unsigned int *hwbcCount, nvmlHwbcEntry_t *hwbcEntries)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetHicVersion");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(hwbcCount));
        preparedValues.push_back(InjectionArgument(hwbcEntries));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "HicVersion", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "HicVersion", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetCreate(nvmlEventSet_t *set)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlEventSetCreate");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(set));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceRegisterEvents(nvmlDevice_t device, unsigned long long eventTypes, nvmlEventSet_t set)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceRegisterEvents");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(eventTypes));
        args.push_back(InjectionArgument(set));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RegisterEvents", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RegisterEvents", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedEventTypes(nvmlDevice_t device, unsigned long long *eventTypes)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedEventTypes");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(eventTypes));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedEventTypes", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedEventTypes", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetWait(nvmlEventSet_t set, nvmlEventData_t *data, unsigned int timeoutms)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlEventSetWait");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(set));
        preparedValues.push_back(InjectionArgument(data));
        args.push_back(InjectionArgument(timeoutms));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetWait_v2(nvmlEventSet_t set, nvmlEventData_t *data, unsigned int timeoutms)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlEventSetWait_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(set));
        preparedValues.push_back(InjectionArgument(data));
        args.push_back(InjectionArgument(timeoutms));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetFree(nvmlEventSet_t set)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlEventSetFree");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(set));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeRunningProcesses(nvmlDevice_t device,
                                                  unsigned int *infoCount,
                                                  nvmlProcessInfo_v1_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetComputeRunningProcesses");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeRunningProcesses_v2(nvmlDevice_t device,
                                                     unsigned int *infoCount,
                                                     nvmlProcessInfo_v2_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetComputeRunningProcesses_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeRunningProcesses_v3(nvmlDevice_t device,
                                                     unsigned int *infoCount,
                                                     nvmlProcessInfo_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetComputeRunningProcesses_v3");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice_t device,
                                                   unsigned int *infoCount,
                                                   nvmlProcessInfo_v1_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGraphicsRunningProcesses");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GraphicsRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GraphicsRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses_v2(nvmlDevice_t device,
                                                      unsigned int *infoCount,
                                                      nvmlProcessInfo_v2_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGraphicsRunningProcesses_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GraphicsRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GraphicsRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses_v3(nvmlDevice_t device,
                                                      unsigned int *infoCount,
                                                      nvmlProcessInfo_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGraphicsRunningProcesses_v3");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GraphicsRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GraphicsRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMPSComputeRunningProcesses(nvmlDevice_t device,
                                                     unsigned int *infoCount,
                                                     nvmlProcessInfo_v1_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMPSComputeRunningProcesses");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MPSComputeRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MPSComputeRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMPSComputeRunningProcesses_v2(nvmlDevice_t device,
                                                        unsigned int *infoCount,
                                                        nvmlProcessInfo_v2_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMPSComputeRunningProcesses_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MPSComputeRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MPSComputeRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMPSComputeRunningProcesses_v3(nvmlDevice_t device,
                                                        unsigned int *infoCount,
                                                        nvmlProcessInfo_t *infos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMPSComputeRunningProcesses_v3");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(infoCount));
        preparedValues.push_back(InjectionArgument(infos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MPSComputeRunningProcesses", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MPSComputeRunningProcesses", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetProcessName(unsigned int pid, char *name, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetProcessName");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(pid);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "ProcessName");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(name, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceOnSameBoard(nvmlDevice_t dev1, nvmlDevice_t dev2, int *onSameBoard)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceOnSameBoard");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(dev1));
        args.push_back(InjectionArgument(dev2));
        preparedValues.push_back(InjectionArgument(onSameBoard));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "OnSameBoard", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "OnSameBoard", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice_t device, unsigned int *checksum)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetInforomConfigurationChecksum");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(checksum));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "InforomConfigurationChecksum", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "InforomConfigurationChecksum", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceValidateInforom(nvmlDevice_t device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceValidateInforom");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ValidateInforom", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ValidateInforom", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuOperationMode(nvmlDevice_t device,
                                           nvmlGpuOperationMode_t *current,
                                           nvmlGpuOperationMode_t *pending)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuOperationMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(current));
        preparedValues.push_back(InjectionArgument(pending));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuOperationMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuOperationMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetGpuOperationMode");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(mode);
        return injectedNvml->DeviceSet(device, "GpuOperationMode", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDisplayActive(nvmlDevice_t device, nvmlEnableState_t *isActive)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDisplayActive");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(isActive));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DisplayActive", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DisplayActive", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryErrorCounter(nvmlDevice_t device,
                                             nvmlMemoryErrorType_t errorType,
                                             nvmlEccCounterType_t counterType,
                                             nvmlMemoryLocation_t locationType,
                                             unsigned long long *count)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMemoryErrorCounter");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(errorType));
        args.push_back(InjectionArgument(counterType));
        args.push_back(InjectionArgument(locationType));
        preparedValues.push_back(InjectionArgument(count));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemoryErrorCounter", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemoryErrorCounter", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSramEccErrorStatus(nvmlDevice_t device, nvmlEccSramErrorStatus_t *status)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSramEccErrorStatus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(status));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SramEccErrorStatus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SramEccErrorStatus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetGpuLockedClocks(nvmlDevice_t device, unsigned int minGpuClockMHz, unsigned int maxGpuClockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetGpuLockedClocks");
        // The following snippet is generated from generate_setter_functions
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(minGpuClockMHz));
        preparedValues.push_back(InjectionArgument(maxGpuClockMHz));
        CompoundValue cv(preparedValues);
        return injectedNvml->DeviceSet(device, "GpuLockedClocks", {}, NvmlFuncReturn(NVML_SUCCESS, cv));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetGpuLockedClocks(nvmlDevice_t device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceResetGpuLockedClocks");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuLockedClocks", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuLockedClocks", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetMemoryLockedClocks(nvmlDevice_t device,
                                             unsigned int minMemClockMHz,
                                             unsigned int maxMemClockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetMemoryLockedClocks");
        // The following snippet is generated from generate_setter_functions
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(minMemClockMHz));
        preparedValues.push_back(InjectionArgument(maxMemClockMHz));
        CompoundValue cv(preparedValues);
        return injectedNvml->DeviceSet(device, "MemoryLockedClocks", {}, NvmlFuncReturn(NVML_SUCCESS, cv));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetMemoryLockedClocks(nvmlDevice_t device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceResetMemoryLockedClocks");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemoryLockedClocks", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemoryLockedClocks", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetApplicationsClocks(nvmlDevice_t device,
                                             unsigned int memClockMHz,
                                             unsigned int graphicsClockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetApplicationsClocks");
        // The following snippet is generated from generate_setter_functions
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(memClockMHz));
        preparedValues.push_back(InjectionArgument(graphicsClockMHz));
        CompoundValue cv(preparedValues);
        return injectedNvml->DeviceSet(device, "ApplicationsClocks", {}, NvmlFuncReturn(NVML_SUCCESS, cv));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetApplicationsClock");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(clockType));
        preparedValues.push_back(InjectionArgument(clockMHz));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ApplicationsClock", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ApplicationsClock", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMaxCustomerBoostClock");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(clockType));
        preparedValues.push_back(InjectionArgument(clockMHz));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MaxCustomerBoostClock", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MaxCustomerBoostClock", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetClock(nvmlDevice_t device,
                                nvmlClockType_t clockType,
                                nvmlClockId_t clockId,
                                unsigned int *clockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetClock");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(clockType));
        args.push_back(InjectionArgument(clockId));
        preparedValues.push_back(InjectionArgument(clockMHz));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Clock", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Clock", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDefaultApplicationsClock(nvmlDevice_t device,
                                                   nvmlClockType_t clockType,
                                                   unsigned int *clockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDefaultApplicationsClock");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(clockType));
        preparedValues.push_back(InjectionArgument(clockMHz));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DefaultApplicationsClock", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DefaultApplicationsClock", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetApplicationsClocks(nvmlDevice_t device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceResetApplicationsClocks");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ApplicationsClocks", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ApplicationsClocks", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedMemoryClocks(nvmlDevice_t device, unsigned int *count, unsigned int *clocksMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedMemoryClocks");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(clocksMHz));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedMemoryClocks", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedMemoryClocks", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice_t device,
                                                  unsigned int memoryClockMHz,
                                                  unsigned int *count,
                                                  unsigned int *clocksMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedGraphicsClocks");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(memoryClockMHz));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(clocksMHz));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedGraphicsClocks", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedGraphicsClocks", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice_t device,
                                                   nvmlEnableState_t *isEnabled,
                                                   nvmlEnableState_t *defaultIsEnabled)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAutoBoostedClocksEnabled");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(isEnabled));
        preparedValues.push_back(InjectionArgument(defaultIsEnabled));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AutoBoostedClocksEnabled", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AutoBoostedClocksEnabled", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetAutoBoostedClocksEnabled");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(enabled);
        return injectedNvml->DeviceSet(device, "AutoBoostedClocksEnabled", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice_t device,
                                                          nvmlEnableState_t enabled,
                                                          unsigned int flags)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetDefaultAutoBoostedClocksEnabled");
        // The following snippet is generated from generate_setter_functions
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(enabled));
        preparedValues.push_back(InjectionArgument(flags));
        CompoundValue cv(preparedValues);
        return injectedNvml->DeviceSet(device, "DefaultAutoBoostedClocksEnabled", {}, NvmlFuncReturn(NVML_SUCCESS, cv));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device,
                                                          unsigned int *minLimit,
                                                          unsigned int *maxLimit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerManagementLimitConstraints");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(minLimit));
        preparedValues.push_back(InjectionArgument(maxLimit));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerManagementLimitConstraints", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerManagementLimitConstraints", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice_t device, unsigned int *defaultLimit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerManagementDefaultLimit");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(defaultLimit));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerManagementDefaultLimit", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerManagementDefaultLimit", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int limit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetPowerManagementLimit");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(limit);
        return injectedNvml->DeviceSet(device, "PowerManagementLimit", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCurrentClocksEventReasons(nvmlDevice_t device, unsigned long long *clocksEventReasons)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCurrentClocksEventReasons");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(clocksEventReasons));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CurrentClocksEventReasons", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CurrentClocksEventReasons", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice_t device, unsigned long long *clocksThrottleReasons)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCurrentClocksThrottleReasons");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(clocksThrottleReasons));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CurrentClocksThrottleReasons", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CurrentClocksThrottleReasons", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedClocksEventReasons(nvmlDevice_t device,
                                                      unsigned long long *supportedClocksEventReasons)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedClocksEventReasons");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(supportedClocksEventReasons));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedClocksEventReasons", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedClocksEventReasons", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice_t device,
                                                         unsigned long long *supportedClocksThrottleReasons)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedClocksThrottleReasons");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(supportedClocksThrottleReasons));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedClocksThrottleReasons", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedClocksThrottleReasons", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetIndex(nvmlDevice_t device, unsigned int *index)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetIndex");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(index));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Index", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Index", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAccountingMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(mode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetAccountingMode(nvmlDevice_t device, nvmlEnableState_t mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetAccountingMode");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(mode);
        return injectedNvml->DeviceSet(device, "AccountingMode", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceClearAccountingPids(nvmlDevice_t device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceClearAccountingPids");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingPids", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingPids", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingStats(nvmlDevice_t device, unsigned int pid, nvmlAccountingStats_t *stats)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAccountingStats");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(pid));
        preparedValues.push_back(InjectionArgument(stats));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingStats", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingStats", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingPids(nvmlDevice_t device, unsigned int *count, unsigned int *pids)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAccountingPids");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(pids));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingPids", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingPids", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingBufferSize(nvmlDevice_t device, unsigned int *bufferSize)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAccountingBufferSize");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(bufferSize));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingBufferSize", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingBufferSize", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRetiredPages(nvmlDevice_t device,
                                       nvmlPageRetirementCause_t sourceFilter,
                                       unsigned int *count,
                                       unsigned long long *addresses)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetRetiredPages");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(sourceFilter));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(addresses));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RetiredPages", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RetiredPages", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRetiredPages_v2(nvmlDevice_t device,
                                          nvmlPageRetirementCause_t sourceFilter,
                                          unsigned int *count,
                                          unsigned long long *addresses,
                                          unsigned long long *timestamps)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetRetiredPages_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(sourceFilter));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(addresses));
        preparedValues.push_back(InjectionArgument(timestamps));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RetiredPages", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RetiredPages", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice_t device, nvmlEnableState_t *isPending)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetRetiredPagesPendingStatus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(isPending));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RetiredPagesPendingStatus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RetiredPagesPendingStatus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetAPIRestriction(nvmlDevice_t device,
                                         nvmlRestrictedAPI_t apiType,
                                         nvmlEnableState_t isRestricted)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetAPIRestriction");
        // The following snippet is generated from generate_setter_functions
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(apiType));
        preparedValues.push_back(InjectionArgument(isRestricted));
        CompoundValue cv(preparedValues);
        return injectedNvml->DeviceSet(device, "APIRestriction", {}, NvmlFuncReturn(NVML_SUCCESS, cv));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAPIRestriction(nvmlDevice_t device,
                                         nvmlRestrictedAPI_t apiType,
                                         nvmlEnableState_t *isRestricted)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAPIRestriction");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(apiType));
        preparedValues.push_back(InjectionArgument(isRestricted));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "APIRestriction", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "APIRestriction", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMinorNumber(nvmlDevice_t device, unsigned int *minorNumber)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMinorNumber");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(minorNumber));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MinorNumber", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MinorNumber", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEnforcedPowerLimit(nvmlDevice_t device, unsigned int *limit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetEnforcedPowerLimit");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(limit));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EnforcedPowerLimit", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EnforcedPowerLimit", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSamples(nvmlDevice_t device,
                                  nvmlSamplingType_t type,
                                  unsigned long long lastSeenTimeStamp,
                                  nvmlValueType_t *sampleValType,
                                  unsigned int *sampleCount,
                                  nvmlSample_t *samples)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSamples");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(type));
        args.push_back(InjectionArgument(lastSeenTimeStamp));
        preparedValues.push_back(InjectionArgument(sampleValType));
        preparedValues.push_back(InjectionArgument(sampleCount));
        preparedValues.push_back(InjectionArgument(samples));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Samples", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Samples", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieThroughput(nvmlDevice_t device, nvmlPcieUtilCounter_t counter, unsigned int *value)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPcieThroughput");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(counter));
        preparedValues.push_back(InjectionArgument(value));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PcieThroughput", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PcieThroughput", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieReplayCounter(nvmlDevice_t device, unsigned int *value)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPcieReplayCounter");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(value));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PcieReplayCounter", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PcieReplayCounter", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTopologyCommonAncestor(nvmlDevice_t device1,
                                                 nvmlDevice_t device2,
                                                 nvmlGpuTopologyLevel_t *pathInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetTopologyCommonAncestor");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device1));
        args.push_back(InjectionArgument(device2));
        preparedValues.push_back(InjectionArgument(pathInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "TopologyCommonAncestor", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "TopologyCommonAncestor", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTopologyNearestGpus(nvmlDevice_t device,
                                              nvmlGpuTopologyLevel_t level,
                                              unsigned int *count,
                                              nvmlDevice_t *deviceArray)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetTopologyNearestGpus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(level));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(deviceArray));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "TopologyNearestGpus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "TopologyNearestGpus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetTopologyGpuSet(unsigned int cpuNumber, unsigned int *count, nvmlDevice_t *deviceArray)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetTopologyGpuSet");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(cpuNumber));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(deviceArray));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "TopologyGpuSet", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "TopologyGpuSet", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkState(nvmlDevice_t device, unsigned int link, nvmlEnableState_t *isActive)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        preparedValues.push_back(InjectionArgument(isActive));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetP2PStatus(nvmlDevice_t device1,
                                    nvmlDevice_t device2,
                                    nvmlGpuP2PCapsIndex_t p2pIndex,
                                    nvmlGpuP2PStatus_t *p2pStatus)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetP2PStatus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device1));
        args.push_back(InjectionArgument(device2));
        args.push_back(InjectionArgument(p2pIndex));
        preparedValues.push_back(InjectionArgument(p2pStatus));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "P2PStatus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "P2PStatus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkVersion(nvmlDevice_t device, unsigned int link, unsigned int *version)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkVersion");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        preparedValues.push_back(InjectionArgument(version));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkVersion", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkVersion", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkRemotePciInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        preparedValues.push_back(InjectionArgument(pci));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkRemotePciInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkRemotePciInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkRemotePciInfo_v2(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkRemotePciInfo_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        preparedValues.push_back(InjectionArgument(pci));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkRemotePciInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkRemotePciInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkRemoteDeviceType(nvmlDevice_t device,
                                                 unsigned int link,
                                                 nvmlIntNvLinkDeviceType_t *pNvLinkDeviceType)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkRemoteDeviceType");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        preparedValues.push_back(InjectionArgument(pNvLinkDeviceType));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkRemoteDeviceType", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkRemoteDeviceType", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkCapability(nvmlDevice_t device,
                                           unsigned int link,
                                           nvmlNvLinkCapability_t capability,
                                           unsigned int *capResult)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkCapability");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        args.push_back(InjectionArgument(capability));
        preparedValues.push_back(InjectionArgument(capResult));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkCapability", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkCapability", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkErrorCounter(nvmlDevice_t device,
                                             unsigned int link,
                                             nvmlNvLinkErrorCounter_t counter,
                                             unsigned long long *counterValue)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkErrorCounter");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        args.push_back(InjectionArgument(counter));
        preparedValues.push_back(InjectionArgument(counterValue));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkErrorCounter", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkErrorCounter", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetNvLinkErrorCounters(nvmlDevice_t device, unsigned int link)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceResetNvLinkErrorCounters");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkErrorCounters", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkErrorCounters", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice_t device,
                                                   unsigned int link,
                                                   unsigned int counter,
                                                   nvmlNvLinkUtilizationControl_t *control,
                                                   unsigned int reset)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetNvLinkUtilizationControl");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        args.push_back(InjectionArgument(counter));
        preparedValues.push_back(InjectionArgument(control));
        args.push_back(InjectionArgument(reset));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkUtilizationControl", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkUtilizationControl", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice_t device,
                                                   unsigned int link,
                                                   unsigned int counter,
                                                   nvmlNvLinkUtilizationControl_t *control)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkUtilizationControl");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        args.push_back(InjectionArgument(counter));
        preparedValues.push_back(InjectionArgument(control));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkUtilizationControl", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkUtilizationControl", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice_t device,
                                                   unsigned int link,
                                                   unsigned int counter,
                                                   unsigned long long *rxcounter,
                                                   unsigned long long *txcounter)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNvLinkUtilizationCounter");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        args.push_back(InjectionArgument(counter));
        preparedValues.push_back(InjectionArgument(rxcounter));
        preparedValues.push_back(InjectionArgument(txcounter));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkUtilizationCounter", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkUtilizationCounter", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceFreezeNvLinkUtilizationCounter(nvmlDevice_t device,
                                                      unsigned int link,
                                                      unsigned int counter,
                                                      nvmlEnableState_t freeze)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceFreezeNvLinkUtilizationCounter");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        args.push_back(InjectionArgument(counter));
        args.push_back(InjectionArgument(freeze));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkUtilizationCounter", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkUtilizationCounter", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetNvLinkUtilizationCounter(nvmlDevice_t device, unsigned int link, unsigned int counter)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceResetNvLinkUtilizationCounter");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(link));
        args.push_back(InjectionArgument(counter));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NvLinkUtilizationCounter", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NvLinkUtilizationCounter", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t *pVirtualMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetVirtualizationMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pVirtualMode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VirtualizationMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VirtualizationMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t virtualMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetVirtualizationMode");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(virtualMode);
        return injectedNvml->DeviceSet(device, "VirtualizationMode", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedVgpus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(vgpuCount));
        preparedValues.push_back(InjectionArgument(vgpuTypeIds));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedVgpus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedVgpus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCreatableVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCreatableVgpus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(vgpuCount));
        preparedValues.push_back(InjectionArgument(vgpuTypeIds));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "CreatableVgpus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "CreatableVgpus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetClass(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeClass, unsigned int *size)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetClass");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(vgpuTypeId);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "Class");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(vgpuTypeClass, *size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetName(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeName, unsigned int *size)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetName");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(vgpuTypeId);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "Name");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(vgpuTypeName, *size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetGpuInstanceProfileId(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *gpuInstanceProfileId)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetGpuInstanceProfileId");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        preparedValues.push_back(InjectionArgument(gpuInstanceProfileId));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceProfileId", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceProfileId", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetDeviceID(nvmlVgpuTypeId_t vgpuTypeId,
                                     unsigned long long *deviceID,
                                     unsigned long long *subsystemID)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetDeviceID");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        preparedValues.push_back(InjectionArgument(deviceID));
        preparedValues.push_back(InjectionArgument(subsystemID));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DeviceID", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DeviceID", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetFramebufferSize(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *fbSize)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetFramebufferSize");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        preparedValues.push_back(InjectionArgument(fbSize));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FramebufferSize", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FramebufferSize", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetNumDisplayHeads(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *numDisplayHeads)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetNumDisplayHeads");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        preparedValues.push_back(InjectionArgument(numDisplayHeads));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NumDisplayHeads", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NumDisplayHeads", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetResolution(nvmlVgpuTypeId_t vgpuTypeId,
                                       unsigned int displayIndex,
                                       unsigned int *xdim,
                                       unsigned int *ydim)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetResolution");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        args.push_back(InjectionArgument(displayIndex));
        preparedValues.push_back(InjectionArgument(xdim));
        preparedValues.push_back(InjectionArgument(ydim));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Resolution", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Resolution", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetLicense(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetLicense");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(vgpuTypeId);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "License");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(vgpuTypeLicenseString, size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetFrameRateLimit(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *frameRateLimit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetFrameRateLimit");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        preparedValues.push_back(InjectionArgument(frameRateLimit));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FrameRateLimit", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FrameRateLimit", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetMaxInstances(nvmlDevice_t device,
                                         nvmlVgpuTypeId_t vgpuTypeId,
                                         unsigned int *vgpuInstanceCount)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetMaxInstances");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(vgpuTypeId));
        preparedValues.push_back(InjectionArgument(vgpuInstanceCount));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MaxInstances", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MaxInstances", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetMaxInstancesPerVm(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCountPerVm)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetMaxInstancesPerVm");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        preparedValues.push_back(InjectionArgument(vgpuInstanceCountPerVm));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MaxInstancesPerVm", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MaxInstancesPerVm", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetActiveVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuInstance_t *vgpuInstances)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetActiveVgpus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(vgpuCount));
        preparedValues.push_back(InjectionArgument(vgpuInstances));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ActiveVgpus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ActiveVgpus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetVmID(nvmlVgpuInstance_t vgpuInstance,
                                     char *vmId,
                                     unsigned int size,
                                     nvmlVgpuVmIdType_t *vmIdType)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetVmID");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(vmId));
        args.push_back(InjectionArgument(size));
        preparedValues.push_back(InjectionArgument(vmIdType));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VmID", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VmID", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetUUID(nvmlVgpuInstance_t vgpuInstance, char *uuid, unsigned int size)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetUUID");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(vgpuInstance);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "UUID");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(uuid, size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetMdevUUID(nvmlVgpuInstance_t vgpuInstance, char *mdevUuid, unsigned int size)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetMdevUUID");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(vgpuInstance);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "MdevUUID");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(mdevUuid, size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetVmDriverVersion(nvmlVgpuInstance_t vgpuInstance, char *version, unsigned int length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetVmDriverVersion");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(vgpuInstance);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "VmDriverVersion");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(version, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFbUsage(nvmlVgpuInstance_t vgpuInstance, unsigned long long *fbUsage)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetFbUsage");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(fbUsage));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FbUsage", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FbUsage", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetLicenseStatus(nvmlVgpuInstance_t vgpuInstance, unsigned int *licensed)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetLicenseStatus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(licensed));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "LicenseStatus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "LicenseStatus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetLicenseInfo(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetLicenseInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(licenseInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "LicenseInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "LicenseInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetLicenseInfo_v2(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetLicenseInfo_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(licenseInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "LicenseInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "LicenseInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetType(nvmlVgpuInstance_t vgpuInstance, unsigned int *vgpuTypeId)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetType");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(vgpuTypeId));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Type", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Type", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFrameRateLimit(nvmlVgpuInstance_t vgpuInstance, unsigned int *frameRateLimit)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetFrameRateLimit");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(frameRateLimit));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FrameRateLimit", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FrameRateLimit", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEccMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *eccMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetEccMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(eccMode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EccMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EccMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int *encoderCapacity)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetEncoderCapacity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(encoderCapacity));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderCapacity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderCapacity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceSetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int encoderCapacity)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceSetEncoderCapacity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(encoderCapacity));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderCapacity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderCapacity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVgpuUtilization(nvmlDevice_t device,
                                          unsigned long long lastSeenTimeStamp,
                                          nvmlValueType_t *sampleValType,
                                          unsigned int *vgpuInstanceSamplesCount,
                                          nvmlVgpuInstanceUtilizationSample_t *utilizationSamples)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetVgpuUtilization");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(lastSeenTimeStamp));
        preparedValues.push_back(InjectionArgument(sampleValType));
        preparedValues.push_back(InjectionArgument(vgpuInstanceSamplesCount));
        preparedValues.push_back(InjectionArgument(utilizationSamples));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VgpuUtilization", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VgpuUtilization", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetMetadata(nvmlVgpuInstance_t vgpuInstance,
                                         nvmlVgpuMetadata_t *vgpuMetadata,
                                         unsigned int *bufferSize)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetMetadata");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(vgpuMetadata));
        preparedValues.push_back(InjectionArgument(bufferSize));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Metadata", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Metadata", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetGpuPciId(nvmlVgpuInstance_t vgpuInstance, char *vgpuPciId, unsigned int *length)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetGpuPciId");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(vgpuInstance);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "GpuPciId");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(vgpuPciId, *length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetCapabilities(nvmlVgpuTypeId_t vgpuTypeId,
                                         nvmlVgpuCapability_t capability,
                                         unsigned int *capResult)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuTypeGetCapabilities");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuTypeId));
        args.push_back(InjectionArgument(capability));
        preparedValues.push_back(InjectionArgument(capResult));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Capabilities", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Capabilities", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGspFirmwareVersion(nvmlDevice_t device, char *version)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGspFirmwareVersion");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(version));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GspFirmwareVersion", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GspFirmwareVersion", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGspFirmwareMode(nvmlDevice_t device, unsigned int *isEnabled, unsigned int *defaultMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGspFirmwareMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(isEnabled));
        preparedValues.push_back(InjectionArgument(defaultMode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GspFirmwareMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GspFirmwareMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetGpuInstanceId(nvmlVgpuInstance_t vgpuInstance, unsigned int *gpuInstanceId)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetGpuInstanceId");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(gpuInstanceId));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceId", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceId", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVgpuMetadata(nvmlDevice_t device,
                                       nvmlVgpuPgpuMetadata_t *pgpuMetadata,
                                       unsigned int *bufferSize)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetVgpuMetadata");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pgpuMetadata));
        preparedValues.push_back(InjectionArgument(bufferSize));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VgpuMetadata", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VgpuMetadata", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetVgpuCompatibility(nvmlVgpuMetadata_t *vgpuMetadata,
                                      nvmlVgpuPgpuMetadata_t *pgpuMetadata,
                                      nvmlVgpuPgpuCompatibility_t *compatibilityInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGetVgpuCompatibility");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(vgpuMetadata));
        preparedValues.push_back(InjectionArgument(pgpuMetadata));
        preparedValues.push_back(InjectionArgument(compatibilityInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VgpuCompatibility", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VgpuCompatibility", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPgpuMetadataString(nvmlDevice_t device, char *pgpuMetadata, unsigned int *bufferSize)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPgpuMetadataString");
        // The following snippet is generated from check_and_write_get_string_body
        InjectionArgument arg(device);
        auto [tmpNvmlRet, buf] = injectedNvml->GetString(arg, "PgpuMetadataString");
        if (tmpNvmlRet != NVML_SUCCESS)
        {
            return tmpNvmlRet;
        }
        snprintf(pgpuMetadata, *bufferSize, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures(nvmlDevice_t device,
                                                 nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGridLicensableFeatures");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pGridLicensableFeatures));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures_v2(nvmlDevice_t device,
                                                    nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGridLicensableFeatures_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pGridLicensableFeatures));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures_v3(nvmlDevice_t device,
                                                    nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGridLicensableFeatures_v3");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pGridLicensableFeatures));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures_v4(nvmlDevice_t device,
                                                    nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGridLicensableFeatures_v4");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pGridLicensableFeatures));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GridLicensableFeatures", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderCapacity(nvmlDevice_t device,
                                          nvmlEncoderType_t encoderQueryType,
                                          unsigned int *pEncoderCapacity)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetEncoderCapacity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(encoderQueryType));
        preparedValues.push_back(InjectionArgument(pEncoderCapacity));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderCapacity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderCapacity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderStats(nvmlDevice_t device,
                                       unsigned int *sessionCount,
                                       unsigned int *averageFps,
                                       unsigned int *averageLatency)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetEncoderStats");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(sessionCount));
        preparedValues.push_back(InjectionArgument(averageFps));
        preparedValues.push_back(InjectionArgument(averageLatency));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderStats", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderStats", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderSessions(nvmlDevice_t device,
                                          unsigned int *sessionCount,
                                          nvmlEncoderSessionInfo_t *sessionInfos)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetEncoderSessions");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(sessionCount));
        preparedValues.push_back(InjectionArgument(sessionInfos));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderSessions", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderSessions", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFBCStats(nvmlDevice_t device, nvmlFBCStats_t *fbcStats)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetFBCStats");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(fbcStats));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FBCStats", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FBCStats", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFBCSessions(nvmlDevice_t device,
                                      unsigned int *sessionCount,
                                      nvmlFBCSessionInfo_t *sessionInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetFBCSessions");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(sessionCount));
        preparedValues.push_back(InjectionArgument(sessionInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FBCSessions", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FBCSessions", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceModifyDrainState(nvmlPciInfo_t *pciInfo, nvmlEnableState_t newState)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceModifyDrainState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(pciInfo));
        args.push_back(InjectionArgument(newState));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DrainState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DrainState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceQueryDrainState(nvmlPciInfo_t *pciInfo, nvmlEnableState_t *newState)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceQueryDrainState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(pciInfo));
        preparedValues.push_back(InjectionArgument(newState));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DrainState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DrainState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceRemoveGpu(nvmlPciInfo_t *pciInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceRemoveGpu");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(pciInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RemoveGpu", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RemoveGpu", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceRemoveGpu_v2(nvmlPciInfo_t *pciInfo,
                                    nvmlDetachGpuState_t gpuState,
                                    nvmlPcieLinkState_t linkState)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceRemoveGpu_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(pciInfo));
        args.push_back(InjectionArgument(gpuState));
        args.push_back(InjectionArgument(linkState));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RemoveGpu", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RemoveGpu", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceDiscoverGpus(nvmlPciInfo_t *pciInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceDiscoverGpus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(pciInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DiscoverGpus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DiscoverGpus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFieldValues(nvmlDevice_t device, int valuesCount, nvmlFieldValue_t *values)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetFieldValues");
        // The following snippet is generated from generate_getter_functions
        if (values == nullptr)
        {
            return NVML_ERROR_INVALID_ARGUMENT;
        }

        injectedNvml->GetFieldValues(device, valuesCount, values);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVgpuProcessUtilization(nvmlDevice_t device,
                                                 unsigned long long lastSeenTimeStamp,
                                                 unsigned int *vgpuProcessSamplesCount,
                                                 nvmlVgpuProcessUtilizationSample_t *utilizationSamples)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetVgpuProcessUtilization");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(lastSeenTimeStamp));
        preparedValues.push_back(InjectionArgument(vgpuProcessSamplesCount));
        preparedValues.push_back(InjectionArgument(utilizationSamples));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VgpuProcessUtilization", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VgpuProcessUtilization", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEncoderStats(nvmlVgpuInstance_t vgpuInstance,
                                             unsigned int *sessionCount,
                                             unsigned int *averageFps,
                                             unsigned int *averageLatency)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetEncoderStats");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(sessionCount));
        preparedValues.push_back(InjectionArgument(averageFps));
        preparedValues.push_back(InjectionArgument(averageLatency));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderStats", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderStats", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEncoderSessions(nvmlVgpuInstance_t vgpuInstance,
                                                unsigned int *sessionCount,
                                                nvmlEncoderSessionInfo_t *sessionInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetEncoderSessions");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(sessionCount));
        preparedValues.push_back(InjectionArgument(sessionInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "EncoderSessions", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "EncoderSessions", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFBCStats(nvmlVgpuInstance_t vgpuInstance, nvmlFBCStats_t *fbcStats)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetFBCStats");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(fbcStats));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FBCStats", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FBCStats", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFBCSessions(nvmlVgpuInstance_t vgpuInstance,
                                            unsigned int *sessionCount,
                                            nvmlFBCSessionInfo_t *sessionInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetFBCSessions");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(sessionCount));
        preparedValues.push_back(InjectionArgument(sessionInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "FBCSessions", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "FBCSessions", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetProcessUtilization(nvmlDevice_t device,
                                             nvmlProcessUtilizationSample_t *utilization,
                                             unsigned int *processSamplesCount,
                                             unsigned long long lastSeenTimeStamp)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetProcessUtilization");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(utilization));
        preparedValues.push_back(InjectionArgument(processSamplesCount));
        args.push_back(InjectionArgument(lastSeenTimeStamp));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ProcessUtilization", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ProcessUtilization", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetAccountingMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *mode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetAccountingMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(mode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetAccountingPids(nvmlVgpuInstance_t vgpuInstance, unsigned int *count, unsigned int *pids)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetAccountingPids");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        preparedValues.push_back(InjectionArgument(count));
        preparedValues.push_back(InjectionArgument(pids));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingPids", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingPids", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetAccountingStats(nvmlVgpuInstance_t vgpuInstance,
                                                unsigned int pid,
                                                nvmlAccountingStats_t *stats)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceGetAccountingStats");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(pid));
        preparedValues.push_back(InjectionArgument(stats));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AccountingStats", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AccountingStats", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceClearAccountingPids(nvmlVgpuInstance_t vgpuInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlVgpuInstanceClearAccountingPids");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(vgpuInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetExcludedDeviceCount(unsigned int *deviceCount)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGetExcludedDeviceCount");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(deviceCount);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("ExcludedDeviceCount"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetExcludedDeviceInfoByIndex(unsigned int index, nvmlExcludedDeviceInfo_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGetExcludedDeviceInfoByIndex");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(index));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ExcludedDeviceInfoByIndex", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ExcludedDeviceInfoByIndex", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetVgpuVersion(nvmlVgpuVersion_t *supported, nvmlVgpuVersion_t *current)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGetVgpuVersion");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(supported));
        preparedValues.push_back(InjectionArgument(current));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VgpuVersion", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VgpuVersion", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSetVgpuVersion(nvmlVgpuVersion_t *vgpuVersion)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSetVgpuVersion");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(vgpuVersion));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "VgpuVersion", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "VgpuVersion", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHostVgpuMode(nvmlDevice_t device, nvmlHostVgpuMode_t *pHostVgpuMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetHostVgpuMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pHostVgpuMode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "HostVgpuMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "HostVgpuMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetMigMode(nvmlDevice_t device, unsigned int mode, nvmlReturn_t *activationStatus)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetMigMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(mode));
        preparedValues.push_back(InjectionArgument(activationStatus));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MigMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MigMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMigMode(nvmlDevice_t device, unsigned int *currentMode, unsigned int *pendingMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMigMode");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(currentMode));
        preparedValues.push_back(InjectionArgument(pendingMode));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MigMode", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MigMode", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceProfileInfo(nvmlDevice_t device,
                                                 unsigned int profile,
                                                 nvmlGpuInstanceProfileInfo_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstanceProfileInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profile));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceProfileInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceProfileInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceProfileInfoV(nvmlDevice_t device,
                                                  unsigned int profile,
                                                  nvmlGpuInstanceProfileInfo_v2_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstanceProfileInfoV");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profile));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceProfileInfoV", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceProfileInfoV", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceRemainingCapacity(nvmlDevice_t device, unsigned int profileId, unsigned int *count)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstanceRemainingCapacity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(count));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceRemainingCapacity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceRemainingCapacity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstancePossiblePlacements(nvmlDevice_t device,
                                                        unsigned int profileId,
                                                        nvmlGpuInstancePlacement_t *placements,
                                                        unsigned int *count)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstancePossiblePlacements");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(placements));
        preparedValues.push_back(InjectionArgument(count));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstancePossiblePlacements", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstancePossiblePlacements", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstancePossiblePlacements_v2(nvmlDevice_t device,
                                                           unsigned int profileId,
                                                           nvmlGpuInstancePlacement_t *placements,
                                                           unsigned int *count)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstancePossiblePlacements_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(placements));
        preparedValues.push_back(InjectionArgument(count));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstancePossiblePlacements", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstancePossiblePlacements", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceCreateGpuInstance(nvmlDevice_t device, unsigned int profileId, nvmlGpuInstance_t *gpuInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceCreateGpuInstance");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(gpuInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstance", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstance", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceCreateGpuInstanceWithPlacement(nvmlDevice_t device,
                                                      unsigned int profileId,
                                                      const nvmlGpuInstancePlacement_t *placement,
                                                      nvmlGpuInstance_t *gpuInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceCreateGpuInstanceWithPlacement");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(placement));
        preparedValues.push_back(InjectionArgument(gpuInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceWithPlacement", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceWithPlacement", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceDestroy(nvmlGpuInstance_t gpuInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceDestroy");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstances(nvmlDevice_t device,
                                       unsigned int profileId,
                                       nvmlGpuInstance_t *instances,
                                       unsigned int *count)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstances");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(instances));
        preparedValues.push_back(InjectionArgument(count));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstances", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstances", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetInfo(nvmlGpuInstance_t gpuInstance, nvmlGpuInstanceInfo_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceGetInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Info", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Info", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceById(nvmlDevice_t device, unsigned int id, nvmlGpuInstance_t *gpuInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstanceById");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(id));
        preparedValues.push_back(InjectionArgument(gpuInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceById", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceById", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceProfileInfo(nvmlGpuInstance_t gpuInstance,
                                                          unsigned int profile,
                                                          unsigned int engProfile,
                                                          nvmlComputeInstanceProfileInfo_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceGetComputeInstanceProfileInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profile));
        args.push_back(InjectionArgument(engProfile));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeInstanceProfileInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeInstanceProfileInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceProfileInfoV(nvmlGpuInstance_t gpuInstance,
                                                           unsigned int profile,
                                                           unsigned int engProfile,
                                                           nvmlComputeInstanceProfileInfo_v2_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceGetComputeInstanceProfileInfoV");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profile));
        args.push_back(InjectionArgument(engProfile));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeInstanceProfileInfoV", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeInstanceProfileInfoV", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceRemainingCapacity(nvmlGpuInstance_t gpuInstance,
                                                                unsigned int profileId,
                                                                unsigned int *count)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceGetComputeInstanceRemainingCapacity");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(count));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeInstanceRemainingCapacity", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeInstanceRemainingCapacity", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceCreateComputeInstance(nvmlGpuInstance_t gpuInstance,
                                                  unsigned int profileId,
                                                  nvmlComputeInstance_t *computeInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceCreateComputeInstance");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(computeInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlComputeInstanceDestroy(nvmlComputeInstance_t computeInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlComputeInstanceDestroy");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(computeInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "None", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "None", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstances(nvmlGpuInstance_t gpuInstance,
                                                unsigned int profileId,
                                                nvmlComputeInstance_t *computeInstances,
                                                unsigned int *count)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceGetComputeInstances");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profileId));
        preparedValues.push_back(InjectionArgument(computeInstances));
        preparedValues.push_back(InjectionArgument(count));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeInstances", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeInstances", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceById(nvmlGpuInstance_t gpuInstance,
                                                   unsigned int id,
                                                   nvmlComputeInstance_t *computeInstance)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpuInstanceGetComputeInstanceById");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(id));
        preparedValues.push_back(InjectionArgument(computeInstance));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeInstanceById", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeInstanceById", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlComputeInstanceGetInfo(nvmlComputeInstance_t computeInstance, nvmlComputeInstanceInfo_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlComputeInstanceGetInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(computeInstance));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Info", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Info", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlComputeInstanceGetInfo_v2(nvmlComputeInstance_t computeInstance, nvmlComputeInstanceInfo_t *info)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlComputeInstanceGetInfo_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(computeInstance));
        preparedValues.push_back(InjectionArgument(info));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Info", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Info", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceIsMigDeviceHandle(nvmlDevice_t device, unsigned int *isMigDevice)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceIsMigDeviceHandle");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(isMigDevice));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MigDeviceHandle", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MigDeviceHandle", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceId(nvmlDevice_t device, unsigned int *id)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuInstanceId");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(id));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuInstanceId", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuInstanceId", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeInstanceId(nvmlDevice_t device, unsigned int *id)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetComputeInstanceId");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(id));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ComputeInstanceId", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ComputeInstanceId", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxMigDeviceCount(nvmlDevice_t device, unsigned int *migDeviceCount)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMaxMigDeviceCount");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(migDeviceCount));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MaxMigDeviceCount", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MaxMigDeviceCount", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMigDeviceHandleByIndex(nvmlDevice_t device, unsigned int index, nvmlDevice_t *migDevice)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMigDeviceHandleByIndex");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(index));
        preparedValues.push_back(InjectionArgument(migDevice));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MigDeviceHandleByIndex", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MigDeviceHandleByIndex", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetConfComputeState(nvmlConfComputeSystemState_t *ccMode)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlSystemGetConfComputeState");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(ccMode);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("ConfComputeState"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDeviceHandleFromMigDeviceHandle(nvmlDevice_t migDevice, nvmlDevice_t *device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDeviceHandleFromMigDeviceHandle");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument identifier(migDevice);
        *device = injectedNvml->GetNvmlDevice(identifier, "DeviceHandleFromMigDeviceHandle");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAttributes(nvmlDevice_t device, nvmlDeviceAttributes_t *attributes)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAttributes");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(attributes));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Attributes", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Attributes", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAttributes_v2(nvmlDevice_t device, nvmlDeviceAttributes_t *attributes)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAttributes_v2");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(attributes));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Attributes", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Attributes", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRemappedRows(nvmlDevice_t device,
                                       unsigned int *corrRows,
                                       unsigned int *uncRows,
                                       unsigned int *isPending,
                                       unsigned int *failureOccurred)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetRemappedRows");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(corrRows));
        preparedValues.push_back(InjectionArgument(uncRows));
        preparedValues.push_back(InjectionArgument(isPending));
        preparedValues.push_back(InjectionArgument(failureOccurred));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RemappedRows", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RemappedRows", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRowRemapperHistogram(nvmlDevice_t device, nvmlRowRemapperHistogramValues_t *values)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetRowRemapperHistogram");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(values));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "RowRemapperHistogram", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "RowRemapperHistogram", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBusType(nvmlDevice_t device, nvmlBusType_t *type)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetBusType");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(type));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "BusType", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "BusType", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetIrqNum(nvmlDevice_t device, unsigned int *irqNum)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetIrqNum");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(irqNum));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "IrqNum", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "IrqNum", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNumGpuCores(nvmlDevice_t device, unsigned int *numCores)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetNumGpuCores");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(numCores));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "NumGpuCores", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "NumGpuCores", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerSource(nvmlDevice_t device, nvmlPowerSource_t *powerSource)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPowerSource");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(powerSource));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PowerSource", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PowerSource", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryBusWidth(nvmlDevice_t device, unsigned int *busWidth)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMemoryBusWidth");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(busWidth));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemoryBusWidth", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemoryBusWidth", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieLinkMaxSpeed(nvmlDevice_t device, unsigned int *maxSpeed)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPcieLinkMaxSpeed");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(maxSpeed));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PcieLinkMaxSpeed", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PcieLinkMaxSpeed", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAdaptiveClockInfoStatus(nvmlDevice_t device, unsigned int *adaptiveClockStatus)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetAdaptiveClockInfoStatus");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(adaptiveClockStatus));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "AdaptiveClockInfoStatus", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "AdaptiveClockInfoStatus", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieSpeed(nvmlDevice_t device, unsigned int *pcieSpeed)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPcieSpeed");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pcieSpeed));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PcieSpeed", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PcieSpeed", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDynamicPstatesInfo(nvmlDevice_t device, nvmlGpuDynamicPstatesInfo_t *pDynamicPstatesInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetDynamicPstatesInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pDynamicPstatesInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "DynamicPstatesInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "DynamicPstatesInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetFanSpeed_v2(nvmlDevice_t device, unsigned int fan, unsigned int speed)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetFanSpeed_v2");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument extraKey(fan);
        InjectionArgument value(speed);
        return injectedNvml->DeviceSet(device, "FanSpeed", {extraKey}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetDefaultFanSpeed_v2(nvmlDevice_t device, unsigned int fan)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetDefaultFanSpeed_v2");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(fan);
        return injectedNvml->DeviceSet(device, "DefaultFanSpeed", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetThermalSettings(nvmlDevice_t device,
                                          unsigned int sensorIndex,
                                          nvmlGpuThermalSettings_t *pThermalSettings)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetThermalSettings");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(sensorIndex));
        preparedValues.push_back(InjectionArgument(pThermalSettings));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "ThermalSettings", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "ThermalSettings", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMinMaxClockOfPState(nvmlDevice_t device,
                                              nvmlClockType_t type,
                                              nvmlPstates_t pstate,
                                              unsigned int *minClockMHz,
                                              unsigned int *maxClockMHz)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMinMaxClockOfPState");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(type));
        args.push_back(InjectionArgument(pstate));
        preparedValues.push_back(InjectionArgument(minClockMHz));
        preparedValues.push_back(InjectionArgument(maxClockMHz));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MinMaxClockOfPState", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MinMaxClockOfPState", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedPerformanceStates(nvmlDevice_t device, nvmlPstates_t *pstates, unsigned int size)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetSupportedPerformanceStates");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(pstates));
        args.push_back(InjectionArgument(size));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SupportedPerformanceStates", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SupportedPerformanceStates", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpcClkVfOffset(nvmlDevice_t device, int *offset)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpcClkVfOffset");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(offset));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpcClkVfOffset", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpcClkVfOffset", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetGpcClkVfOffset(nvmlDevice_t device, int offset)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetGpcClkVfOffset");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(offset);
        return injectedNvml->DeviceSet(device, "GpcClkVfOffset", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemClkVfOffset(nvmlDevice_t device, int *offset)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMemClkVfOffset");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(offset));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemClkVfOffset", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemClkVfOffset", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetMemClkVfOffset(nvmlDevice_t device, int offset)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceSetMemClkVfOffset");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(offset);
        return injectedNvml->DeviceSet(device, "MemClkVfOffset", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMinMaxFanSpeed(nvmlDevice_t device, unsigned int *min, unsigned int *max)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMinMaxFanSpeed");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(min));
        preparedValues.push_back(InjectionArgument(max));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MinMaxFanSpeed", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MinMaxFanSpeed", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpcClkMinMaxVfOffset(nvmlDevice_t device, int *minOffset, int *maxOffset)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpcClkMinMaxVfOffset");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(minOffset));
        preparedValues.push_back(InjectionArgument(maxOffset));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpcClkMinMaxVfOffset", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpcClkMinMaxVfOffset", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemClkMinMaxVfOffset(nvmlDevice_t device, int *minOffset, int *maxOffset)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetMemClkMinMaxVfOffset");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(minOffset));
        preparedValues.push_back(InjectionArgument(maxOffset));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MemClkMinMaxVfOffset", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MemClkMinMaxVfOffset", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmMetricsGet(nvmlGpmMetricsGet_t *metricsGet)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpmMetricsGet");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(metricsGet);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("Metrics"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmSampleAlloc(nvmlGpmSample_t *gpmSample)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpmSampleAlloc");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        preparedValues.push_back(InjectionArgument(gpmSample));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SampleAlloc", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SampleAlloc", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmSampleFree(nvmlGpmSample_t gpmSample)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpmSampleFree");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(gpmSample));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "SampleFree", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "SampleFree", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmSampleGet(nvmlDevice_t device, nvmlGpmSample_t gpmSample)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpmSampleGet");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(gpmSample));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Sample", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Sample", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmMigSampleGet(nvmlDevice_t device, unsigned int gpuInstanceId, nvmlGpmSample_t gpmSample)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpmMigSampleGet");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        args.push_back(InjectionArgument(gpuInstanceId));
        args.push_back(InjectionArgument(gpmSample));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "MigSample", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "MigSample", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmQueryDeviceSupport(nvmlDevice_t device, nvmlGpmSupport_t *gpmSupport)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlGpmQueryDeviceSupport");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(gpmSupport));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "QueryDeviceSupport", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "QueryDeviceSupport", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuFabricInfo(nvmlDevice_t device, nvmlGpuFabricInfo_t *gpuFabricInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuFabricInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(gpuFabricInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuFabricInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuFabricInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuFabricInfoV(nvmlDevice_t device, nvmlGpuFabricInfoV_t *gpuFabricInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetGpuFabricInfoV");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(gpuFabricInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "GpuFabricInfoV", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "GpuFabricInfoV", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCount_v2(unsigned int *deviceCount)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetCount_v2");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument arg(deviceCount);
        arg.SetValueFrom(injectedNvml->ObjectlessGet("Count"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByIndex_v2(unsigned int index, nvmlDevice_t *device)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetHandleByIndex_v2");
        // The following snippet is generated from generate_getter_functions
        InjectionArgument identifier(index);
        *device = injectedNvml->GetNvmlDevice(identifier, "Index");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetArchitecture(nvmlDevice_t device, nvmlDeviceArchitecture_t *arch)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetArchitecture");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(arch));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "Architecture", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "Architecture", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceWorkloadPowerProfileGetProfilesInfo(nvmlDevice_t device,
                                                           nvmlWorkloadPowerProfileProfilesInfo_t *profilesInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceWorkloadPowerProfileGetProfilesInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(profilesInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "WorkloadPowerProfileGetProfilesInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "WorkloadPowerProfileGetProfilesInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceWorkloadPowerProfileGetCurrentProfiles(nvmlDevice_t device,
                                                              nvmlWorkloadPowerProfileCurrentProfiles_t *currentProfiles)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceWorkloadPowerProfileGetCurrentProfiles");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(currentProfiles));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "WorkloadPowerProfileGetCurrentProfiles", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "WorkloadPowerProfileGetCurrentProfiles", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceWorkloadPowerProfileSetRequestedProfiles(nvmlDevice_t device,
                                                                nvmlWorkloadPowerProfileRequestedProfiles_t *requestedProfiles)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceWorkloadPowerProfileSetRequestedProfiles");
        // The following snippet is generated from generate_setter_functions
        InjectionArgument value(requestedProfiles);
        return injectedNvml->DeviceSet(device, "WorkloadPowerProfileSetRequestedProfiles", {}, NvmlFuncReturn(NVML_SUCCESS, value));
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceWorkloadPowerProfileClearRequestedProfiles(nvmlDevice_t device,
                                                                  nvmlWorkloadPowerProfileRequestedProfiles_t *requestedProfiles)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceWorkloadPowerProfileClearRequestedProfiles");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(requestedProfiles));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "WorkloadPowerProfileClearRequestedProfiles", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "WorkloadPowerProfileClearRequestedProfiles", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPlatformInfo(nvmlDevice_t device, nvmlPlatformInfo_t *platformInfo)
{
    // The following snippet is generated from write_function
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        // The following snippet is generated from write_function
        auto *injectedNvml = InjectedNvml::GetInstance();
        if (!injectedNvml)
        {
            return NVML_ERROR_UNINITIALIZED;
        }
        injectedNvml->AddFuncCallCount("nvmlDeviceGetPlatformInfo");
        // The following snippet is generated from write_function
        std::vector<InjectionArgument> args;
        std::vector<InjectionArgument> preparedValues;
        args.push_back(InjectionArgument(device));
        preparedValues.push_back(InjectionArgument(platformInfo));

        if (injectedNvml->IsGetter(__func__))
        {
            return injectedNvml->GetWrapper(__func__, "PlatformInfo", args, preparedValues);
        }
        else
        {
            return injectedNvml->SetWrapper(__func__, "PlatformInfo", args, preparedValues);
        }
    }
    return NVML_SUCCESS;
}

#ifdef __cplusplus
}
#endif

#pragma GCC diagnostic pop

// END nvml_generated_stubs