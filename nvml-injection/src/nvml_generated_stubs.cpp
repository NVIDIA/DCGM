/*
 * NOTE: This code is auto-generated by generate_nvml_stubs.py
 * DO NOT EDIT MANUALLY
 */


#include "InjectedNvml.h"
#include "nvml.h"
#include "nvml_generated_declarations.h"

#include "PassThruNvml.h"

#ifdef __cplusplus
extern "C" {
#endif

bool GLOBAL_PASS_THROUGH_MODE = false;

nvmlReturn_t nvmlDeviceGetClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        *clock            = InjectedNvml->GetClockInfo(device, "ClockInfo", type);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxClockInfo(nvmlDevice_t device, nvmlClockType_t type, unsigned int *clock)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        *clock            = InjectedNvml->GetClockInfo(device, "MaxClockInfo", type);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeMode(nvmlDevice_t device, nvmlComputeMode_t *mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "ComputeMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetComputeMode(nvmlDevice_t device, nvmlComputeMode_t mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        InjectedNvml->SimpleDeviceSet(device, "ComputeMode", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCudaComputeCapability(nvmlDevice_t device, int *major, int *minor)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(major));
        values.push_back(InjectionArgument(minor));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "CudaComputeCapability", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetDriverModel(nvmlDevice_t device, nvmlDriverModel_t driverModel, unsigned int flags)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "DriverModel", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "DriverModel", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDriverModel(nvmlDevice_t device, nvmlDriverModel_t *current, nvmlDriverModel_t *pending)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(current));
        values.push_back(InjectionArgument(pending));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "DriverModel", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCount(unsigned int *deviceCount)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(deviceCount);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("Count"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByIndex(unsigned int index, nvmlDevice_t *device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument identifier(index);
        *device = InjectedNvml->GetNvmlDevice(identifier, "Index");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleBySerial(const char *serial, nvmlDevice_t *device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument identifier(serial);
        *device = InjectedNvml->GetNvmlDevice(identifier, "Serial");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByUUID(const char *uuid, nvmlDevice_t *device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument identifier(uuid);
        *device = InjectedNvml->GetNvmlDevice(identifier, "UUID");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByPciBusId(const char *pciBusId, nvmlDevice_t *device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument identifier(pciBusId);
        *device = InjectedNvml->GetNvmlDevice(identifier, "PciBusId");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByPciBusId_v2(const char *pciBusId, nvmlDevice_t *device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument identifier(pciBusId);
        *device = InjectedNvml->GetNvmlDevice(identifier, "PciBusId");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetInforomVersion(nvmlDevice_t device,
                                         nvmlInforomObject_t object,
                                         char *version,
                                         unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "InforomVersion", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "InforomVersion", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetInforomImageVersion(nvmlDevice_t device, char *version, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(device);
        std::string buf = InjectedNvml->GetString(arg, "InforomImageVersion");
        snprintf(version, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDisplayMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "DisplayMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEccMode(nvmlDevice_t device, nvmlEnableState_t *current, nvmlEnableState_t *pending)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(current));
        values.push_back(InjectionArgument(pending));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "EccMode", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDefaultEccMode(nvmlDevice_t device, nvmlEnableState_t *defaultMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(defaultMode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "DefaultEccMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBoardId(nvmlDevice_t device, unsigned int *boardId)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(boardId);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "BoardId"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMultiGpuBoard(nvmlDevice_t device, unsigned int *multiGpuBool)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(multiGpuBool);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MultiGpuBoard"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDetailedEccErrors(nvmlDevice_t device,
                                            nvmlMemoryErrorType_t errorType,
                                            nvmlEccCounterType_t counterType,
                                            nvmlEccErrorCounts_t *eccCounts)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "DetailedEccErrors", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "DetailedEccErrors", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTotalEccErrors(nvmlDevice_t device,
                                         nvmlMemoryErrorType_t errorType,
                                         nvmlEccCounterType_t counterType,
                                         unsigned long long *eccCounts)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "TotalEccErrors", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "TotalEccErrors", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetEccMode(nvmlDevice_t device, nvmlEnableState_t ecc)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(ecc);
        InjectedNvml->SimpleDeviceSet(device, "EccMode", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceClearEccErrorCounts(nvmlDevice_t device, nvmlEccCounterType_t counterType)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "EccErrorCounts", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "EccErrorCounts", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetName(nvmlDevice_t device, char *name, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(device);
        std::string buf = InjectedNvml->GetString(arg, "Name");
        snprintf(name, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBrand(nvmlDevice_t device, nvmlBrandType_t *type)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(type);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "Brand"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSerial(nvmlDevice_t device, char *serial, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(device);
        std::string buf = InjectedNvml->GetString(arg, "Serial");
        snprintf(serial, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBoardPartNumber(nvmlDevice_t device, char *partNumber, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(device);
        std::string buf = InjectedNvml->GetString(arg, "BoardPartNumber");
        snprintf(partNumber, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryAffinity(nvmlDevice_t device,
                                         unsigned int nodeSetSize,
                                         unsigned long *nodeSet,
                                         nvmlAffinityScope_t scope)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "MemoryAffinity", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "MemoryAffinity", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCpuAffinityWithinScope(nvmlDevice_t device,
                                                 unsigned int cpuSetSize,
                                                 unsigned long *cpuSet,
                                                 nvmlAffinityScope_t scope)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "CpuAffinityWithinScope", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "CpuAffinityWithinScope", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCpuAffinity(nvmlDevice_t device, unsigned int cpuSetSize, unsigned long *cpuSet)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(cpuSet);
        InjectionArgument arg(cpuSetSize);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "CpuAffinity", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetCpuAffinity(nvmlDevice_t device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "CpuAffinity", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "CpuAffinity", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceClearCpuAffinity(nvmlDevice_t device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "CpuAffinity", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "CpuAffinity", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetUUID(nvmlDevice_t device, char *uuid, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(device);
        std::string buf = InjectedNvml->GetString(arg, "UUID");
        snprintf(uuid, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryInfo(nvmlDevice_t device, nvmlMemory_t *memory)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(memory);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MemoryInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryInfo_v2(nvmlDevice_t device, nvmlMemory_v2_t *memory)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(memory);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MemoryInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPciInfo(nvmlDevice_t device, nvmlPciInfo_t *pci)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pci);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PciInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPciInfo_v2(nvmlDevice_t device, nvmlPciInfo_t *pci)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pci);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PciInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPciInfo_v3(nvmlDevice_t device, nvmlPciInfo_t *pci)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pci);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PciInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PersistenceMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetPersistenceMode(nvmlDevice_t device, nvmlEnableState_t mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        InjectedNvml->SimpleDeviceSet(device, "PersistenceMode", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBAR1MemoryInfo(nvmlDevice_t device, nvmlBAR1Memory_t *bar1Memory)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(bar1Memory);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "BAR1MemoryInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetViolationStatus(nvmlDevice_t device,
                                          nvmlPerfPolicyType_t perfPolicyType,
                                          nvmlViolationTime_t *violTime)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(violTime);
        InjectionArgument arg(perfPolicyType);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "ViolationStatus", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerState(nvmlDevice_t device, nvmlPstates_t *pState)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pState);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PowerState"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPerformanceState(nvmlDevice_t device, nvmlPstates_t *pState)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pState);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PerformanceState"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerUsage(nvmlDevice_t device, unsigned int *power)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(power);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PowerUsage"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerMode(nvmlDevice_t device, unsigned int *powerModeId)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(powerModeId);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PowerMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedPowerModes(nvmlDevice_t device, unsigned int *supportedPowerModes)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(supportedPowerModes);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "SupportedPowerModes"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetPowerMode(nvmlDevice_t device, unsigned int powerModeId)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(powerModeId);
        InjectedNvml->SimpleDeviceSet(device, "PowerMode", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTotalEnergyConsumption(nvmlDevice_t device, unsigned long long *energy)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(energy);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "TotalEnergyConsumption"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PowerManagementMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementLimit(nvmlDevice_t device, unsigned int *limit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(limit);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PowerManagementLimit"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTemperature(nvmlDevice_t device, nvmlTemperatureSensors_t sensorType, unsigned int *temp)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(temp);
        InjectionArgument arg(sensorType);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "Temperature", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTemperatureThreshold(nvmlDevice_t device,
                                               nvmlTemperatureThresholds_t thresholdType,
                                               unsigned int *temp)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(temp);
        InjectionArgument arg(thresholdType);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "TemperatureThreshold", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetTemperatureThreshold(nvmlDevice_t device,
                                               nvmlTemperatureThresholds_t thresholdType,
                                               int *temp)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument extraKey(thresholdType);
        InjectionArgument value(temp);
        InjectedNvml->DeviceSetWithExtraKey(device, "TemperatureThreshold", extraKey, value);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFanSpeed(nvmlDevice_t device, unsigned int *speed)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(speed);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "FanSpeed"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFanSpeed_v2(nvmlDevice_t device, unsigned int fan, unsigned int *speed)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(speed);
        InjectionArgument arg(fan);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "FanSpeed", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTargetFanSpeed(nvmlDevice_t device, unsigned int fan, unsigned int *targetSpeed)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(targetSpeed);
        InjectionArgument arg(fan);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "TargetFanSpeed", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNumFans(nvmlDevice_t device, unsigned int *numFans)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(numFans);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "NumFans"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetUtilizationRates(nvmlDevice_t device, nvmlUtilization_t *utilization)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(utilization);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "UtilizationRates"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderUtilization(nvmlDevice_t device,
                                             unsigned int *utilization,
                                             unsigned int *samplingPeriodUs)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(utilization));
        values.push_back(InjectionArgument(samplingPeriodUs));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "EncoderUtilization", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDecoderUtilization(nvmlDevice_t device,
                                             unsigned int *utilization,
                                             unsigned int *samplingPeriodUs)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(utilization));
        values.push_back(InjectionArgument(samplingPeriodUs));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "DecoderUtilization", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxPcieLinkGeneration(nvmlDevice_t device, unsigned int *maxLinkGen)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(maxLinkGen);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MaxPcieLinkGeneration"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxPcieLinkWidth(nvmlDevice_t device, unsigned int *maxLinkWidth)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(maxLinkWidth);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MaxPcieLinkWidth"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCurrPcieLinkGeneration(nvmlDevice_t device, unsigned int *currLinkGen)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(currLinkGen);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "CurrPcieLinkGeneration"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCurrPcieLinkWidth(nvmlDevice_t device, unsigned int *currLinkWidth)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(currLinkWidth);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "CurrPcieLinkWidth"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetDriverVersion(char *version, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::string str   = InjectedNvml->ObjectlessGet("DriverVersion").AsString();
        snprintf(version, length, "%s", str.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetNVMLVersion(char *version, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::string str   = InjectedNvml->ObjectlessGet("NVMLVersion").AsString();
        snprintf(version, length, "%s", str.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetCudaDriverVersion(int *cudaDriverVersion)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(cudaDriverVersion);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("CudaDriverVersion"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetCudaDriverVersion_v2(int *cudaDriverVersion)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(cudaDriverVersion);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("CudaDriverVersion"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetCount(unsigned int *unitCount)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(unitCount);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("Count"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetFanSpeedInfo(nvmlUnit_t unit, nvmlUnitFanSpeeds_t *fanSpeeds)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(fanSpeeds);
        output.SetValueFrom(InjectedNvml->UnitGet(unit, "FanSpeedInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetHandleByIndex(unsigned int index, nvmlUnit_t *unit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(index));
        args.push_back(InjectionArgument(unit));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetLedState(nvmlUnit_t unit, nvmlLedState_t *state)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(state);
        output.SetValueFrom(InjectedNvml->UnitGet(unit, "LedState"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitSetLedState(nvmlUnit_t unit, nvmlLedColor_t color)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(unit));
        args.push_back(InjectionArgument(color));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetPsuInfo(nvmlUnit_t unit, nvmlPSUInfo_t *psu)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(psu);
        output.SetValueFrom(InjectedNvml->UnitGet(unit, "PsuInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetTemperature(nvmlUnit_t unit, unsigned int type, unsigned int *temp)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(unit));
        args.push_back(InjectionArgument(type));
        args.push_back(InjectionArgument(temp));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetUnitInfo(nvmlUnit_t unit, nvmlUnitInfo_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(info);
        output.SetValueFrom(InjectedNvml->UnitGet(unit, "UnitInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlUnitGetDevices(nvmlUnit_t unit, unsigned int *deviceCount, nvmlDevice_t *devices)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(unit));
        args.push_back(InjectionArgument(deviceCount));
        args.push_back(InjectionArgument(devices));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVbiosVersion(nvmlDevice_t device, char *version, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(device);
        std::string buf = InjectedNvml->GetString(arg, "VbiosVersion");
        snprintf(version, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBridgeChipInfo(nvmlDevice_t device, nvmlBridgeChipHierarchy_t *bridgeHierarchy)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(bridgeHierarchy);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "BridgeChipInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetHicVersion(unsigned int *hwbcCount, nvmlHwbcEntry_t *hwbcEntries)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(hwbcCount));
        args.push_back(InjectionArgument(hwbcEntries));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetCreate(nvmlEventSet_t *set)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(set));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceRegisterEvents(nvmlDevice_t device, unsigned long long eventTypes, nvmlEventSet_t set)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "RegisterEvents", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "RegisterEvents", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedEventTypes(nvmlDevice_t device, unsigned long long *eventTypes)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(eventTypes);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "SupportedEventTypes"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetWait(nvmlEventSet_t set, nvmlEventData_t *data, unsigned int timeoutms)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(set));
        args.push_back(InjectionArgument(data));
        args.push_back(InjectionArgument(timeoutms));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetWait_v2(nvmlEventSet_t set, nvmlEventData_t *data, unsigned int timeoutms)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(set));
        args.push_back(InjectionArgument(data));
        args.push_back(InjectionArgument(timeoutms));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlEventSetFree(nvmlEventSet_t set)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(set));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeRunningProcesses(nvmlDevice_t device,
                                                  unsigned int *infoCount,
                                                  nvmlProcessInfo_v1_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "ComputeRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeRunningProcesses_v2(nvmlDevice_t device,
                                                     unsigned int *infoCount,
                                                     nvmlProcessInfo_v2_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "ComputeRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeRunningProcesses_v3(nvmlDevice_t device,
                                                     unsigned int *infoCount,
                                                     nvmlProcessInfo_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "ComputeRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses(nvmlDevice_t device,
                                                   unsigned int *infoCount,
                                                   nvmlProcessInfo_v1_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "GraphicsRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses_v2(nvmlDevice_t device,
                                                      unsigned int *infoCount,
                                                      nvmlProcessInfo_v2_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "GraphicsRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGraphicsRunningProcesses_v3(nvmlDevice_t device,
                                                      unsigned int *infoCount,
                                                      nvmlProcessInfo_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "GraphicsRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMPSComputeRunningProcesses(nvmlDevice_t device,
                                                     unsigned int *infoCount,
                                                     nvmlProcessInfo_v1_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "MPSComputeRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMPSComputeRunningProcesses_v2(nvmlDevice_t device,
                                                        unsigned int *infoCount,
                                                        nvmlProcessInfo_v2_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "MPSComputeRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMPSComputeRunningProcesses_v3(nvmlDevice_t device,
                                                        unsigned int *infoCount,
                                                        nvmlProcessInfo_t *infos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(infoCount));
        values.push_back(InjectionArgument(infos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "MPSComputeRunningProcesses", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetProcessName(unsigned int pid, char *name, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pid);
        std::string buf = InjectedNvml->GetString(arg, "ProcessName");
        snprintf(name, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceOnSameBoard(nvmlDevice_t dev1, nvmlDevice_t dev2, int *onSameBoard)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "OnSameBoard", dev1, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "OnSameBoard", dev1, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetInforomConfigurationChecksum(nvmlDevice_t device, unsigned int *checksum)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(checksum);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "InforomConfigurationChecksum"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceValidateInforom(nvmlDevice_t device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "ValidateInforom", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "ValidateInforom", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuOperationMode(nvmlDevice_t device,
                                           nvmlGpuOperationMode_t *current,
                                           nvmlGpuOperationMode_t *pending)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(current));
        values.push_back(InjectionArgument(pending));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "GpuOperationMode", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetGpuOperationMode(nvmlDevice_t device, nvmlGpuOperationMode_t mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        InjectedNvml->SimpleDeviceSet(device, "GpuOperationMode", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDisplayActive(nvmlDevice_t device, nvmlEnableState_t *isActive)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(isActive);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "DisplayActive"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryErrorCounter(nvmlDevice_t device,
                                             nvmlMemoryErrorType_t errorType,
                                             nvmlEccCounterType_t counterType,
                                             nvmlMemoryLocation_t locationType,
                                             unsigned long long *count)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "MemoryErrorCounter", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "MemoryErrorCounter", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetGpuLockedClocks(nvmlDevice_t device, unsigned int minGpuClockMHz, unsigned int maxGpuClockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(minGpuClockMHz));
        values.push_back(InjectionArgument(maxGpuClockMHz));
        CompoundValue cv(values);
        InjectedNvml->DeviceSetCompoundValue(device, "GpuLockedClocks", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetGpuLockedClocks(nvmlDevice_t device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "GpuLockedClocks", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "GpuLockedClocks", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetMemoryLockedClocks(nvmlDevice_t device,
                                             unsigned int minMemClockMHz,
                                             unsigned int maxMemClockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(minMemClockMHz));
        values.push_back(InjectionArgument(maxMemClockMHz));
        CompoundValue cv(values);
        InjectedNvml->DeviceSetCompoundValue(device, "MemoryLockedClocks", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetMemoryLockedClocks(nvmlDevice_t device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "MemoryLockedClocks", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "MemoryLockedClocks", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetApplicationsClocks(nvmlDevice_t device,
                                             unsigned int memClockMHz,
                                             unsigned int graphicsClockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(memClockMHz));
        values.push_back(InjectionArgument(graphicsClockMHz));
        CompoundValue cv(values);
        InjectedNvml->DeviceSetCompoundValue(device, "ApplicationsClocks", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetApplicationsClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        *clockMHz         = InjectedNvml->GetClockInfo(device, "ApplicationsClock", clockType);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxCustomerBoostClock(nvmlDevice_t device, nvmlClockType_t clockType, unsigned int *clockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        *clockMHz         = InjectedNvml->GetClockInfo(device, "MaxCustomerBoostClock", clockType);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetClock(nvmlDevice_t device,
                                nvmlClockType_t clockType,
                                nvmlClockId_t clockId,
                                unsigned int *clockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        *clockMHz         = InjectedNvml->GetClock(device, clockType, clockId);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDefaultApplicationsClock(nvmlDevice_t device,
                                                   nvmlClockType_t clockType,
                                                   unsigned int *clockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        *clockMHz         = InjectedNvml->GetClockInfo(device, "DefaultApplicationsClock", clockType);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetApplicationsClocks(nvmlDevice_t device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "ApplicationsClocks", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "ApplicationsClocks", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedMemoryClocks(nvmlDevice_t device, unsigned int *count, unsigned int *clocksMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(count));
        values.push_back(InjectionArgument(clocksMHz));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "SupportedMemoryClocks", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedGraphicsClocks(nvmlDevice_t device,
                                                  unsigned int memoryClockMHz,
                                                  unsigned int *count,
                                                  unsigned int *clocksMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "SupportedGraphicsClocks", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "SupportedGraphicsClocks", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAutoBoostedClocksEnabled(nvmlDevice_t device,
                                                   nvmlEnableState_t *isEnabled,
                                                   nvmlEnableState_t *defaultIsEnabled)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(isEnabled));
        values.push_back(InjectionArgument(defaultIsEnabled));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "AutoBoostedClocksEnabled", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetAutoBoostedClocksEnabled(nvmlDevice_t device, nvmlEnableState_t enabled)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(enabled);
        InjectedNvml->SimpleDeviceSet(device, "AutoBoostedClocksEnabled", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetDefaultAutoBoostedClocksEnabled(nvmlDevice_t device,
                                                          nvmlEnableState_t enabled,
                                                          unsigned int flags)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(enabled));
        values.push_back(InjectionArgument(flags));
        CompoundValue cv(values);
        InjectedNvml->DeviceSetCompoundValue(device, "DefaultAutoBoostedClocksEnabled", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementLimitConstraints(nvmlDevice_t device,
                                                          unsigned int *minLimit,
                                                          unsigned int *maxLimit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(minLimit));
        values.push_back(InjectionArgument(maxLimit));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "PowerManagementLimitConstraints", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerManagementDefaultLimit(nvmlDevice_t device, unsigned int *defaultLimit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(defaultLimit);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PowerManagementDefaultLimit"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetPowerManagementLimit(nvmlDevice_t device, unsigned int limit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(limit);
        InjectedNvml->SimpleDeviceSet(device, "PowerManagementLimit", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCurrentClocksThrottleReasons(nvmlDevice_t device, unsigned long long *clocksThrottleReasons)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(clocksThrottleReasons);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "CurrentClocksThrottleReasons"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedClocksThrottleReasons(nvmlDevice_t device,
                                                         unsigned long long *supportedClocksThrottleReasons)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(supportedClocksThrottleReasons);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "SupportedClocksThrottleReasons"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetIndex(nvmlDevice_t device, unsigned int *index)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(index);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "Index"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingMode(nvmlDevice_t device, nvmlEnableState_t *mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "AccountingMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetAccountingMode(nvmlDevice_t device, nvmlEnableState_t mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(mode);
        InjectedNvml->SimpleDeviceSet(device, "AccountingMode", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceClearAccountingPids(nvmlDevice_t device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "AccountingPids", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "AccountingPids", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingStats(nvmlDevice_t device, unsigned int pid, nvmlAccountingStats_t *stats)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(stats);
        InjectionArgument arg(pid);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "AccountingStats", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingPids(nvmlDevice_t device, unsigned int *count, unsigned int *pids)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(count));
        values.push_back(InjectionArgument(pids));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "AccountingPids", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAccountingBufferSize(nvmlDevice_t device, unsigned int *bufferSize)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(bufferSize);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "AccountingBufferSize"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRetiredPages(nvmlDevice_t device,
                                       nvmlPageRetirementCause_t sourceFilter,
                                       unsigned int *count,
                                       unsigned long long *addresses)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "RetiredPages", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "RetiredPages", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRetiredPages_v2(nvmlDevice_t device,
                                          nvmlPageRetirementCause_t sourceFilter,
                                          unsigned int *count,
                                          unsigned long long *addresses,
                                          unsigned long long *timestamps)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "RetiredPages", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "RetiredPages", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRetiredPagesPendingStatus(nvmlDevice_t device, nvmlEnableState_t *isPending)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(isPending);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "RetiredPagesPendingStatus"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetAPIRestriction(nvmlDevice_t device,
                                         nvmlRestrictedAPI_t apiType,
                                         nvmlEnableState_t isRestricted)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(apiType));
        values.push_back(InjectionArgument(isRestricted));
        CompoundValue cv(values);
        InjectedNvml->DeviceSetCompoundValue(device, "APIRestriction", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAPIRestriction(nvmlDevice_t device,
                                         nvmlRestrictedAPI_t apiType,
                                         nvmlEnableState_t *isRestricted)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(isRestricted);
        InjectionArgument arg(apiType);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "APIRestriction", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMinorNumber(nvmlDevice_t device, unsigned int *minorNumber)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(minorNumber);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MinorNumber"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEnforcedPowerLimit(nvmlDevice_t device, unsigned int *limit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(limit);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "EnforcedPowerLimit"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSamples(nvmlDevice_t device,
                                  nvmlSamplingType_t type,
                                  unsigned long long lastSeenTimeStamp,
                                  nvmlValueType_t *sampleValType,
                                  unsigned int *sampleCount,
                                  nvmlSample_t *samples)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "Samples", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "Samples", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieThroughput(nvmlDevice_t device, nvmlPcieUtilCounter_t counter, unsigned int *value)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(value);
        InjectionArgument arg(counter);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "PcieThroughput", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieReplayCounter(nvmlDevice_t device, unsigned int *value)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(value);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PcieReplayCounter"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTopologyCommonAncestor(nvmlDevice_t device1,
                                                 nvmlDevice_t device2,
                                                 nvmlGpuTopologyLevel_t *pathInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(pathInfo);
        InjectionArgument arg(device2);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device1, "TopologyCommonAncestor", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetTopologyNearestGpus(nvmlDevice_t device,
                                              nvmlGpuTopologyLevel_t level,
                                              unsigned int *count,
                                              nvmlDevice_t *deviceArray)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "TopologyNearestGpus", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "TopologyNearestGpus", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetTopologyGpuSet(unsigned int cpuNumber, unsigned int *count, nvmlDevice_t *deviceArray)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(cpuNumber));
        args.push_back(InjectionArgument(count));
        args.push_back(InjectionArgument(deviceArray));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkState(nvmlDevice_t device, unsigned int link, nvmlEnableState_t *isActive)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(isActive);
        InjectionArgument arg(link);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "NvLinkState", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetP2PStatus(nvmlDevice_t device1,
                                    nvmlDevice_t device2,
                                    nvmlGpuP2PCapsIndex_t p2pIndex,
                                    nvmlGpuP2PStatus_t *p2pStatus)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "P2PStatus", device1, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "P2PStatus", device1, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkVersion(nvmlDevice_t device, unsigned int link, unsigned int *version)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(version);
        InjectionArgument arg(link);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "NvLinkVersion", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkRemotePciInfo(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(pci);
        InjectionArgument arg(link);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "NvLinkRemotePciInfo", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkRemotePciInfo_v2(nvmlDevice_t device, unsigned int link, nvmlPciInfo_t *pci)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(pci);
        InjectionArgument arg(link);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "NvLinkRemotePciInfo", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkRemoteDeviceType(nvmlDevice_t device,
                                                 unsigned int link,
                                                 nvmlIntNvLinkDeviceType_t *pNvLinkDeviceType)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(pNvLinkDeviceType);
        InjectionArgument arg(link);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "NvLinkRemoteDeviceType", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkCapability(nvmlDevice_t device,
                                           unsigned int link,
                                           nvmlNvLinkCapability_t capability,
                                           unsigned int *capResult)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkCapability", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkCapability", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkErrorCounter(nvmlDevice_t device,
                                             unsigned int link,
                                             nvmlNvLinkErrorCounter_t counter,
                                             unsigned long long *counterValue)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkErrorCounter", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkErrorCounter", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetNvLinkErrorCounters(nvmlDevice_t device, unsigned int link)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkErrorCounters", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkErrorCounters", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetNvLinkUtilizationControl(nvmlDevice_t device,
                                                   unsigned int link,
                                                   unsigned int counter,
                                                   nvmlNvLinkUtilizationControl_t *control,
                                                   unsigned int reset)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkUtilizationControl", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkUtilizationControl", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkUtilizationControl(nvmlDevice_t device,
                                                   unsigned int link,
                                                   unsigned int counter,
                                                   nvmlNvLinkUtilizationControl_t *control)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkUtilizationControl", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkUtilizationControl", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNvLinkUtilizationCounter(nvmlDevice_t device,
                                                   unsigned int link,
                                                   unsigned int counter,
                                                   unsigned long long *rxcounter,
                                                   unsigned long long *txcounter)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkUtilizationCounter", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkUtilizationCounter", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceFreezeNvLinkUtilizationCounter(nvmlDevice_t device,
                                                      unsigned int link,
                                                      unsigned int counter,
                                                      nvmlEnableState_t freeze)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkUtilizationCounter", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkUtilizationCounter", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceResetNvLinkUtilizationCounter(nvmlDevice_t device, unsigned int link, unsigned int counter)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "NvLinkUtilizationCounter", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "NvLinkUtilizationCounter", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t *pVirtualMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pVirtualMode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "VirtualizationMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetVirtualizationMode(nvmlDevice_t device, nvmlGpuVirtualizationMode_t virtualMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(virtualMode);
        InjectedNvml->SimpleDeviceSet(device, "VirtualizationMode", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(vgpuCount));
        values.push_back(InjectionArgument(vgpuTypeIds));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "SupportedVgpus", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCreatableVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuTypeId_t *vgpuTypeIds)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(vgpuCount));
        values.push_back(InjectionArgument(vgpuTypeIds));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "CreatableVgpus", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetClass(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeClass, unsigned int *size)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(vgpuTypeId);
        std::string buf = InjectedNvml->GetString(arg, "Class");
        snprintf(vgpuTypeClass, *size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetName(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeName, unsigned int *size)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(vgpuTypeId);
        std::string buf = InjectedNvml->GetString(arg, "Name");
        snprintf(vgpuTypeName, *size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetGpuInstanceProfileId(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *gpuInstanceProfileId)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(gpuInstanceProfileId);
        output.SetValueFrom(InjectedNvml->GetByVgpuTypeId(vgpuTypeId, "GpuInstanceProfileId"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetDeviceID(nvmlVgpuTypeId_t vgpuTypeId,
                                     unsigned long long *deviceID,
                                     unsigned long long *subsystemID)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuTypeId));
        args.push_back(InjectionArgument(deviceID));
        args.push_back(InjectionArgument(subsystemID));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetFramebufferSize(nvmlVgpuTypeId_t vgpuTypeId, unsigned long long *fbSize)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(fbSize);
        output.SetValueFrom(InjectedNvml->GetByVgpuTypeId(vgpuTypeId, "FramebufferSize"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetNumDisplayHeads(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *numDisplayHeads)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(numDisplayHeads);
        output.SetValueFrom(InjectedNvml->GetByVgpuTypeId(vgpuTypeId, "NumDisplayHeads"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetResolution(nvmlVgpuTypeId_t vgpuTypeId,
                                       unsigned int displayIndex,
                                       unsigned int *xdim,
                                       unsigned int *ydim)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuTypeId));
        args.push_back(InjectionArgument(displayIndex));
        args.push_back(InjectionArgument(xdim));
        args.push_back(InjectionArgument(ydim));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetLicense(nvmlVgpuTypeId_t vgpuTypeId, char *vgpuTypeLicenseString, unsigned int size)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(vgpuTypeId);
        std::string buf = InjectedNvml->GetString(arg, "License");
        snprintf(vgpuTypeLicenseString, size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetFrameRateLimit(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *frameRateLimit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(frameRateLimit);
        output.SetValueFrom(InjectedNvml->GetByVgpuTypeId(vgpuTypeId, "FrameRateLimit"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetMaxInstances(nvmlDevice_t device,
                                         nvmlVgpuTypeId_t vgpuTypeId,
                                         unsigned int *vgpuInstanceCount)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(vgpuInstanceCount);
        InjectionArgument arg(vgpuTypeId);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "MaxInstances", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetMaxInstancesPerVm(nvmlVgpuTypeId_t vgpuTypeId, unsigned int *vgpuInstanceCountPerVm)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(vgpuInstanceCountPerVm);
        output.SetValueFrom(InjectedNvml->GetByVgpuTypeId(vgpuTypeId, "MaxInstancesPerVm"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetActiveVgpus(nvmlDevice_t device, unsigned int *vgpuCount, nvmlVgpuInstance_t *vgpuInstances)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(vgpuCount));
        values.push_back(InjectionArgument(vgpuInstances));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "ActiveVgpus", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetVmID(nvmlVgpuInstance_t vgpuInstance,
                                     char *vmId,
                                     unsigned int size,
                                     nvmlVgpuVmIdType_t *vmIdType)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(vmId));
        args.push_back(InjectionArgument(size));
        args.push_back(InjectionArgument(vmIdType));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetUUID(nvmlVgpuInstance_t vgpuInstance, char *uuid, unsigned int size)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(vgpuInstance);
        std::string buf = InjectedNvml->GetString(arg, "UUID");
        snprintf(uuid, size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetMdevUUID(nvmlVgpuInstance_t vgpuInstance, char *mdevUuid, unsigned int size)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(vgpuInstance);
        std::string buf = InjectedNvml->GetString(arg, "MdevUUID");
        snprintf(mdevUuid, size, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetVmDriverVersion(nvmlVgpuInstance_t vgpuInstance, char *version, unsigned int length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(vgpuInstance);
        std::string buf = InjectedNvml->GetString(arg, "VmDriverVersion");
        snprintf(version, length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFbUsage(nvmlVgpuInstance_t vgpuInstance, unsigned long long *fbUsage)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(fbUsage);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "FbUsage"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetLicenseStatus(nvmlVgpuInstance_t vgpuInstance, unsigned int *licensed)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(licensed);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "LicenseStatus"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetLicenseInfo(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(licenseInfo);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "LicenseInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetLicenseInfo_v2(nvmlVgpuInstance_t vgpuInstance, nvmlVgpuLicenseInfo_t *licenseInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(licenseInfo);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "LicenseInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetType(nvmlVgpuInstance_t vgpuInstance, unsigned int *vgpuTypeId)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(vgpuTypeId);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "Type"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFrameRateLimit(nvmlVgpuInstance_t vgpuInstance, unsigned int *frameRateLimit)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(frameRateLimit);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "FrameRateLimit"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEccMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *eccMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(eccMode);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "EccMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int *encoderCapacity)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(encoderCapacity);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "EncoderCapacity"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceSetEncoderCapacity(nvmlVgpuInstance_t vgpuInstance, unsigned int encoderCapacity)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(encoderCapacity));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVgpuUtilization(nvmlDevice_t device,
                                          unsigned long long lastSeenTimeStamp,
                                          nvmlValueType_t *sampleValType,
                                          unsigned int *vgpuInstanceSamplesCount,
                                          nvmlVgpuInstanceUtilizationSample_t *utilizationSamples)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "VgpuUtilization", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "VgpuUtilization", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetMetadata(nvmlVgpuInstance_t vgpuInstance,
                                         nvmlVgpuMetadata_t *vgpuMetadata,
                                         unsigned int *bufferSize)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(vgpuMetadata));
        args.push_back(InjectionArgument(bufferSize));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetGpuPciId(nvmlVgpuInstance_t vgpuInstance, char *vgpuPciId, unsigned int *length)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(vgpuInstance);
        std::string buf = InjectedNvml->GetString(arg, "GpuPciId");
        snprintf(vgpuPciId, *length, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuTypeGetCapabilities(nvmlVgpuTypeId_t vgpuTypeId,
                                         nvmlVgpuCapability_t capability,
                                         unsigned int *capResult)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuTypeId));
        args.push_back(InjectionArgument(capability));
        args.push_back(InjectionArgument(capResult));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGspFirmwareVersion(nvmlDevice_t device, char *version)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(version);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "GspFirmwareVersion"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGspFirmwareMode(nvmlDevice_t device, unsigned int *isEnabled, unsigned int *defaultMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(isEnabled));
        values.push_back(InjectionArgument(defaultMode));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "GspFirmwareMode", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetGpuInstanceId(nvmlVgpuInstance_t vgpuInstance, unsigned int *gpuInstanceId)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(gpuInstanceId);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "GpuInstanceId"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVgpuMetadata(nvmlDevice_t device,
                                       nvmlVgpuPgpuMetadata_t *pgpuMetadata,
                                       unsigned int *bufferSize)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "VgpuMetadata", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "VgpuMetadata", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetVgpuCompatibility(nvmlVgpuMetadata_t *vgpuMetadata,
                                      nvmlVgpuPgpuMetadata_t *pgpuMetadata,
                                      nvmlVgpuPgpuCompatibility_t *compatibilityInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuMetadata));
        args.push_back(InjectionArgument(pgpuMetadata));
        args.push_back(InjectionArgument(compatibilityInfo));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPgpuMetadataString(nvmlDevice_t device, char *pgpuMetadata, unsigned int *bufferSize)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(device);
        std::string buf = InjectedNvml->GetString(arg, "PgpuMetadataString");
        snprintf(pgpuMetadata, *bufferSize, "%s", buf.c_str());
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures(nvmlDevice_t device,
                                                 nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pGridLicensableFeatures);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "GridLicensableFeatures"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures_v2(nvmlDevice_t device,
                                                    nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pGridLicensableFeatures);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "GridLicensableFeatures"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures_v3(nvmlDevice_t device,
                                                    nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pGridLicensableFeatures);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "GridLicensableFeatures"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGridLicensableFeatures_v4(nvmlDevice_t device,
                                                    nvmlGridLicensableFeatures_t *pGridLicensableFeatures)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pGridLicensableFeatures);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "GridLicensableFeatures"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderCapacity(nvmlDevice_t device,
                                          nvmlEncoderType_t encoderQueryType,
                                          unsigned int *pEncoderCapacity)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(pEncoderCapacity);
        InjectionArgument arg(encoderQueryType);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "EncoderCapacity", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderStats(nvmlDevice_t device,
                                       unsigned int *sessionCount,
                                       unsigned int *averageFps,
                                       unsigned int *averageLatency)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "EncoderStats", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "EncoderStats", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetEncoderSessions(nvmlDevice_t device,
                                          unsigned int *sessionCount,
                                          nvmlEncoderSessionInfo_t *sessionInfos)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(sessionCount));
        values.push_back(InjectionArgument(sessionInfos));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "EncoderSessions", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFBCStats(nvmlDevice_t device, nvmlFBCStats_t *fbcStats)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(fbcStats);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "FBCStats"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFBCSessions(nvmlDevice_t device,
                                      unsigned int *sessionCount,
                                      nvmlFBCSessionInfo_t *sessionInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(sessionCount));
        values.push_back(InjectionArgument(sessionInfo));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "FBCSessions", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceModifyDrainState(nvmlPciInfo_t *pciInfo, nvmlEnableState_t newState)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(pciInfo));
        args.push_back(InjectionArgument(newState));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceQueryDrainState(nvmlPciInfo_t *pciInfo, nvmlEnableState_t *newState)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(pciInfo));
        args.push_back(InjectionArgument(newState));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceRemoveGpu(nvmlPciInfo_t *pciInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(pciInfo));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceRemoveGpu_v2(nvmlPciInfo_t *pciInfo,
                                    nvmlDetachGpuState_t gpuState,
                                    nvmlPcieLinkState_t linkState)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(pciInfo));
        args.push_back(InjectionArgument(gpuState));
        args.push_back(InjectionArgument(linkState));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceDiscoverGpus(nvmlPciInfo_t *pciInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(pciInfo));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetFieldValues(nvmlDevice_t device, int valuesCount, nvmlFieldValue_t *values)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        if (values == nullptr)
        {
            return NVML_ERROR_INVALID_ARGUMENT;
        }

        InjectedNvml->GetFieldValues(device, valuesCount, values);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetVgpuProcessUtilization(nvmlDevice_t device,
                                                 unsigned long long lastSeenTimeStamp,
                                                 unsigned int *vgpuProcessSamplesCount,
                                                 nvmlVgpuProcessUtilizationSample_t *utilizationSamples)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "VgpuProcessUtilization", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "VgpuProcessUtilization", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEncoderStats(nvmlVgpuInstance_t vgpuInstance,
                                             unsigned int *sessionCount,
                                             unsigned int *averageFps,
                                             unsigned int *averageLatency)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(sessionCount));
        args.push_back(InjectionArgument(averageFps));
        args.push_back(InjectionArgument(averageLatency));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetEncoderSessions(nvmlVgpuInstance_t vgpuInstance,
                                                unsigned int *sessionCount,
                                                nvmlEncoderSessionInfo_t *sessionInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(sessionCount));
        args.push_back(InjectionArgument(sessionInfo));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFBCStats(nvmlVgpuInstance_t vgpuInstance, nvmlFBCStats_t *fbcStats)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(fbcStats);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "FBCStats"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetFBCSessions(nvmlVgpuInstance_t vgpuInstance,
                                            unsigned int *sessionCount,
                                            nvmlFBCSessionInfo_t *sessionInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(sessionCount));
        args.push_back(InjectionArgument(sessionInfo));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetProcessUtilization(nvmlDevice_t device,
                                             nvmlProcessUtilizationSample_t *utilization,
                                             unsigned int *processSamplesCount,
                                             unsigned long long lastSeenTimeStamp)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "ProcessUtilization", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "ProcessUtilization", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetAccountingMode(nvmlVgpuInstance_t vgpuInstance, nvmlEnableState_t *mode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(mode);
        output.SetValueFrom(InjectedNvml->VgpuInstanceGet(vgpuInstance, "AccountingMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetAccountingPids(nvmlVgpuInstance_t vgpuInstance, unsigned int *count, unsigned int *pids)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(count));
        args.push_back(InjectionArgument(pids));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceGetAccountingStats(nvmlVgpuInstance_t vgpuInstance,
                                                unsigned int pid,
                                                nvmlAccountingStats_t *stats)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));
        args.push_back(InjectionArgument(pid));
        args.push_back(InjectionArgument(stats));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlVgpuInstanceClearAccountingPids(nvmlVgpuInstance_t vgpuInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuInstance));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetExcludedDeviceCount(unsigned int *deviceCount)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(deviceCount);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("ExcludedDeviceCount"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetExcludedDeviceInfoByIndex(unsigned int index, nvmlExcludedDeviceInfo_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(index));
        args.push_back(InjectionArgument(info));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGetVgpuVersion(nvmlVgpuVersion_t *supported, nvmlVgpuVersion_t *current)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(supported));
        args.push_back(InjectionArgument(current));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSetVgpuVersion(nvmlVgpuVersion_t *vgpuVersion)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(vgpuVersion));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHostVgpuMode(nvmlDevice_t device, nvmlHostVgpuMode_t *pHostVgpuMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pHostVgpuMode);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "HostVgpuMode"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetMigMode(nvmlDevice_t device, unsigned int mode, nvmlReturn_t *activationStatus)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "MigMode", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "MigMode", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMigMode(nvmlDevice_t device, unsigned int *currentMode, unsigned int *pendingMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(currentMode));
        values.push_back(InjectionArgument(pendingMode));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "MigMode", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceProfileInfo(nvmlDevice_t device,
                                                 unsigned int profile,
                                                 nvmlGpuInstanceProfileInfo_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(info);
        InjectionArgument arg(profile);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "GpuInstanceProfileInfo", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceProfileInfoV(nvmlDevice_t device,
                                                  unsigned int profile,
                                                  nvmlGpuInstanceProfileInfo_v2_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(info);
        InjectionArgument arg(profile);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "GpuInstanceProfileInfoV", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceRemainingCapacity(nvmlDevice_t device, unsigned int profileId, unsigned int *count)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(count);
        InjectionArgument arg(profileId);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "GpuInstanceRemainingCapacity", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstancePossiblePlacements(nvmlDevice_t device,
                                                        unsigned int profileId,
                                                        nvmlGpuInstancePlacement_t *placements,
                                                        unsigned int *count)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "GpuInstancePossiblePlacements", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "GpuInstancePossiblePlacements", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstancePossiblePlacements_v2(nvmlDevice_t device,
                                                           unsigned int profileId,
                                                           nvmlGpuInstancePlacement_t *placements,
                                                           unsigned int *count)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "GpuInstancePossiblePlacements", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "GpuInstancePossiblePlacements", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceCreateGpuInstance(nvmlDevice_t device, unsigned int profileId, nvmlGpuInstance_t *gpuInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "GpuInstance", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "GpuInstance", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceCreateGpuInstanceWithPlacement(nvmlDevice_t device,
                                                      unsigned int profileId,
                                                      const nvmlGpuInstancePlacement_t *placement,
                                                      nvmlGpuInstance_t *gpuInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "GpuInstanceWithPlacement", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "GpuInstanceWithPlacement", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceDestroy(nvmlGpuInstance_t gpuInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstances(nvmlDevice_t device,
                                       unsigned int profileId,
                                       nvmlGpuInstance_t *instances,
                                       unsigned int *count)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "GpuInstances", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "GpuInstances", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetInfo(nvmlGpuInstance_t gpuInstance, nvmlGpuInstanceInfo_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(info));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceById(nvmlDevice_t device, unsigned int id, nvmlGpuInstance_t *gpuInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(gpuInstance);
        InjectionArgument arg(id);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "GpuInstanceById", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceProfileInfo(nvmlGpuInstance_t gpuInstance,
                                                          unsigned int profile,
                                                          unsigned int engProfile,
                                                          nvmlComputeInstanceProfileInfo_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profile));
        args.push_back(InjectionArgument(engProfile));
        args.push_back(InjectionArgument(info));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceProfileInfoV(nvmlGpuInstance_t gpuInstance,
                                                           unsigned int profile,
                                                           unsigned int engProfile,
                                                           nvmlComputeInstanceProfileInfo_v2_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profile));
        args.push_back(InjectionArgument(engProfile));
        args.push_back(InjectionArgument(info));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceRemainingCapacity(nvmlGpuInstance_t gpuInstance,
                                                                unsigned int profileId,
                                                                unsigned int *count)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profileId));
        args.push_back(InjectionArgument(count));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceCreateComputeInstance(nvmlGpuInstance_t gpuInstance,
                                                  unsigned int profileId,
                                                  nvmlComputeInstance_t *computeInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profileId));
        args.push_back(InjectionArgument(computeInstance));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlComputeInstanceDestroy(nvmlComputeInstance_t computeInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(computeInstance));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstances(nvmlGpuInstance_t gpuInstance,
                                                unsigned int profileId,
                                                nvmlComputeInstance_t *computeInstances,
                                                unsigned int *count)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(profileId));
        args.push_back(InjectionArgument(computeInstances));
        args.push_back(InjectionArgument(count));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpuInstanceGetComputeInstanceById(nvmlGpuInstance_t gpuInstance,
                                                   unsigned int id,
                                                   nvmlComputeInstance_t *computeInstance)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpuInstance));
        args.push_back(InjectionArgument(id));
        args.push_back(InjectionArgument(computeInstance));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlComputeInstanceGetInfo(nvmlComputeInstance_t computeInstance, nvmlComputeInstanceInfo_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(computeInstance));
        args.push_back(InjectionArgument(info));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlComputeInstanceGetInfo_v2(nvmlComputeInstance_t computeInstance, nvmlComputeInstanceInfo_t *info)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(computeInstance));
        args.push_back(InjectionArgument(info));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceIsMigDeviceHandle(nvmlDevice_t device, unsigned int *isMigDevice)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "MigDeviceHandle", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "MigDeviceHandle", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpuInstanceId(nvmlDevice_t device, unsigned int *id)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(id);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "GpuInstanceId"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetComputeInstanceId(nvmlDevice_t device, unsigned int *id)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(id);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "ComputeInstanceId"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMaxMigDeviceCount(nvmlDevice_t device, unsigned int *migDeviceCount)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(migDeviceCount);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MaxMigDeviceCount"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMigDeviceHandleByIndex(nvmlDevice_t device, unsigned int index, nvmlDevice_t *migDevice)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(migDevice);
        InjectionArgument arg(index);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "MigDeviceHandleByIndex", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlSystemGetConfComputeState(nvmlConfComputeSystemState_t *ccMode)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(ccMode);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("ConfComputeState"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDeviceHandleFromMigDeviceHandle(nvmlDevice_t migDevice, nvmlDevice_t *device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument identifier(migDevice);
        *device = InjectedNvml->GetNvmlDevice(identifier, "DeviceHandleFromMigDeviceHandle");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAttributes(nvmlDevice_t device, nvmlDeviceAttributes_t *attributes)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(attributes);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "Attributes"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAttributes_v2(nvmlDevice_t device, nvmlDeviceAttributes_t *attributes)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(attributes);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "Attributes"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRemappedRows(nvmlDevice_t device,
                                       unsigned int *corrRows,
                                       unsigned int *uncRows,
                                       unsigned int *isPending,
                                       unsigned int *failureOccurred)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "RemappedRows", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "RemappedRows", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetRowRemapperHistogram(nvmlDevice_t device, nvmlRowRemapperHistogramValues_t *values)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(values);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "RowRemapperHistogram"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetBusType(nvmlDevice_t device, nvmlBusType_t *type)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(type);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "BusType"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetIrqNum(nvmlDevice_t device, unsigned int *irqNum)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(irqNum);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "IrqNum"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetNumGpuCores(nvmlDevice_t device, unsigned int *numCores)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(numCores);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "NumGpuCores"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPowerSource(nvmlDevice_t device, nvmlPowerSource_t *powerSource)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(powerSource);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PowerSource"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemoryBusWidth(nvmlDevice_t device, unsigned int *busWidth)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(busWidth);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MemoryBusWidth"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieLinkMaxSpeed(nvmlDevice_t device, unsigned int *maxSpeed)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(maxSpeed);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PcieLinkMaxSpeed"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetAdaptiveClockInfoStatus(nvmlDevice_t device, unsigned int *adaptiveClockStatus)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(adaptiveClockStatus);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "AdaptiveClockInfoStatus"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetPcieSpeed(nvmlDevice_t device, unsigned int *pcieSpeed)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pcieSpeed);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "PcieSpeed"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetDynamicPstatesInfo(nvmlDevice_t device, nvmlGpuDynamicPstatesInfo_t *pDynamicPstatesInfo)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(pDynamicPstatesInfo);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "DynamicPstatesInfo"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetFanSpeed_v2(nvmlDevice_t device, unsigned int fan, unsigned int speed)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument extraKey(fan);
        InjectionArgument value(speed);
        InjectedNvml->DeviceSetWithExtraKey(device, "FanSpeed", extraKey, value);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetDefaultFanSpeed_v2(nvmlDevice_t device, unsigned int fan)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(fan);
        InjectedNvml->SimpleDeviceSet(device, "DefaultFanSpeed", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetThermalSettings(nvmlDevice_t device,
                                          unsigned int sensorIndex,
                                          nvmlGpuThermalSettings_t *pThermalSettings)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument output(pThermalSettings);
        InjectionArgument arg(sensorIndex);
        output.SetValueFrom(InjectedNvml->DeviceGetWithExtraKey(device, "ThermalSettings", arg));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMinMaxClockOfPState(nvmlDevice_t device,
                                              nvmlClockType_t type,
                                              nvmlPstates_t pstate,
                                              unsigned int *minClockMHz,
                                              unsigned int *maxClockMHz)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "MinMaxClockOfPState", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "MinMaxClockOfPState", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetSupportedPerformanceStates(nvmlDevice_t device, nvmlPstates_t *pstates, unsigned int size)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "SupportedPerformanceStates", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "SupportedPerformanceStates", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpcClkVfOffset(nvmlDevice_t device, int *offset)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(offset);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "GpcClkVfOffset"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetGpcClkVfOffset(nvmlDevice_t device, int offset)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(offset);
        InjectedNvml->SimpleDeviceSet(device, "GpcClkVfOffset", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemClkVfOffset(nvmlDevice_t device, int *offset)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(offset);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "MemClkVfOffset"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceSetMemClkVfOffset(nvmlDevice_t device, int offset)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(offset);
        InjectedNvml->SimpleDeviceSet(device, "MemClkVfOffset", arg);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMinMaxFanSpeed(nvmlDevice_t device, unsigned int *min, unsigned int *max)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(min));
        values.push_back(InjectionArgument(max));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "MinMaxFanSpeed", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetGpcClkMinMaxVfOffset(nvmlDevice_t device, int *minOffset, int *maxOffset)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(minOffset));
        values.push_back(InjectionArgument(maxOffset));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "GpcClkMinMaxVfOffset", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetMemClkMinMaxVfOffset(nvmlDevice_t device, int *minOffset, int *maxOffset)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> values;
        values.push_back(InjectionArgument(minOffset));
        values.push_back(InjectionArgument(maxOffset));
        CompoundValue cv(values);
        InjectedNvml->GetCompoundValue(device, "MemClkMinMaxVfOffset", cv);
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmMetricsGet(nvmlGpmMetricsGet_t *metricsGet)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(metricsGet);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("Metrics"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmSampleAlloc(nvmlGpmSample_t *gpmSample)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpmSample));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmSampleFree(nvmlGpmSample_t gpmSample)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;
        args.push_back(InjectionArgument(gpmSample));

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->GetWrapper(__func__, args);
        }
        else
        {
            return InjectedNvml->SetWrapper(__func__, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmSampleGet(nvmlDevice_t device, nvmlGpmSample_t gpmSample)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(gpmSample);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "Sample"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmMigSampleGet(nvmlDevice_t device, unsigned int gpuInstanceId, nvmlGpmSample_t gpmSample)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "MigSample", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "MigSample", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlGpmQueryDeviceSupport(nvmlDevice_t device, nvmlGpmSupport_t *gpmSupport)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        std::vector<InjectionArgument> args;

        if (InjectedNvml->IsGetter(__func__))
        {
            return InjectedNvml->DeviceGetWrapper(__func__, "QueryDeviceSupport", device, args);
        }
        else
        {
            return InjectedNvml->DeviceSetWrapper(__func__, "QueryDeviceSupport", device, args);
        }
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetCount_v2(unsigned int *deviceCount)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(deviceCount);
        arg.SetValueFrom(InjectedNvml->ObjectlessGet("Count"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetHandleByIndex_v2(unsigned int index, nvmlDevice_t *device)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument identifier(index);
        *device = InjectedNvml->GetNvmlDevice(identifier, "Index");
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

nvmlReturn_t nvmlDeviceGetArchitecture(nvmlDevice_t device, nvmlDeviceArchitecture_t *arch)
{
    if (GLOBAL_PASS_THROUGH_MODE)
    {
        auto PassThruNvml = PassThruNvml::GetInstance();
        if (PassThruNvml->IsLoaded(__func__) == false)
        {
            PassThruNvml->LoadFunction(__func__);
        }
        return NVML_ERROR_NOT_SUPPORTED;
    }
    else
    {
        auto InjectedNvml = InjectedNvml::GetInstance();
        InjectionArgument arg(arch);
        arg.SetValueFrom(InjectedNvml->SimpleDeviceGet(device, "Architecture"));
        return NVML_SUCCESS;
    }
    return NVML_SUCCESS;
}

#ifdef __cplusplus
}
#endif
// END nvml_generated_stubs