/*
 * Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * NOTE: This code is auto-generated by generate_nvml_stubs.py
 * DO NOT EDIT MANUALLY
 */


// clang-format off
#pragma GCC diagnostic ignored "-Wunused-function"
#include "NvmlReturnDeserializer.h"

#include <functional>
#include <optional>
#include <unordered_map>

#include "nvml.h"
#include <yaml-cpp/yaml.h>
#include <yaml-cpp/node/node.h>

#include "NvmlLogging.h"
#include "NvmlFuncReturn.h"

namespace {

// The following snippet is generated from write_deserializer_declare
nvmlPciInfo_t *nvmlPciInfo_tDeserializer(const YAML::Node &node);
nvmlEccErrorCounts_t *nvmlEccErrorCounts_tDeserializer(const YAML::Node &node);
nvmlUtilization_t *nvmlUtilization_tDeserializer(const YAML::Node &node);
nvmlMemory_t *nvmlMemory_tDeserializer(const YAML::Node &node);
nvmlMemory_v2_t *nvmlMemory_v2_tDeserializer(const YAML::Node &node);
nvmlBAR1Memory_t *nvmlBAR1Memory_tDeserializer(const YAML::Node &node);
nvmlProcessInfo_v1_t *nvmlProcessInfo_v1_tDeserializer(const YAML::Node &node);
nvmlProcessInfo_v2_t *nvmlProcessInfo_v2_tDeserializer(const YAML::Node &node);
nvmlProcessInfo_t *nvmlProcessInfo_tDeserializer(const YAML::Node &node);
nvmlDeviceAttributes_t *nvmlDeviceAttributes_tDeserializer(const YAML::Node &node);
nvmlRowRemapperHistogramValues_t *nvmlRowRemapperHistogramValues_tDeserializer(const YAML::Node &node);
nvmlNvLinkUtilizationControl_t *nvmlNvLinkUtilizationControl_tDeserializer(const YAML::Node &node);
nvmlBridgeChipInfo_t *nvmlBridgeChipInfo_tDeserializer(const YAML::Node &node);
nvmlBridgeChipHierarchy_t *nvmlBridgeChipHierarchy_tDeserializer(const YAML::Node &node);
nvmlViolationTime_t *nvmlViolationTime_tDeserializer(const YAML::Node &node);
nvmlClkMonFaultInfo_t *nvmlClkMonFaultInfo_tDeserializer(const YAML::Node &node);
nvmlClkMonStatus_t *nvmlClkMonStatus_tDeserializer(const YAML::Node &node);
nvmlVgpuProcessUtilizationSample_t *nvmlVgpuProcessUtilizationSample_tDeserializer(const YAML::Node &node);
nvmlVgpuLicenseExpiry_t *nvmlVgpuLicenseExpiry_tDeserializer(const YAML::Node &node);
nvmlVgpuLicenseInfo_t *nvmlVgpuLicenseInfo_tDeserializer(const YAML::Node &node);
nvmlProcessUtilizationSample_t *nvmlProcessUtilizationSample_tDeserializer(const YAML::Node &node);
nvmlGridLicenseExpiry_t *nvmlGridLicenseExpiry_tDeserializer(const YAML::Node &node);
nvmlGridLicensableFeature_t *nvmlGridLicensableFeature_tDeserializer(const YAML::Node &node);
nvmlGridLicensableFeatures_t *nvmlGridLicensableFeatures_tDeserializer(const YAML::Node &node);
nvmlHwbcEntry_t *nvmlHwbcEntry_tDeserializer(const YAML::Node &node);
nvmlLedState_t *nvmlLedState_tDeserializer(const YAML::Node &node);
nvmlUnitInfo_t *nvmlUnitInfo_tDeserializer(const YAML::Node &node);
nvmlPSUInfo_t *nvmlPSUInfo_tDeserializer(const YAML::Node &node);
nvmlUnitFanInfo_t *nvmlUnitFanInfo_tDeserializer(const YAML::Node &node);
nvmlUnitFanSpeeds_t *nvmlUnitFanSpeeds_tDeserializer(const YAML::Node &node);
nvmlAccountingStats_t *nvmlAccountingStats_tDeserializer(const YAML::Node &node);
nvmlEncoderSessionInfo_t *nvmlEncoderSessionInfo_tDeserializer(const YAML::Node &node);
nvmlFBCStats_t *nvmlFBCStats_tDeserializer(const YAML::Node &node);
nvmlFBCSessionInfo_t *nvmlFBCSessionInfo_tDeserializer(const YAML::Node &node);
nvmlConfComputeSystemCaps_t *nvmlConfComputeSystemCaps_tDeserializer(const YAML::Node &node);
nvmlConfComputeSystemState_t *nvmlConfComputeSystemState_tDeserializer(const YAML::Node &node);
nvmlConfComputeMemSizeInfo_t *nvmlConfComputeMemSizeInfo_tDeserializer(const YAML::Node &node);
nvmlConfComputeGpuCertificate_t *nvmlConfComputeGpuCertificate_tDeserializer(const YAML::Node &node);
nvmlConfComputeGpuAttestationReport_t *nvmlConfComputeGpuAttestationReport_tDeserializer(const YAML::Node &node);
nvmlVgpuVersion_t *nvmlVgpuVersion_tDeserializer(const YAML::Node &node);
nvmlVgpuMetadata_t *nvmlVgpuMetadata_tDeserializer(const YAML::Node &node);
nvmlVgpuPgpuMetadata_t *nvmlVgpuPgpuMetadata_tDeserializer(const YAML::Node &node);
nvmlVgpuPgpuCompatibility_t *nvmlVgpuPgpuCompatibility_tDeserializer(const YAML::Node &node);
nvmlExcludedDeviceInfo_t *nvmlExcludedDeviceInfo_tDeserializer(const YAML::Node &node);
nvmlGpuInstancePlacement_t *nvmlGpuInstancePlacement_tDeserializer(const YAML::Node &node);
nvmlGpuInstanceProfileInfo_t *nvmlGpuInstanceProfileInfo_tDeserializer(const YAML::Node &node);
nvmlGpuInstanceProfileInfo_v2_t *nvmlGpuInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node);
nvmlComputeInstancePlacement_t *nvmlComputeInstancePlacement_tDeserializer(const YAML::Node &node);
nvmlComputeInstanceProfileInfo_t *nvmlComputeInstanceProfileInfo_tDeserializer(const YAML::Node &node);
nvmlComputeInstanceProfileInfo_v2_t *nvmlComputeInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node);
nvmlGpmSupport_t *nvmlGpmSupport_tDeserializer(const YAML::Node &node);

// The following snippet is generated from write_deserializer_definition
nvmlPciInfo_t *nvmlPciInfo_tDeserializer(const YAML::Node &node)
{
    auto *pciInfo = reinterpret_cast<nvmlPciInfo_t *>(malloc(sizeof(nvmlPciInfo_t)));
    if (pciInfo == nullptr)
    {
        return nullptr;
    }
    memset(pciInfo, 0, sizeof(*pciInfo));
    if (node["busIdLegacy"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto busIdLegacy = node["busIdLegacy"].as<std::string>();
        std::memcpy(&pciInfo->busIdLegacy, busIdLegacy.data(), sizeof(pciInfo->busIdLegacy));
    }
    else
    {
        NVML_LOG_ERR("missing busIdLegacy for struct nvmlPciInfo_t");
    }
    if (node["domain"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->domain = node["domain"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing domain for struct nvmlPciInfo_t");
    }
    if (node["bus"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->bus = node["bus"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing bus for struct nvmlPciInfo_t");
    }
    if (node["device"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->device = node["device"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing device for struct nvmlPciInfo_t");
    }
    if (node["pciDeviceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->pciDeviceId = node["pciDeviceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pciDeviceId for struct nvmlPciInfo_t");
    }
    if (node["pciSubSystemId"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->pciSubSystemId = node["pciSubSystemId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pciSubSystemId for struct nvmlPciInfo_t");
    }
    if (node["busId"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto busId = node["busId"].as<std::string>();
        std::memcpy(&pciInfo->busId, busId.data(), sizeof(pciInfo->busId));
    }
    else
    {
        NVML_LOG_ERR("missing busId for struct nvmlPciInfo_t");
    }
    return pciInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlEccErrorCounts_t *nvmlEccErrorCounts_tDeserializer(const YAML::Node &node)
{
    auto *eccErrorCounts = reinterpret_cast<nvmlEccErrorCounts_t *>(malloc(sizeof(nvmlEccErrorCounts_t)));
    if (eccErrorCounts == nullptr)
    {
        return nullptr;
    }
    memset(eccErrorCounts, 0, sizeof(*eccErrorCounts));
    if (node["l1Cache"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->l1Cache = node["l1Cache"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing l1Cache for struct nvmlEccErrorCounts_t");
    }
    if (node["l2Cache"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->l2Cache = node["l2Cache"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing l2Cache for struct nvmlEccErrorCounts_t");
    }
    if (node["deviceMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->deviceMemory = node["deviceMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing deviceMemory for struct nvmlEccErrorCounts_t");
    }
    if (node["registerFile"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->registerFile = node["registerFile"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing registerFile for struct nvmlEccErrorCounts_t");
    }
    return eccErrorCounts;
}

// The following snippet is generated from write_deserializer_definition
nvmlUtilization_t *nvmlUtilization_tDeserializer(const YAML::Node &node)
{
    auto *utilization = reinterpret_cast<nvmlUtilization_t *>(malloc(sizeof(nvmlUtilization_t)));
    if (utilization == nullptr)
    {
        return nullptr;
    }
    memset(utilization, 0, sizeof(*utilization));
    if (node["gpu"])
    {
        // The following snippet is generated from write_deserializer_definition
        utilization->gpu = node["gpu"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpu for struct nvmlUtilization_t");
    }
    if (node["memory"])
    {
        // The following snippet is generated from write_deserializer_definition
        utilization->memory = node["memory"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memory for struct nvmlUtilization_t");
    }
    return utilization;
}

// The following snippet is generated from write_deserializer_definition
nvmlMemory_t *nvmlMemory_tDeserializer(const YAML::Node &node)
{
    auto *memory = reinterpret_cast<nvmlMemory_t *>(malloc(sizeof(nvmlMemory_t)));
    if (memory == nullptr)
    {
        return nullptr;
    }
    memset(memory, 0, sizeof(*memory));
    if (node["total"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory->total = node["total"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing total for struct nvmlMemory_t");
    }
    if (node["free"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory->free = node["free"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing free for struct nvmlMemory_t");
    }
    if (node["used"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory->used = node["used"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing used for struct nvmlMemory_t");
    }
    return memory;
}

// The following snippet is generated from write_deserializer_definition
nvmlMemory_v2_t *nvmlMemory_v2_tDeserializer(const YAML::Node &node)
{
    auto *memory_v2 = reinterpret_cast<nvmlMemory_v2_t *>(malloc(sizeof(nvmlMemory_v2_t)));
    if (memory_v2 == nullptr)
    {
        return nullptr;
    }
    memset(memory_v2, 0, sizeof(*memory_v2));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->version = node["version"].as<unsigned int>();
    }
    if (node["total"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->total = node["total"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing total for struct nvmlMemory_v2_t");
    }
    if (node["reserved"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->reserved = node["reserved"].as<unsigned long long>();
    }
    if (node["free"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->free = node["free"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing free for struct nvmlMemory_v2_t");
    }
    if (node["used"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->used = node["used"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing used for struct nvmlMemory_v2_t");
    }
    return memory_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlBAR1Memory_t *nvmlBAR1Memory_tDeserializer(const YAML::Node &node)
{
    auto *bAR1Memory = reinterpret_cast<nvmlBAR1Memory_t *>(malloc(sizeof(nvmlBAR1Memory_t)));
    if (bAR1Memory == nullptr)
    {
        return nullptr;
    }
    memset(bAR1Memory, 0, sizeof(*bAR1Memory));
    if (node["bar1Total"])
    {
        // The following snippet is generated from write_deserializer_definition
        bAR1Memory->bar1Total = node["bar1Total"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing bar1Total for struct nvmlBAR1Memory_t");
    }
    if (node["bar1Free"])
    {
        // The following snippet is generated from write_deserializer_definition
        bAR1Memory->bar1Free = node["bar1Free"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing bar1Free for struct nvmlBAR1Memory_t");
    }
    if (node["bar1Used"])
    {
        // The following snippet is generated from write_deserializer_definition
        bAR1Memory->bar1Used = node["bar1Used"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing bar1Used for struct nvmlBAR1Memory_t");
    }
    return bAR1Memory;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessInfo_v1_t *nvmlProcessInfo_v1_tDeserializer(const YAML::Node &node)
{
    auto *processInfo_v1 = reinterpret_cast<nvmlProcessInfo_v1_t *>(malloc(sizeof(nvmlProcessInfo_v1_t)));
    if (processInfo_v1 == nullptr)
    {
        return nullptr;
    }
    memset(processInfo_v1, 0, sizeof(*processInfo_v1));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v1->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessInfo_v1_t");
    }
    if (node["usedGpuMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v1->usedGpuMemory = node["usedGpuMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing usedGpuMemory for struct nvmlProcessInfo_v1_t");
    }
    return processInfo_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessInfo_v2_t *nvmlProcessInfo_v2_tDeserializer(const YAML::Node &node)
{
    auto *processInfo_v2 = reinterpret_cast<nvmlProcessInfo_v2_t *>(malloc(sizeof(nvmlProcessInfo_v2_t)));
    if (processInfo_v2 == nullptr)
    {
        return nullptr;
    }
    memset(processInfo_v2, 0, sizeof(*processInfo_v2));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v2->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessInfo_v2_t");
    }
    if (node["usedGpuMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v2->usedGpuMemory = node["usedGpuMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing usedGpuMemory for struct nvmlProcessInfo_v2_t");
    }
    if (node["gpuInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v2->gpuInstanceId = node["gpuInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuInstanceId for struct nvmlProcessInfo_v2_t");
    }
    if (node["computeInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v2->computeInstanceId = node["computeInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing computeInstanceId for struct nvmlProcessInfo_v2_t");
    }
    return processInfo_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessInfo_t *nvmlProcessInfo_tDeserializer(const YAML::Node &node)
{
    auto *processInfo = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t)));
    if (processInfo == nullptr)
    {
        return nullptr;
    }
    memset(processInfo, 0, sizeof(*processInfo));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessInfo_t");
    }
    if (node["usedGpuMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->usedGpuMemory = node["usedGpuMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing usedGpuMemory for struct nvmlProcessInfo_t");
    }
    if (node["gpuInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->gpuInstanceId = node["gpuInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuInstanceId for struct nvmlProcessInfo_t");
    }
    if (node["computeInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->computeInstanceId = node["computeInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing computeInstanceId for struct nvmlProcessInfo_t");
    }
    return processInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlDeviceAttributes_t *nvmlDeviceAttributes_tDeserializer(const YAML::Node &node)
{
    auto *deviceAttributes = reinterpret_cast<nvmlDeviceAttributes_t *>(malloc(sizeof(nvmlDeviceAttributes_t)));
    if (deviceAttributes == nullptr)
    {
        return nullptr;
    }
    memset(deviceAttributes, 0, sizeof(*deviceAttributes));
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedCopyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedCopyEngineCount = node["sharedCopyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedCopyEngineCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedDecoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedDecoderCount = node["sharedDecoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedDecoderCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedEncoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedEncoderCount = node["sharedEncoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedEncoderCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedJpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedJpegCount = node["sharedJpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedJpegCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedOfaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedOfaCount = node["sharedOfaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedOfaCount for struct nvmlDeviceAttributes_t");
    }
    if (node["gpuInstanceSliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->gpuInstanceSliceCount = node["gpuInstanceSliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuInstanceSliceCount for struct nvmlDeviceAttributes_t");
    }
    if (node["computeInstanceSliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->computeInstanceSliceCount = node["computeInstanceSliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing computeInstanceSliceCount for struct nvmlDeviceAttributes_t");
    }
    if (node["memorySizeMB"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->memorySizeMB = node["memorySizeMB"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing memorySizeMB for struct nvmlDeviceAttributes_t");
    }
    return deviceAttributes;
}

// The following snippet is generated from write_deserializer_definition
nvmlRowRemapperHistogramValues_t *nvmlRowRemapperHistogramValues_tDeserializer(const YAML::Node &node)
{
    auto *rowRemapperHistogramValues = reinterpret_cast<nvmlRowRemapperHistogramValues_t *>(malloc(sizeof(nvmlRowRemapperHistogramValues_t)));
    if (rowRemapperHistogramValues == nullptr)
    {
        return nullptr;
    }
    memset(rowRemapperHistogramValues, 0, sizeof(*rowRemapperHistogramValues));
    if (node["max"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->max = node["max"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing max for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["high"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->high = node["high"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing high for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["partial"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->partial = node["partial"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing partial for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["low"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->low = node["low"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing low for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["none"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->none = node["none"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing none for struct nvmlRowRemapperHistogramValues_t");
    }
    return rowRemapperHistogramValues;
}

// The following snippet is generated from write_deserializer_definition
nvmlNvLinkUtilizationControl_t *nvmlNvLinkUtilizationControl_tDeserializer(const YAML::Node &node)
{
    auto *nvLinkUtilizationControl = reinterpret_cast<nvmlNvLinkUtilizationControl_t *>(malloc(sizeof(nvmlNvLinkUtilizationControl_t)));
    if (nvLinkUtilizationControl == nullptr)
    {
        return nullptr;
    }
    memset(nvLinkUtilizationControl, 0, sizeof(*nvLinkUtilizationControl));
    if (node["units"])
    {
        // The following snippet is generated from write_deserializer_definition
        nvLinkUtilizationControl->units = static_cast<nvmlNvLinkUtilizationCountUnits_t>(node["units"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing units for struct nvmlNvLinkUtilizationControl_t");
    }
    if (node["pktfilter"])
    {
        // The following snippet is generated from write_deserializer_definition
        nvLinkUtilizationControl->pktfilter = static_cast<nvmlNvLinkUtilizationCountPktTypes_t>(node["pktfilter"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing pktfilter for struct nvmlNvLinkUtilizationControl_t");
    }
    return nvLinkUtilizationControl;
}

// The following snippet is generated from write_deserializer_definition
nvmlBridgeChipInfo_t *nvmlBridgeChipInfo_tDeserializer(const YAML::Node &node)
{
    auto *bridgeChipInfo = reinterpret_cast<nvmlBridgeChipInfo_t *>(malloc(sizeof(nvmlBridgeChipInfo_t)));
    if (bridgeChipInfo == nullptr)
    {
        return nullptr;
    }
    memset(bridgeChipInfo, 0, sizeof(*bridgeChipInfo));
    if (node["type"])
    {
        // The following snippet is generated from write_deserializer_definition
        bridgeChipInfo->type = static_cast<nvmlBridgeChipType_t>(node["type"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing type for struct nvmlBridgeChipInfo_t");
    }
    if (node["fwVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        bridgeChipInfo->fwVersion = node["fwVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing fwVersion for struct nvmlBridgeChipInfo_t");
    }
    return bridgeChipInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlBridgeChipHierarchy_t *nvmlBridgeChipHierarchy_tDeserializer(const YAML::Node &node)
{
    auto *bridgeChipHierarchy = reinterpret_cast<nvmlBridgeChipHierarchy_t *>(malloc(sizeof(nvmlBridgeChipHierarchy_t)));
    if (bridgeChipHierarchy == nullptr)
    {
        return nullptr;
    }
    memset(bridgeChipHierarchy, 0, sizeof(*bridgeChipHierarchy));
    if (node["bridgeCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        bridgeChipHierarchy->bridgeCount = node["bridgeCount"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing bridgeCount for struct nvmlBridgeChipHierarchy_t");
    }
    if (node["bridgeChipInfo"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["bridgeChipInfo"].size(), sizeof(bridgeChipHierarchy->bridgeChipInfo) / sizeof(nvmlBridgeChipInfo_t));
        for (YAML::const_iterator it = node["bridgeChipInfo"].begin(); it != node["bridgeChipInfo"].end(); ++it)
        {
            auto *tmp = nvmlBridgeChipInfo_tDeserializer(*it);
            if (!tmp)
            {
                free(bridgeChipHierarchy);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&bridgeChipHierarchy->bridgeChipInfo[idx++], tmp, sizeof(nvmlBridgeChipInfo_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing bridgeChipInfo for struct nvmlBridgeChipHierarchy_t");
    }
    return bridgeChipHierarchy;
}

// The following snippet is generated from write_deserializer_definition
nvmlViolationTime_t *nvmlViolationTime_tDeserializer(const YAML::Node &node)
{
    auto *violationTime = reinterpret_cast<nvmlViolationTime_t *>(malloc(sizeof(nvmlViolationTime_t)));
    if (violationTime == nullptr)
    {
        return nullptr;
    }
    memset(violationTime, 0, sizeof(*violationTime));
    if (node["referenceTime"])
    {
        // The following snippet is generated from write_deserializer_definition
        violationTime->referenceTime = node["referenceTime"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing referenceTime for struct nvmlViolationTime_t");
    }
    if (node["violationTime"])
    {
        // The following snippet is generated from write_deserializer_definition
        violationTime->violationTime = node["violationTime"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing violationTime for struct nvmlViolationTime_t");
    }
    return violationTime;
}

// The following snippet is generated from write_deserializer_definition
nvmlClkMonFaultInfo_t *nvmlClkMonFaultInfo_tDeserializer(const YAML::Node &node)
{
    auto *clkMonFaultInfo = reinterpret_cast<nvmlClkMonFaultInfo_t *>(malloc(sizeof(nvmlClkMonFaultInfo_t)));
    if (clkMonFaultInfo == nullptr)
    {
        return nullptr;
    }
    memset(clkMonFaultInfo, 0, sizeof(*clkMonFaultInfo));
    if (node["clkApiDomain"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonFaultInfo->clkApiDomain = node["clkApiDomain"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing clkApiDomain for struct nvmlClkMonFaultInfo_t");
    }
    if (node["clkDomainFaultMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonFaultInfo->clkDomainFaultMask = node["clkDomainFaultMask"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing clkDomainFaultMask for struct nvmlClkMonFaultInfo_t");
    }
    return clkMonFaultInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlClkMonStatus_t *nvmlClkMonStatus_tDeserializer(const YAML::Node &node)
{
    auto *clkMonStatus = reinterpret_cast<nvmlClkMonStatus_t *>(malloc(sizeof(nvmlClkMonStatus_t)));
    if (clkMonStatus == nullptr)
    {
        return nullptr;
    }
    memset(clkMonStatus, 0, sizeof(*clkMonStatus));
    if (node["bGlobalStatus"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonStatus->bGlobalStatus = node["bGlobalStatus"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing bGlobalStatus for struct nvmlClkMonStatus_t");
    }
    if (node["clkMonListSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonStatus->clkMonListSize = node["clkMonListSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing clkMonListSize for struct nvmlClkMonStatus_t");
    }
    if (node["clkMonList"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["clkMonList"].size(), sizeof(clkMonStatus->clkMonList) / sizeof(nvmlClkMonFaultInfo_t));
        for (YAML::const_iterator it = node["clkMonList"].begin(); it != node["clkMonList"].end(); ++it)
        {
            auto *tmp = nvmlClkMonFaultInfo_tDeserializer(*it);
            if (!tmp)
            {
                free(clkMonStatus);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&clkMonStatus->clkMonList[idx++], tmp, sizeof(nvmlClkMonFaultInfo_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing clkMonList for struct nvmlClkMonStatus_t");
    }
    return clkMonStatus;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuProcessUtilizationSample_t *nvmlVgpuProcessUtilizationSample_tDeserializer(const YAML::Node &node)
{
    auto *vgpuProcessUtilizationSample = reinterpret_cast<nvmlVgpuProcessUtilizationSample_t *>(malloc(sizeof(nvmlVgpuProcessUtilizationSample_t)));
    if (vgpuProcessUtilizationSample == nullptr)
    {
        return nullptr;
    }
    memset(vgpuProcessUtilizationSample, 0, sizeof(*vgpuProcessUtilizationSample));
    if (node["vgpuInstance"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->vgpuInstance = static_cast<nvmlVgpuInstance_t>(node["vgpuInstance"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstance for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["processName"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto processName = node["processName"].as<std::string>();
        std::memcpy(&vgpuProcessUtilizationSample->processName, processName.data(), sizeof(vgpuProcessUtilizationSample->processName));
    }
    else
    {
        NVML_LOG_ERR("missing processName for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["timeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->timeStamp = node["timeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeStamp for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["smUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->smUtil = node["smUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing smUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["memUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->memUtil = node["memUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["encUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->encUtil = node["encUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["decUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->decUtil = node["decUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    return vgpuProcessUtilizationSample;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuLicenseExpiry_t *nvmlVgpuLicenseExpiry_tDeserializer(const YAML::Node &node)
{
    auto *vgpuLicenseExpiry = reinterpret_cast<nvmlVgpuLicenseExpiry_t *>(malloc(sizeof(nvmlVgpuLicenseExpiry_t)));
    if (vgpuLicenseExpiry == nullptr)
    {
        return nullptr;
    }
    memset(vgpuLicenseExpiry, 0, sizeof(*vgpuLicenseExpiry));
    if (node["year"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->year = node["year"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing year for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["month"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->month = node["month"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing month for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["day"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->day = node["day"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing day for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["hour"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->hour = node["hour"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing hour for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["min"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->min = node["min"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing min for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["sec"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->sec = node["sec"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing sec for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["status"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->status = node["status"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing status for struct nvmlVgpuLicenseExpiry_t");
    }
    return vgpuLicenseExpiry;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuLicenseInfo_t *nvmlVgpuLicenseInfo_tDeserializer(const YAML::Node &node)
{
    auto *vgpuLicenseInfo = reinterpret_cast<nvmlVgpuLicenseInfo_t *>(malloc(sizeof(nvmlVgpuLicenseInfo_t)));
    if (vgpuLicenseInfo == nullptr)
    {
        return nullptr;
    }
    memset(vgpuLicenseInfo, 0, sizeof(*vgpuLicenseInfo));
    if (node["isLicensed"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseInfo->isLicensed = node["isLicensed"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing isLicensed for struct nvmlVgpuLicenseInfo_t");
    }
    if (node["licenseExpiry"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlVgpuLicenseExpiry_tDeserializer(node["licenseExpiry"]);
        if (!tmp0)
        {
            free(vgpuLicenseInfo);
            return nullptr;
        }
        std::memcpy(&vgpuLicenseInfo->licenseExpiry, tmp0, sizeof(nvmlClkMonFaultInfo_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing licenseExpiry for struct nvmlVgpuLicenseInfo_t");
    }
    if (node["currentState"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseInfo->currentState = node["currentState"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing currentState for struct nvmlVgpuLicenseInfo_t");
    }
    return vgpuLicenseInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessUtilizationSample_t *nvmlProcessUtilizationSample_tDeserializer(const YAML::Node &node)
{
    auto *processUtilizationSample = reinterpret_cast<nvmlProcessUtilizationSample_t *>(malloc(sizeof(nvmlProcessUtilizationSample_t)));
    if (processUtilizationSample == nullptr)
    {
        return nullptr;
    }
    memset(processUtilizationSample, 0, sizeof(*processUtilizationSample));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessUtilizationSample_t");
    }
    if (node["timeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->timeStamp = node["timeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeStamp for struct nvmlProcessUtilizationSample_t");
    }
    if (node["smUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->smUtil = node["smUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing smUtil for struct nvmlProcessUtilizationSample_t");
    }
    if (node["memUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->memUtil = node["memUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memUtil for struct nvmlProcessUtilizationSample_t");
    }
    if (node["encUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->encUtil = node["encUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encUtil for struct nvmlProcessUtilizationSample_t");
    }
    if (node["decUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->decUtil = node["decUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decUtil for struct nvmlProcessUtilizationSample_t");
    }
    return processUtilizationSample;
}

// The following snippet is generated from write_deserializer_definition
nvmlGridLicenseExpiry_t *nvmlGridLicenseExpiry_tDeserializer(const YAML::Node &node)
{
    auto *gridLicenseExpiry = reinterpret_cast<nvmlGridLicenseExpiry_t *>(malloc(sizeof(nvmlGridLicenseExpiry_t)));
    if (gridLicenseExpiry == nullptr)
    {
        return nullptr;
    }
    memset(gridLicenseExpiry, 0, sizeof(*gridLicenseExpiry));
    if (node["year"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->year = node["year"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing year for struct nvmlGridLicenseExpiry_t");
    }
    if (node["month"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->month = node["month"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing month for struct nvmlGridLicenseExpiry_t");
    }
    if (node["day"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->day = node["day"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing day for struct nvmlGridLicenseExpiry_t");
    }
    if (node["hour"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->hour = node["hour"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing hour for struct nvmlGridLicenseExpiry_t");
    }
    if (node["min"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->min = node["min"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing min for struct nvmlGridLicenseExpiry_t");
    }
    if (node["sec"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->sec = node["sec"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing sec for struct nvmlGridLicenseExpiry_t");
    }
    if (node["status"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->status = node["status"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing status for struct nvmlGridLicenseExpiry_t");
    }
    return gridLicenseExpiry;
}

// The following snippet is generated from write_deserializer_definition
nvmlGridLicensableFeature_t *nvmlGridLicensableFeature_tDeserializer(const YAML::Node &node)
{
    auto *gridLicensableFeature = reinterpret_cast<nvmlGridLicensableFeature_t *>(malloc(sizeof(nvmlGridLicensableFeature_t)));
    if (gridLicensableFeature == nullptr)
    {
        return nullptr;
    }
    memset(gridLicensableFeature, 0, sizeof(*gridLicensableFeature));
    if (node["featureCode"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeature->featureCode = static_cast<nvmlGridLicenseFeatureCode_t>(node["featureCode"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing featureCode for struct nvmlGridLicensableFeature_t");
    }
    if (node["featureState"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeature->featureState = node["featureState"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing featureState for struct nvmlGridLicensableFeature_t");
    }
    if (node["licenseInfo"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto licenseInfo = node["licenseInfo"].as<std::string>();
        std::memcpy(&gridLicensableFeature->licenseInfo, licenseInfo.data(), sizeof(gridLicensableFeature->licenseInfo));
    }
    else
    {
        NVML_LOG_ERR("missing licenseInfo for struct nvmlGridLicensableFeature_t");
    }
    if (node["productName"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto productName = node["productName"].as<std::string>();
        std::memcpy(&gridLicensableFeature->productName, productName.data(), sizeof(gridLicensableFeature->productName));
    }
    else
    {
        NVML_LOG_ERR("missing productName for struct nvmlGridLicensableFeature_t");
    }
    if (node["featureEnabled"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeature->featureEnabled = node["featureEnabled"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing featureEnabled for struct nvmlGridLicensableFeature_t");
    }
    if (node["licenseExpiry"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlGridLicenseExpiry_tDeserializer(node["licenseExpiry"]);
        if (!tmp0)
        {
            free(gridLicensableFeature);
            return nullptr;
        }
        std::memcpy(&gridLicensableFeature->licenseExpiry, tmp0, sizeof(nvmlClkMonFaultInfo_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing licenseExpiry for struct nvmlGridLicensableFeature_t");
    }
    return gridLicensableFeature;
}

// The following snippet is generated from write_deserializer_definition
nvmlGridLicensableFeatures_t *nvmlGridLicensableFeatures_tDeserializer(const YAML::Node &node)
{
    auto *gridLicensableFeatures = reinterpret_cast<nvmlGridLicensableFeatures_t *>(malloc(sizeof(nvmlGridLicensableFeatures_t)));
    if (gridLicensableFeatures == nullptr)
    {
        return nullptr;
    }
    memset(gridLicensableFeatures, 0, sizeof(*gridLicensableFeatures));
    if (node["isGridLicenseSupported"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeatures->isGridLicenseSupported = node["isGridLicenseSupported"].as<int>();
    }
    else
    {
        NVML_LOG_ERR("missing isGridLicenseSupported for struct nvmlGridLicensableFeatures_t");
    }
    if (node["licensableFeaturesCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeatures->licensableFeaturesCount = node["licensableFeaturesCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing licensableFeaturesCount for struct nvmlGridLicensableFeatures_t");
    }
    if (node["gridLicensableFeatures"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["gridLicensableFeatures"].size(), sizeof(gridLicensableFeatures->gridLicensableFeatures) / sizeof(nvmlGridLicensableFeature_t));
        for (YAML::const_iterator it = node["gridLicensableFeatures"].begin(); it != node["gridLicensableFeatures"].end(); ++it)
        {
            auto *tmp = nvmlGridLicensableFeature_tDeserializer(*it);
            if (!tmp)
            {
                free(gridLicensableFeatures);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&gridLicensableFeatures->gridLicensableFeatures[idx++], tmp, sizeof(nvmlGridLicensableFeature_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing gridLicensableFeatures for struct nvmlGridLicensableFeatures_t");
    }
    return gridLicensableFeatures;
}

// The following snippet is generated from write_deserializer_definition
nvmlHwbcEntry_t *nvmlHwbcEntry_tDeserializer(const YAML::Node &node)
{
    auto *hwbcEntry = reinterpret_cast<nvmlHwbcEntry_t *>(malloc(sizeof(nvmlHwbcEntry_t)));
    if (hwbcEntry == nullptr)
    {
        return nullptr;
    }
    memset(hwbcEntry, 0, sizeof(*hwbcEntry));
    if (node["hwbcId"])
    {
        // The following snippet is generated from write_deserializer_definition
        hwbcEntry->hwbcId = node["hwbcId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hwbcId for struct nvmlHwbcEntry_t");
    }
    if (node["firmwareVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto firmwareVersion = node["firmwareVersion"].as<std::string>();
        std::memcpy(&hwbcEntry->firmwareVersion, firmwareVersion.data(), sizeof(hwbcEntry->firmwareVersion));
    }
    else
    {
        NVML_LOG_ERR("missing firmwareVersion for struct nvmlHwbcEntry_t");
    }
    return hwbcEntry;
}

// The following snippet is generated from write_deserializer_definition
nvmlLedState_t *nvmlLedState_tDeserializer(const YAML::Node &node)
{
    auto *ledState = reinterpret_cast<nvmlLedState_t *>(malloc(sizeof(nvmlLedState_t)));
    if (ledState == nullptr)
    {
        return nullptr;
    }
    memset(ledState, 0, sizeof(*ledState));
    if (node["cause"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto cause = node["cause"].as<std::string>();
        std::memcpy(&ledState->cause, cause.data(), sizeof(ledState->cause));
    }
    else
    {
        NVML_LOG_ERR("missing cause for struct nvmlLedState_t");
    }
    if (node["color"])
    {
        // The following snippet is generated from write_deserializer_definition
        ledState->color = static_cast<nvmlLedColor_t>(node["color"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing color for struct nvmlLedState_t");
    }
    return ledState;
}

// The following snippet is generated from write_deserializer_definition
nvmlUnitInfo_t *nvmlUnitInfo_tDeserializer(const YAML::Node &node)
{
    auto *unitInfo = reinterpret_cast<nvmlUnitInfo_t *>(malloc(sizeof(nvmlUnitInfo_t)));
    if (unitInfo == nullptr)
    {
        return nullptr;
    }
    memset(unitInfo, 0, sizeof(*unitInfo));
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&unitInfo->name, name.data(), sizeof(unitInfo->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlUnitInfo_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto id = node["id"].as<std::string>();
        std::memcpy(&unitInfo->id, id.data(), sizeof(unitInfo->id));
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlUnitInfo_t");
    }
    if (node["serial"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto serial = node["serial"].as<std::string>();
        std::memcpy(&unitInfo->serial, serial.data(), sizeof(unitInfo->serial));
    }
    else
    {
        NVML_LOG_ERR("missing serial for struct nvmlUnitInfo_t");
    }
    if (node["firmwareVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto firmwareVersion = node["firmwareVersion"].as<std::string>();
        std::memcpy(&unitInfo->firmwareVersion, firmwareVersion.data(), sizeof(unitInfo->firmwareVersion));
    }
    else
    {
        NVML_LOG_ERR("missing firmwareVersion for struct nvmlUnitInfo_t");
    }
    return unitInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlPSUInfo_t *nvmlPSUInfo_tDeserializer(const YAML::Node &node)
{
    auto *pSUInfo = reinterpret_cast<nvmlPSUInfo_t *>(malloc(sizeof(nvmlPSUInfo_t)));
    if (pSUInfo == nullptr)
    {
        return nullptr;
    }
    memset(pSUInfo, 0, sizeof(*pSUInfo));
    if (node["state"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto state = node["state"].as<std::string>();
        std::memcpy(&pSUInfo->state, state.data(), sizeof(pSUInfo->state));
    }
    else
    {
        NVML_LOG_ERR("missing state for struct nvmlPSUInfo_t");
    }
    if (node["current"])
    {
        // The following snippet is generated from write_deserializer_definition
        pSUInfo->current = node["current"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing current for struct nvmlPSUInfo_t");
    }
    if (node["voltage"])
    {
        // The following snippet is generated from write_deserializer_definition
        pSUInfo->voltage = node["voltage"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing voltage for struct nvmlPSUInfo_t");
    }
    if (node["power"])
    {
        // The following snippet is generated from write_deserializer_definition
        pSUInfo->power = node["power"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing power for struct nvmlPSUInfo_t");
    }
    return pSUInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlUnitFanInfo_t *nvmlUnitFanInfo_tDeserializer(const YAML::Node &node)
{
    auto *unitFanInfo = reinterpret_cast<nvmlUnitFanInfo_t *>(malloc(sizeof(nvmlUnitFanInfo_t)));
    if (unitFanInfo == nullptr)
    {
        return nullptr;
    }
    memset(unitFanInfo, 0, sizeof(*unitFanInfo));
    if (node["speed"])
    {
        // The following snippet is generated from write_deserializer_definition
        unitFanInfo->speed = node["speed"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing speed for struct nvmlUnitFanInfo_t");
    }
    if (node["state"])
    {
        // The following snippet is generated from write_deserializer_definition
        unitFanInfo->state = static_cast<nvmlFanState_t>(node["state"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing state for struct nvmlUnitFanInfo_t");
    }
    return unitFanInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlUnitFanSpeeds_t *nvmlUnitFanSpeeds_tDeserializer(const YAML::Node &node)
{
    auto *unitFanSpeeds = reinterpret_cast<nvmlUnitFanSpeeds_t *>(malloc(sizeof(nvmlUnitFanSpeeds_t)));
    if (unitFanSpeeds == nullptr)
    {
        return nullptr;
    }
    memset(unitFanSpeeds, 0, sizeof(*unitFanSpeeds));
    if (node["fans"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["fans"].size(), sizeof(unitFanSpeeds->fans) / sizeof(nvmlUnitFanInfo_t));
        for (YAML::const_iterator it = node["fans"].begin(); it != node["fans"].end(); ++it)
        {
            auto *tmp = nvmlUnitFanInfo_tDeserializer(*it);
            if (!tmp)
            {
                free(unitFanSpeeds);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&unitFanSpeeds->fans[idx++], tmp, sizeof(nvmlUnitFanInfo_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing fans for struct nvmlUnitFanSpeeds_t");
    }
    if (node["count"])
    {
        // The following snippet is generated from write_deserializer_definition
        unitFanSpeeds->count = node["count"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing count for struct nvmlUnitFanSpeeds_t");
    }
    return unitFanSpeeds;
}

// The following snippet is generated from write_deserializer_definition
nvmlAccountingStats_t *nvmlAccountingStats_tDeserializer(const YAML::Node &node)
{
    auto *accountingStats = reinterpret_cast<nvmlAccountingStats_t *>(malloc(sizeof(nvmlAccountingStats_t)));
    if (accountingStats == nullptr)
    {
        return nullptr;
    }
    memset(accountingStats, 0, sizeof(*accountingStats));
    if (node["gpuUtilization"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->gpuUtilization = node["gpuUtilization"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuUtilization for struct nvmlAccountingStats_t");
    }
    if (node["memoryUtilization"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->memoryUtilization = node["memoryUtilization"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memoryUtilization for struct nvmlAccountingStats_t");
    }
    if (node["maxMemoryUsage"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->maxMemoryUsage = node["maxMemoryUsage"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing maxMemoryUsage for struct nvmlAccountingStats_t");
    }
    if (node["time"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->time = node["time"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing time for struct nvmlAccountingStats_t");
    }
    if (node["startTime"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->startTime = node["startTime"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing startTime for struct nvmlAccountingStats_t");
    }
    if (node["isRunning"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->isRunning = node["isRunning"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isRunning for struct nvmlAccountingStats_t");
    }
    return accountingStats;
}

// The following snippet is generated from write_deserializer_definition
nvmlEncoderSessionInfo_t *nvmlEncoderSessionInfo_tDeserializer(const YAML::Node &node)
{
    auto *encoderSessionInfo = reinterpret_cast<nvmlEncoderSessionInfo_t *>(malloc(sizeof(nvmlEncoderSessionInfo_t)));
    if (encoderSessionInfo == nullptr)
    {
        return nullptr;
    }
    memset(encoderSessionInfo, 0, sizeof(*encoderSessionInfo));
    if (node["sessionId"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->sessionId = node["sessionId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionId for struct nvmlEncoderSessionInfo_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlEncoderSessionInfo_t");
    }
    if (node["vgpuInstance"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->vgpuInstance = static_cast<nvmlVgpuInstance_t>(node["vgpuInstance"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstance for struct nvmlEncoderSessionInfo_t");
    }
    if (node["codecType"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->codecType = static_cast<nvmlEncoderType_t>(node["codecType"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing codecType for struct nvmlEncoderSessionInfo_t");
    }
    if (node["hResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->hResolution = node["hResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hResolution for struct nvmlEncoderSessionInfo_t");
    }
    if (node["vResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->vResolution = node["vResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vResolution for struct nvmlEncoderSessionInfo_t");
    }
    if (node["averageFps"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->averageFps = node["averageFps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageFps for struct nvmlEncoderSessionInfo_t");
    }
    if (node["averageLatency"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->averageLatency = node["averageLatency"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageLatency for struct nvmlEncoderSessionInfo_t");
    }
    return encoderSessionInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlFBCStats_t *nvmlFBCStats_tDeserializer(const YAML::Node &node)
{
    auto *fBCStats = reinterpret_cast<nvmlFBCStats_t *>(malloc(sizeof(nvmlFBCStats_t)));
    if (fBCStats == nullptr)
    {
        return nullptr;
    }
    memset(fBCStats, 0, sizeof(*fBCStats));
    if (node["sessionsCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCStats->sessionsCount = node["sessionsCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionsCount for struct nvmlFBCStats_t");
    }
    if (node["averageFPS"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCStats->averageFPS = node["averageFPS"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageFPS for struct nvmlFBCStats_t");
    }
    if (node["averageLatency"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCStats->averageLatency = node["averageLatency"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageLatency for struct nvmlFBCStats_t");
    }
    return fBCStats;
}

// The following snippet is generated from write_deserializer_definition
nvmlFBCSessionInfo_t *nvmlFBCSessionInfo_tDeserializer(const YAML::Node &node)
{
    auto *fBCSessionInfo = reinterpret_cast<nvmlFBCSessionInfo_t *>(malloc(sizeof(nvmlFBCSessionInfo_t)));
    if (fBCSessionInfo == nullptr)
    {
        return nullptr;
    }
    memset(fBCSessionInfo, 0, sizeof(*fBCSessionInfo));
    if (node["sessionId"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->sessionId = node["sessionId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionId for struct nvmlFBCSessionInfo_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlFBCSessionInfo_t");
    }
    if (node["vgpuInstance"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->vgpuInstance = static_cast<nvmlVgpuInstance_t>(node["vgpuInstance"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstance for struct nvmlFBCSessionInfo_t");
    }
    if (node["displayOrdinal"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->displayOrdinal = node["displayOrdinal"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing displayOrdinal for struct nvmlFBCSessionInfo_t");
    }
    if (node["sessionType"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->sessionType = static_cast<nvmlFBCSessionType_t>(node["sessionType"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing sessionType for struct nvmlFBCSessionInfo_t");
    }
    if (node["sessionFlags"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->sessionFlags = node["sessionFlags"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionFlags for struct nvmlFBCSessionInfo_t");
    }
    if (node["hMaxResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->hMaxResolution = node["hMaxResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hMaxResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["vMaxResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->vMaxResolution = node["vMaxResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vMaxResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["hResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->hResolution = node["hResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["vResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->vResolution = node["vResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["averageFPS"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->averageFPS = node["averageFPS"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageFPS for struct nvmlFBCSessionInfo_t");
    }
    if (node["averageLatency"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->averageLatency = node["averageLatency"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageLatency for struct nvmlFBCSessionInfo_t");
    }
    return fBCSessionInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeSystemCaps_t *nvmlConfComputeSystemCaps_tDeserializer(const YAML::Node &node)
{
    auto *confComputeSystemCaps = reinterpret_cast<nvmlConfComputeSystemCaps_t *>(malloc(sizeof(nvmlConfComputeSystemCaps_t)));
    if (confComputeSystemCaps == nullptr)
    {
        return nullptr;
    }
    memset(confComputeSystemCaps, 0, sizeof(*confComputeSystemCaps));
    if (node["cpuCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemCaps->cpuCaps = node["cpuCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing cpuCaps for struct nvmlConfComputeSystemCaps_t");
    }
    if (node["gpusCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemCaps->gpusCaps = node["gpusCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpusCaps for struct nvmlConfComputeSystemCaps_t");
    }
    return confComputeSystemCaps;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeSystemState_t *nvmlConfComputeSystemState_tDeserializer(const YAML::Node &node)
{
    auto *confComputeSystemState = reinterpret_cast<nvmlConfComputeSystemState_t *>(malloc(sizeof(nvmlConfComputeSystemState_t)));
    if (confComputeSystemState == nullptr)
    {
        return nullptr;
    }
    memset(confComputeSystemState, 0, sizeof(*confComputeSystemState));
    if (node["environment"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemState->environment = node["environment"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing environment for struct nvmlConfComputeSystemState_t");
    }
    if (node["ccFeature"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemState->ccFeature = node["ccFeature"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ccFeature for struct nvmlConfComputeSystemState_t");
    }
    if (node["devMode"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemState->devMode = node["devMode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing devMode for struct nvmlConfComputeSystemState_t");
    }
    return confComputeSystemState;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeMemSizeInfo_t *nvmlConfComputeMemSizeInfo_tDeserializer(const YAML::Node &node)
{
    auto *confComputeMemSizeInfo = reinterpret_cast<nvmlConfComputeMemSizeInfo_t *>(malloc(sizeof(nvmlConfComputeMemSizeInfo_t)));
    if (confComputeMemSizeInfo == nullptr)
    {
        return nullptr;
    }
    memset(confComputeMemSizeInfo, 0, sizeof(*confComputeMemSizeInfo));
    if (node["protectedMemSizeKib"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeMemSizeInfo->protectedMemSizeKib = node["protectedMemSizeKib"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing protectedMemSizeKib for struct nvmlConfComputeMemSizeInfo_t");
    }
    if (node["unprotectedMemSizeKib"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeMemSizeInfo->unprotectedMemSizeKib = node["unprotectedMemSizeKib"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing unprotectedMemSizeKib for struct nvmlConfComputeMemSizeInfo_t");
    }
    return confComputeMemSizeInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeGpuCertificate_t *nvmlConfComputeGpuCertificate_tDeserializer(const YAML::Node &node)
{
    auto *confComputeGpuCertificate = reinterpret_cast<nvmlConfComputeGpuCertificate_t *>(malloc(sizeof(nvmlConfComputeGpuCertificate_t)));
    if (confComputeGpuCertificate == nullptr)
    {
        return nullptr;
    }
    memset(confComputeGpuCertificate, 0, sizeof(*confComputeGpuCertificate));
    if (node["certChainSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuCertificate->certChainSize = node["certChainSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing certChainSize for struct nvmlConfComputeGpuCertificate_t");
    }
    if (node["attestationCertChainSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuCertificate->attestationCertChainSize = node["attestationCertChainSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing attestationCertChainSize for struct nvmlConfComputeGpuCertificate_t");
    }
    if (node["certChain"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto certChain = node["certChain"].as<std::string>();
        std::memcpy(&confComputeGpuCertificate->certChain, certChain.data(), sizeof(confComputeGpuCertificate->certChain));
    }
    else
    {
        NVML_LOG_ERR("missing certChain for struct nvmlConfComputeGpuCertificate_t");
    }
    if (node["attestationCertChain"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto attestationCertChain = node["attestationCertChain"].as<std::string>();
        std::memcpy(&confComputeGpuCertificate->attestationCertChain, attestationCertChain.data(), sizeof(confComputeGpuCertificate->attestationCertChain));
    }
    else
    {
        NVML_LOG_ERR("missing attestationCertChain for struct nvmlConfComputeGpuCertificate_t");
    }
    return confComputeGpuCertificate;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeGpuAttestationReport_t *nvmlConfComputeGpuAttestationReport_tDeserializer(const YAML::Node &node)
{
    auto *confComputeGpuAttestationReport = reinterpret_cast<nvmlConfComputeGpuAttestationReport_t *>(malloc(sizeof(nvmlConfComputeGpuAttestationReport_t)));
    if (confComputeGpuAttestationReport == nullptr)
    {
        return nullptr;
    }
    memset(confComputeGpuAttestationReport, 0, sizeof(*confComputeGpuAttestationReport));
    if (node["isCecAttestationReportPresent"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuAttestationReport->isCecAttestationReportPresent = node["isCecAttestationReportPresent"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isCecAttestationReportPresent for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["attestationReportSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuAttestationReport->attestationReportSize = node["attestationReportSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing attestationReportSize for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["cecAttestationReportSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuAttestationReport->cecAttestationReportSize = node["cecAttestationReportSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing cecAttestationReportSize for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["nonce"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto nonce = node["nonce"].as<std::string>();
        std::memcpy(&confComputeGpuAttestationReport->nonce, nonce.data(), sizeof(confComputeGpuAttestationReport->nonce));
    }
    else
    {
        NVML_LOG_ERR("missing nonce for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["attestationReport"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto attestationReport = node["attestationReport"].as<std::string>();
        std::memcpy(&confComputeGpuAttestationReport->attestationReport, attestationReport.data(), sizeof(confComputeGpuAttestationReport->attestationReport));
    }
    else
    {
        NVML_LOG_ERR("missing attestationReport for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["cecAttestationReport"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto cecAttestationReport = node["cecAttestationReport"].as<std::string>();
        std::memcpy(&confComputeGpuAttestationReport->cecAttestationReport, cecAttestationReport.data(), sizeof(confComputeGpuAttestationReport->cecAttestationReport));
    }
    else
    {
        NVML_LOG_ERR("missing cecAttestationReport for struct nvmlConfComputeGpuAttestationReport_t");
    }
    return confComputeGpuAttestationReport;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuVersion_t *nvmlVgpuVersion_tDeserializer(const YAML::Node &node)
{
    auto *vgpuVersion = reinterpret_cast<nvmlVgpuVersion_t *>(malloc(sizeof(nvmlVgpuVersion_t)));
    if (vgpuVersion == nullptr)
    {
        return nullptr;
    }
    memset(vgpuVersion, 0, sizeof(*vgpuVersion));
    if (node["minVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuVersion->minVersion = node["minVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing minVersion for struct nvmlVgpuVersion_t");
    }
    if (node["maxVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuVersion->maxVersion = node["maxVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing maxVersion for struct nvmlVgpuVersion_t");
    }
    return vgpuVersion;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuMetadata_t *nvmlVgpuMetadata_tDeserializer(const YAML::Node &node)
{
    auto *vgpuMetadata = reinterpret_cast<nvmlVgpuMetadata_t *>(malloc(sizeof(nvmlVgpuMetadata_t)));
    if (vgpuMetadata == nullptr)
    {
        return nullptr;
    }
    memset(vgpuMetadata, 0, sizeof(*vgpuMetadata));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuMetadata_t");
    }
    if (node["revision"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->revision = node["revision"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing revision for struct nvmlVgpuMetadata_t");
    }
    if (node["guestInfoState"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->guestInfoState = static_cast<nvmlVgpuGuestInfoState_t>(node["guestInfoState"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing guestInfoState for struct nvmlVgpuMetadata_t");
    }
    if (node["guestDriverVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto guestDriverVersion = node["guestDriverVersion"].as<std::string>();
        std::memcpy(&vgpuMetadata->guestDriverVersion, guestDriverVersion.data(), sizeof(vgpuMetadata->guestDriverVersion));
    }
    else
    {
        NVML_LOG_ERR("missing guestDriverVersion for struct nvmlVgpuMetadata_t");
    }
    if (node["hostDriverVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto hostDriverVersion = node["hostDriverVersion"].as<std::string>();
        std::memcpy(&vgpuMetadata->hostDriverVersion, hostDriverVersion.data(), sizeof(vgpuMetadata->hostDriverVersion));
    }
    else
    {
        NVML_LOG_ERR("missing hostDriverVersion for struct nvmlVgpuMetadata_t");
    }
    if (node["vgpuVirtualizationCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->vgpuVirtualizationCaps = node["vgpuVirtualizationCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vgpuVirtualizationCaps for struct nvmlVgpuMetadata_t");
    }
    if (node["guestVgpuVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->guestVgpuVersion = node["guestVgpuVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing guestVgpuVersion for struct nvmlVgpuMetadata_t");
    }
    if (node["opaqueDataSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->opaqueDataSize = node["opaqueDataSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing opaqueDataSize for struct nvmlVgpuMetadata_t");
    }
    return vgpuMetadata;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuPgpuMetadata_t *nvmlVgpuPgpuMetadata_tDeserializer(const YAML::Node &node)
{
    auto *vgpuPgpuMetadata = reinterpret_cast<nvmlVgpuPgpuMetadata_t *>(malloc(sizeof(nvmlVgpuPgpuMetadata_t)));
    if (vgpuPgpuMetadata == nullptr)
    {
        return nullptr;
    }
    memset(vgpuPgpuMetadata, 0, sizeof(*vgpuPgpuMetadata));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["revision"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->revision = node["revision"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing revision for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["hostDriverVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto hostDriverVersion = node["hostDriverVersion"].as<std::string>();
        std::memcpy(&vgpuPgpuMetadata->hostDriverVersion, hostDriverVersion.data(), sizeof(vgpuPgpuMetadata->hostDriverVersion));
    }
    else
    {
        NVML_LOG_ERR("missing hostDriverVersion for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["pgpuVirtualizationCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->pgpuVirtualizationCaps = node["pgpuVirtualizationCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pgpuVirtualizationCaps for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["hostSupportedVgpuRange"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlVgpuVersion_tDeserializer(node["hostSupportedVgpuRange"]);
        if (!tmp0)
        {
            free(vgpuPgpuMetadata);
            return nullptr;
        }
        std::memcpy(&vgpuPgpuMetadata->hostSupportedVgpuRange, tmp0, sizeof(nvmlUnitFanInfo_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing hostSupportedVgpuRange for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["opaqueDataSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->opaqueDataSize = node["opaqueDataSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing opaqueDataSize for struct nvmlVgpuPgpuMetadata_t");
    }
    return vgpuPgpuMetadata;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuPgpuCompatibility_t *nvmlVgpuPgpuCompatibility_tDeserializer(const YAML::Node &node)
{
    auto *vgpuPgpuCompatibility = reinterpret_cast<nvmlVgpuPgpuCompatibility_t *>(malloc(sizeof(nvmlVgpuPgpuCompatibility_t)));
    if (vgpuPgpuCompatibility == nullptr)
    {
        return nullptr;
    }
    memset(vgpuPgpuCompatibility, 0, sizeof(*vgpuPgpuCompatibility));
    if (node["vgpuVmCompatibility"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuCompatibility->vgpuVmCompatibility = static_cast<nvmlVgpuVmCompatibility_t>(node["vgpuVmCompatibility"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuVmCompatibility for struct nvmlVgpuPgpuCompatibility_t");
    }
    if (node["compatibilityLimitCode"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuCompatibility->compatibilityLimitCode = static_cast<nvmlVgpuPgpuCompatibilityLimitCode_t>(node["compatibilityLimitCode"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing compatibilityLimitCode for struct nvmlVgpuPgpuCompatibility_t");
    }
    return vgpuPgpuCompatibility;
}

// The following snippet is generated from write_deserializer_definition
nvmlExcludedDeviceInfo_t *nvmlExcludedDeviceInfo_tDeserializer(const YAML::Node &node)
{
    auto *excludedDeviceInfo = reinterpret_cast<nvmlExcludedDeviceInfo_t *>(malloc(sizeof(nvmlExcludedDeviceInfo_t)));
    if (excludedDeviceInfo == nullptr)
    {
        return nullptr;
    }
    memset(excludedDeviceInfo, 0, sizeof(*excludedDeviceInfo));
    if (node["pciInfo"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlPciInfo_tDeserializer(node["pciInfo"]);
        if (!tmp0)
        {
            free(excludedDeviceInfo);
            return nullptr;
        }
        std::memcpy(&excludedDeviceInfo->pciInfo, tmp0, sizeof(nvmlUnitFanInfo_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing pciInfo for struct nvmlExcludedDeviceInfo_t");
    }
    if (node["uuid"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto uuid = node["uuid"].as<std::string>();
        std::memcpy(&excludedDeviceInfo->uuid, uuid.data(), sizeof(excludedDeviceInfo->uuid));
    }
    else
    {
        NVML_LOG_ERR("missing uuid for struct nvmlExcludedDeviceInfo_t");
    }
    return excludedDeviceInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuInstancePlacement_t *nvmlGpuInstancePlacement_tDeserializer(const YAML::Node &node)
{
    auto *gpuInstancePlacement = reinterpret_cast<nvmlGpuInstancePlacement_t *>(malloc(sizeof(nvmlGpuInstancePlacement_t)));
    if (gpuInstancePlacement == nullptr)
    {
        return nullptr;
    }
    memset(gpuInstancePlacement, 0, sizeof(*gpuInstancePlacement));
    if (node["start"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstancePlacement->start = node["start"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing start for struct nvmlGpuInstancePlacement_t");
    }
    if (node["size"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstancePlacement->size = node["size"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing size for struct nvmlGpuInstancePlacement_t");
    }
    return gpuInstancePlacement;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuInstanceProfileInfo_t *nvmlGpuInstanceProfileInfo_tDeserializer(const YAML::Node &node)
{
    auto *gpuInstanceProfileInfo = reinterpret_cast<nvmlGpuInstanceProfileInfo_t *>(malloc(sizeof(nvmlGpuInstanceProfileInfo_t)));
    if (gpuInstanceProfileInfo == nullptr)
    {
        return nullptr;
    }
    memset(gpuInstanceProfileInfo, 0, sizeof(*gpuInstanceProfileInfo));
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["isP2pSupported"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->isP2pSupported = node["isP2pSupported"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isP2pSupported for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["copyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->copyEngineCount = node["copyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing copyEngineCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["decoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->decoderCount = node["decoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decoderCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["encoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->encoderCount = node["encoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encoderCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["jpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->jpegCount = node["jpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing jpegCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["ofaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->ofaCount = node["ofaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ofaCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["memorySizeMB"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->memorySizeMB = node["memorySizeMB"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing memorySizeMB for struct nvmlGpuInstanceProfileInfo_t");
    }
    return gpuInstanceProfileInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuInstanceProfileInfo_v2_t *nvmlGpuInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node)
{
    auto *gpuInstanceProfileInfo_v2 = reinterpret_cast<nvmlGpuInstanceProfileInfo_v2_t *>(malloc(sizeof(nvmlGpuInstanceProfileInfo_v2_t)));
    if (gpuInstanceProfileInfo_v2 == nullptr)
    {
        return nullptr;
    }
    memset(gpuInstanceProfileInfo_v2, 0, sizeof(*gpuInstanceProfileInfo_v2));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["isP2pSupported"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->isP2pSupported = node["isP2pSupported"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isP2pSupported for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["copyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->copyEngineCount = node["copyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing copyEngineCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["decoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->decoderCount = node["decoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decoderCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["encoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->encoderCount = node["encoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encoderCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["jpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->jpegCount = node["jpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing jpegCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["ofaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->ofaCount = node["ofaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ofaCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["memorySizeMB"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->memorySizeMB = node["memorySizeMB"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing memorySizeMB for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&gpuInstanceProfileInfo_v2->name, name.data(), sizeof(gpuInstanceProfileInfo_v2->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    return gpuInstanceProfileInfo_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlComputeInstancePlacement_t *nvmlComputeInstancePlacement_tDeserializer(const YAML::Node &node)
{
    auto *computeInstancePlacement = reinterpret_cast<nvmlComputeInstancePlacement_t *>(malloc(sizeof(nvmlComputeInstancePlacement_t)));
    if (computeInstancePlacement == nullptr)
    {
        return nullptr;
    }
    memset(computeInstancePlacement, 0, sizeof(*computeInstancePlacement));
    if (node["start"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstancePlacement->start = node["start"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing start for struct nvmlComputeInstancePlacement_t");
    }
    if (node["size"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstancePlacement->size = node["size"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing size for struct nvmlComputeInstancePlacement_t");
    }
    return computeInstancePlacement;
}

// The following snippet is generated from write_deserializer_definition
nvmlComputeInstanceProfileInfo_t *nvmlComputeInstanceProfileInfo_tDeserializer(const YAML::Node &node)
{
    auto *computeInstanceProfileInfo = reinterpret_cast<nvmlComputeInstanceProfileInfo_t *>(malloc(sizeof(nvmlComputeInstanceProfileInfo_t)));
    if (computeInstanceProfileInfo == nullptr)
    {
        return nullptr;
    }
    memset(computeInstanceProfileInfo, 0, sizeof(*computeInstanceProfileInfo));
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedCopyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedCopyEngineCount = node["sharedCopyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedCopyEngineCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedDecoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedDecoderCount = node["sharedDecoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedDecoderCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedEncoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedEncoderCount = node["sharedEncoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedEncoderCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedJpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedJpegCount = node["sharedJpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedJpegCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedOfaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedOfaCount = node["sharedOfaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedOfaCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    return computeInstanceProfileInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlComputeInstanceProfileInfo_v2_t *nvmlComputeInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node)
{
    auto *computeInstanceProfileInfo_v2 = reinterpret_cast<nvmlComputeInstanceProfileInfo_v2_t *>(malloc(sizeof(nvmlComputeInstanceProfileInfo_v2_t)));
    if (computeInstanceProfileInfo_v2 == nullptr)
    {
        return nullptr;
    }
    memset(computeInstanceProfileInfo_v2, 0, sizeof(*computeInstanceProfileInfo_v2));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedCopyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedCopyEngineCount = node["sharedCopyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedCopyEngineCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedDecoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedDecoderCount = node["sharedDecoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedDecoderCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedEncoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedEncoderCount = node["sharedEncoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedEncoderCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedJpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedJpegCount = node["sharedJpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedJpegCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedOfaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedOfaCount = node["sharedOfaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedOfaCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&computeInstanceProfileInfo_v2->name, name.data(), sizeof(computeInstanceProfileInfo_v2->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    return computeInstanceProfileInfo_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpmSupport_t *nvmlGpmSupport_tDeserializer(const YAML::Node &node)
{
    auto *gpmSupport = reinterpret_cast<nvmlGpmSupport_t *>(malloc(sizeof(nvmlGpmSupport_t)));
    if (gpmSupport == nullptr)
    {
        return nullptr;
    }
    memset(gpmSupport, 0, sizeof(*gpmSupport));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpmSupport->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlGpmSupport_t");
    }
    if (node["isSupportedDevice"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpmSupport->isSupportedDevice = node["isSupportedDevice"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isSupportedDevice for struct nvmlGpmSupport_t");
    }
    return gpmSupport;
}

// The following snippet is generated from write_basic_type_parser
template <typename underlyType, typename resultType>
std::optional<NvmlFuncReturn> BasicTypeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto value = static_cast<resultType>(node["ReturnValue"].as<underlyType>());
    return NvmlFuncReturn(ret, std::move(value));
}

// The following snippet is generated from write_basic_key_type_parser
template <typename underlyType, typename resultType>
std::optional<InjectionArgument> BasicKeyTypeParser(const YAML::Node &node)
{
    if (!node)
    {
        return std::nullopt;
    }
    return static_cast<resultType>(node.as<underlyType>());
}

// The following snippet is generated from write_nvml_return_parser
std::optional<NvmlFuncReturn> NvmlReturnParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    return NvmlFuncReturn(ret);
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> PciInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *pciInfo = nvmlPciInfo_tDeserializer(node["ReturnValue"]);
    if (pciInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {pciInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> EccErrorCountsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *eccErrorCounts = nvmlEccErrorCounts_tDeserializer(node["ReturnValue"]);
    if (eccErrorCounts == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {eccErrorCounts, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> UtilizationParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *utilization = nvmlUtilization_tDeserializer(node["ReturnValue"]);
    if (utilization == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {utilization, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> MemoryParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *memory = nvmlMemory_tDeserializer(node["ReturnValue"]);
    if (memory == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {memory, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> Memory_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *memory_v2 = nvmlMemory_v2_tDeserializer(node["ReturnValue"]);
    if (memory_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {memory_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> BAR1MemoryParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *bAR1Memory = nvmlBAR1Memory_tDeserializer(node["ReturnValue"]);
    if (bAR1Memory == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {bAR1Memory, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessInfo_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processInfo_v1 = nvmlProcessInfo_v1_tDeserializer(node["ReturnValue"]);
    if (processInfo_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processInfo_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessInfo_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processInfo_v2 = nvmlProcessInfo_v2_tDeserializer(node["ReturnValue"]);
    if (processInfo_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processInfo_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processInfo = nvmlProcessInfo_tDeserializer(node["ReturnValue"]);
    if (processInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> DeviceAttributesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *deviceAttributes = nvmlDeviceAttributes_tDeserializer(node["ReturnValue"]);
    if (deviceAttributes == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {deviceAttributes, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> RowRemapperHistogramValuesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *rowRemapperHistogramValues = nvmlRowRemapperHistogramValues_tDeserializer(node["ReturnValue"]);
    if (rowRemapperHistogramValues == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {rowRemapperHistogramValues, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> NvLinkUtilizationControlParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *nvLinkUtilizationControl = nvmlNvLinkUtilizationControl_tDeserializer(node["ReturnValue"]);
    if (nvLinkUtilizationControl == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {nvLinkUtilizationControl, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> BridgeChipHierarchyParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *bridgeChipHierarchy = nvmlBridgeChipHierarchy_tDeserializer(node["ReturnValue"]);
    if (bridgeChipHierarchy == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {bridgeChipHierarchy, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ViolationTimeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *violationTime = nvmlViolationTime_tDeserializer(node["ReturnValue"]);
    if (violationTime == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {violationTime, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuProcessUtilizationSampleParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuProcessUtilizationSample = nvmlVgpuProcessUtilizationSample_tDeserializer(node["ReturnValue"]);
    if (vgpuProcessUtilizationSample == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuProcessUtilizationSample, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuLicenseInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuLicenseInfo = nvmlVgpuLicenseInfo_tDeserializer(node["ReturnValue"]);
    if (vgpuLicenseInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuLicenseInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessUtilizationSampleParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processUtilizationSample = nvmlProcessUtilizationSample_tDeserializer(node["ReturnValue"]);
    if (processUtilizationSample == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processUtilizationSample, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GridLicensableFeaturesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gridLicensableFeatures = nvmlGridLicensableFeatures_tDeserializer(node["ReturnValue"]);
    if (gridLicensableFeatures == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gridLicensableFeatures, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> HwbcEntryParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *hwbcEntry = nvmlHwbcEntry_tDeserializer(node["ReturnValue"]);
    if (hwbcEntry == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {hwbcEntry, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> LedStateParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *ledState = nvmlLedState_tDeserializer(node["ReturnValue"]);
    if (ledState == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {ledState, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> UnitInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *unitInfo = nvmlUnitInfo_tDeserializer(node["ReturnValue"]);
    if (unitInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {unitInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> PSUInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *pSUInfo = nvmlPSUInfo_tDeserializer(node["ReturnValue"]);
    if (pSUInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {pSUInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> UnitFanSpeedsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *unitFanSpeeds = nvmlUnitFanSpeeds_tDeserializer(node["ReturnValue"]);
    if (unitFanSpeeds == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {unitFanSpeeds, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> AccountingStatsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *accountingStats = nvmlAccountingStats_tDeserializer(node["ReturnValue"]);
    if (accountingStats == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {accountingStats, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> EncoderSessionInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *encoderSessionInfo = nvmlEncoderSessionInfo_tDeserializer(node["ReturnValue"]);
    if (encoderSessionInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {encoderSessionInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> FBCStatsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *fBCStats = nvmlFBCStats_tDeserializer(node["ReturnValue"]);
    if (fBCStats == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {fBCStats, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> FBCSessionInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *fBCSessionInfo = nvmlFBCSessionInfo_tDeserializer(node["ReturnValue"]);
    if (fBCSessionInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {fBCSessionInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ConfComputeSystemStateParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *confComputeSystemState = nvmlConfComputeSystemState_tDeserializer(node["ReturnValue"]);
    if (confComputeSystemState == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {confComputeSystemState, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuVersionParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuVersion = nvmlVgpuVersion_tDeserializer(node["ReturnValue"]);
    if (vgpuVersion == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuVersion, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuMetadataParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuMetadata = nvmlVgpuMetadata_tDeserializer(node["ReturnValue"]);
    if (vgpuMetadata == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuMetadata, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuPgpuMetadataParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuPgpuMetadata = nvmlVgpuPgpuMetadata_tDeserializer(node["ReturnValue"]);
    if (vgpuPgpuMetadata == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuPgpuMetadata, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuPgpuCompatibilityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuPgpuCompatibility = nvmlVgpuPgpuCompatibility_tDeserializer(node["ReturnValue"]);
    if (vgpuPgpuCompatibility == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuPgpuCompatibility, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ExcludedDeviceInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *excludedDeviceInfo = nvmlExcludedDeviceInfo_tDeserializer(node["ReturnValue"]);
    if (excludedDeviceInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {excludedDeviceInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuInstancePlacementParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuInstancePlacement = nvmlGpuInstancePlacement_tDeserializer(node["ReturnValue"]);
    if (gpuInstancePlacement == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuInstancePlacement, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuInstanceProfileInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuInstanceProfileInfo = nvmlGpuInstanceProfileInfo_tDeserializer(node["ReturnValue"]);
    if (gpuInstanceProfileInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuInstanceProfileInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuInstanceProfileInfo_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuInstanceProfileInfo_v2 = nvmlGpuInstanceProfileInfo_v2_tDeserializer(node["ReturnValue"]);
    if (gpuInstanceProfileInfo_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuInstanceProfileInfo_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ComputeInstanceProfileInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *computeInstanceProfileInfo = nvmlComputeInstanceProfileInfo_tDeserializer(node["ReturnValue"]);
    if (computeInstanceProfileInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {computeInstanceProfileInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ComputeInstanceProfileInfo_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *computeInstanceProfileInfo_v2 = nvmlComputeInstanceProfileInfo_v2_tDeserializer(node["ReturnValue"]);
    if (computeInstanceProfileInfo_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {computeInstanceProfileInfo_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpmSupportParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpmSupport = nvmlGpmSupport_tDeserializer(node["ReturnValue"]);
    if (gpmSupport == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpmSupport, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> MemoryAffinityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long *>(malloc(sizeof(unsigned long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    return NvmlFuncReturn(ret, {valPtr, size, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> CpuAffinityWithinScopeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long *>(malloc(sizeof(unsigned long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    return NvmlFuncReturn(ret, {valPtr, size, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> CpuAffinityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long *>(malloc(sizeof(unsigned long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    return NvmlFuncReturn(ret, {valPtr, size, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> SupportedGraphicsClocksParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned int>();
    }
        // The following snippet is generated from write_array_funcs_parser
    std::vector<InjectionArgument> args;
    args.emplace_back(idx);
    args.emplace_back(valPtr, idx, true);
    return NvmlFuncReturn(ret, args);
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> RetiredPagesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long long *>(malloc(sizeof(unsigned long long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    std::vector<InjectionArgument> args;
    args.emplace_back(idx);
    args.emplace_back(valPtr, idx, true);
    return NvmlFuncReturn(ret, args);
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> SupportedMemoryClocksParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = it->as<unsigned int>();
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> AutoBoostedClocksEnabledParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["isEnabled"].as<int>()));
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["defaultIsEnabled"].as<int>()));
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> PowerManagementLimitConstraintsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["minLimit"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["maxLimit"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> GpuOperationModeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(static_cast<nvmlGpuOperationMode_t>(node["ReturnValue"]["current"].as<int>()));
    args.emplace_back(static_cast<nvmlGpuOperationMode_t>(node["ReturnValue"]["pending"].as<int>()));
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> CudaComputeCapabilityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["major"].as<int>());
    args.emplace_back(node["ReturnValue"]["minor"].as<int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> EccModeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["current"].as<int>()));
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["pending"].as<int>()));
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> EncoderUtilizationParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["utilization"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["samplingPeriodUs"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> EncoderSessionsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlEncoderSessionInfo_t *>(malloc(sizeof(nvmlEncoderSessionInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlEncoderSessionInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlEncoderSessionInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> DecoderUtilizationParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["utilization"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["samplingPeriodUs"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> FBCSessionsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlFBCSessionInfo_t *>(malloc(sizeof(nvmlFBCSessionInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlFBCSessionInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlFBCSessionInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> DriverModelParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(static_cast<nvmlDriverModel_t>(node["ReturnValue"]["current"].as<int>()));
    args.emplace_back(static_cast<nvmlDriverModel_t>(node["ReturnValue"]["pending"].as<int>()));
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> ComputeRunningProcesses_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlProcessInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlProcessInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> GraphicsRunningProcesses_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlProcessInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlProcessInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> MPSComputeRunningProcesses_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlProcessInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlProcessInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> AccountingPidsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = it->as<unsigned int>();
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> NvLinkUtilizationCounterParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["rxcounter"].as<unsigned long long>());
    args.emplace_back(node["ReturnValue"]["txcounter"].as<unsigned long long>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> SupportedVgpusParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlVgpuTypeId_t *>(malloc(sizeof(nvmlVgpuTypeId_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = static_cast<nvmlVgpuTypeId_t>(it->as<int>());
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> CreatableVgpusParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlVgpuTypeId_t *>(malloc(sizeof(nvmlVgpuTypeId_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = static_cast<nvmlVgpuTypeId_t>(it->as<int>());
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> ClassParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["vgpuTypeClass"].as<char>());
    args.emplace_back(node["ReturnValue"]["size"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> NameParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["vgpuTypeName"].as<char>());
    args.emplace_back(node["ReturnValue"]["size"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> DeviceIDParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["deviceID"].as<unsigned long long>());
    args.emplace_back(node["ReturnValue"]["subsystemID"].as<unsigned long long>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> ResolutionParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["xdim"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["ydim"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> GpuPciIdParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["vgpuPciId"].as<char>());
    args.emplace_back(node["ReturnValue"]["length"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> MigModeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["currentMode"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["pendingMode"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_three_attrs_funcs_parser
std::optional<NvmlFuncReturn> EncoderStatsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    args.emplace_back(node["ReturnValue"]["sessionCount"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["averageFps"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["averageLatency"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

}

// The following snippet is generated from nvml_return_deserializer_cpp_writer
NvmlReturnDeserializer::NvmlReturnDeserializer()
{
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_deviceHandlers = {
        // The following snippet is generated from try_to_write_device_handler
        {"Attributes", DeviceAttributesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"Name", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"Brand", BasicTypeParser<int, nvmlBrandType_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"Index", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"Serial", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"CpuAffinity", CpuAffinityParser},
        // The following snippet is generated from try_to_write_device_handler
        {"UUID", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"MinorNumber", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"BoardPartNumber", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"InforomImageVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"InforomConfigurationChecksum", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"ValidateInforom", NvmlReturnParser},
        // The following snippet is generated from try_to_write_device_handler
        {"DisplayMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"DisplayActive", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"PersistenceMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"PciInfo", PciInfoParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MaxPcieLinkGeneration", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"MaxPcieLinkWidth", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrPcieLinkGeneration", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrPcieLinkWidth", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PcieReplayCounter", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedMemoryClocks", SupportedMemoryClocksParser},
        // The following snippet is generated from try_to_write_device_handler
        {"AutoBoostedClocksEnabled", AutoBoostedClocksEnabledParser},
        // The following snippet is generated from try_to_write_device_handler
        {"FanSpeed", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"NumFans", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PerformanceState", BasicTypeParser<int, nvmlPstates_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrentClocksEventReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrentClocksThrottleReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedClocksEventReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedClocksThrottleReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerState", BasicTypeParser<int, nvmlPstates_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementLimitConstraints", PowerManagementLimitConstraintsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementDefaultLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerUsage", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerMode", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedPowerModes", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"TotalEnergyConsumption", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"EnforcedPowerLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"GpuOperationMode", GpuOperationModeParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MemoryInfo", Memory_v2Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"ComputeMode", BasicTypeParser<int, nvmlComputeMode_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"CudaComputeCapability", CudaComputeCapabilityParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EccMode", EccModeParser},
        // The following snippet is generated from try_to_write_device_handler
        {"DefaultEccMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"BoardId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"MultiGpuBoard", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"UtilizationRates", UtilizationParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EncoderUtilization", EncoderUtilizationParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EncoderStats", EncoderStatsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EncoderSessions", EncoderSessionsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"DecoderUtilization", DecoderUtilizationParser},
        // The following snippet is generated from try_to_write_device_handler
        {"FBCStats", FBCStatsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"FBCSessions", FBCSessionsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"DriverModel", DriverModelParser},
        // The following snippet is generated from try_to_write_device_handler
        {"VbiosVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"BridgeChipInfo", BridgeChipHierarchyParser},
        // The following snippet is generated from try_to_write_device_handler
        {"ComputeRunningProcesses", ComputeRunningProcesses_v3Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"GraphicsRunningProcesses", GraphicsRunningProcesses_v3Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"MPSComputeRunningProcesses", MPSComputeRunningProcesses_v3Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"BAR1MemoryInfo", BAR1MemoryParser},
        // The following snippet is generated from try_to_write_device_handler
        {"IrqNum", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"NumGpuCores", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerSource", BasicTypeParser<int, nvmlPowerSource_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"MemoryBusWidth", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PcieLinkMaxSpeed", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PcieSpeed", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"AdaptiveClockInfoStatus", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"AccountingMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"AccountingPids", AccountingPidsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"AccountingBufferSize", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"RetiredPagesPendingStatus", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"RowRemapperHistogram", RowRemapperHistogramValuesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"Architecture", BasicTypeParser<int, nvmlDeviceArchitecture_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedEventTypes", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"VirtualizationMode", BasicTypeParser<int, nvmlGpuVirtualizationMode_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"HostVgpuMode", BasicTypeParser<int, nvmlHostVgpuMode_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"GridLicensableFeatures", GridLicensableFeaturesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedVgpus", SupportedVgpusParser},
        // The following snippet is generated from try_to_write_device_handler
        {"CreatableVgpus", CreatableVgpusParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MigMode", MigModeParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MigDeviceHandle", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"GpuInstanceId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"ComputeInstanceId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"MaxMigDeviceCount", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"BusType", BasicTypeParser<int, nvmlBusType_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"GpcClkVfOffset", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_device_handler
        {"MemClkVfOffset", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_device_handler
        {"QueryDeviceSupport", GpmSupportParser},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_deviceExtraKeyHandlers = {
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MemoryAffinity", {BasicKeyTypeParser<int, nvmlAffinityScope_t>, MemoryAffinityParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"CpuAffinityWithinScope", {BasicKeyTypeParser<int, nvmlAffinityScope_t>, CpuAffinityWithinScopeParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"InforomVersion", {BasicKeyTypeParser<int, nvmlInforomObject_t>, BasicTypeParser<std::string, std::string>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"PcieThroughput", {BasicKeyTypeParser<int, nvmlPcieUtilCounter_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"ClockInfo", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MaxClockInfo", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"ApplicationsClock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"DefaultApplicationsClock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MaxCustomerBoostClock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"SupportedGraphicsClocks", {BasicKeyTypeParser<unsigned int, unsigned int>, SupportedGraphicsClocksParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"FanSpeed", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"TargetFanSpeed", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"Temperature", {BasicKeyTypeParser<int, nvmlTemperatureSensors_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"TemperatureThreshold", {BasicKeyTypeParser<int, nvmlTemperatureThresholds_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"EncoderCapacity", {BasicKeyTypeParser<int, nvmlEncoderType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"APIRestriction", {BasicKeyTypeParser<int, nvmlRestrictedAPI_t>, BasicTypeParser<int, nvmlEnableState_t>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"ViolationStatus", {BasicKeyTypeParser<int, nvmlPerfPolicyType_t>, ViolationTimeParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"AccountingStats", {BasicKeyTypeParser<unsigned int, unsigned int>, AccountingStatsParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"RetiredPages", {BasicKeyTypeParser<int, nvmlPageRetirementCause_t>, RetiredPagesParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkState", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<int, nvmlEnableState_t>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkVersion", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkRemotePciInfo", {BasicKeyTypeParser<unsigned int, unsigned int>, PciInfoParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkRemoteDeviceType", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<int, nvmlIntNvLinkDeviceType_t>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MaxInstances", {BasicKeyTypeParser<int, nvmlVgpuTypeId_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"GpuInstanceProfileInfo", {BasicKeyTypeParser<unsigned int, unsigned int>, GpuInstanceProfileInfoParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"GpuInstanceProfileInfoV", {BasicKeyTypeParser<unsigned int, unsigned int>, GpuInstanceProfileInfo_v2Parser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"GpuInstanceRemainingCapacity", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_deviceThreeKeysHandlers = {
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"Clock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicKeyTypeParser<int, nvmlClockId_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"TotalEccErrors", {BasicKeyTypeParser<int, nvmlMemoryErrorType_t>, BasicKeyTypeParser<int, nvmlEccCounterType_t>, BasicTypeParser<unsigned long long, unsigned long long>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"DetailedEccErrors", {BasicKeyTypeParser<int, nvmlMemoryErrorType_t>, BasicKeyTypeParser<int, nvmlEccCounterType_t>, EccErrorCountsParser}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"NvLinkCapability", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<int, nvmlNvLinkCapability_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"NvLinkErrorCounter", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<int, nvmlNvLinkErrorCounter_t>, BasicTypeParser<unsigned long long, unsigned long long>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"NvLinkUtilizationCounter", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<unsigned int, unsigned int>, NvLinkUtilizationCounterParser}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_gpuInstanceHandlers = {
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_gpuInstanceExtraKeyHandlers = {
        // The following snippet is generated from try_to_write_gpu_instance_extra_key_handler
        {"ComputeInstanceRemainingCapacity", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_gpuInstanceThreeKeysHandlers = {
        // The following snippet is generated from try_to_write_gpu_instance_three_keys_handler
        {"ComputeInstanceProfileInfo", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<unsigned int, unsigned int>, ComputeInstanceProfileInfoParser}},
        // The following snippet is generated from try_to_write_gpu_instance_three_keys_handler
        {"ComputeInstanceProfileInfoV", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<unsigned int, unsigned int>, ComputeInstanceProfileInfo_v2Parser}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_computeInstanceHandlers = {
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_vgpuTypeHandlers = {
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"Class", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"Name", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"GpuInstanceProfileId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"DeviceID", DeviceIDParser},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"FramebufferSize", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"NumDisplayHeads", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"Resolution", ResolutionParser},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"License", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"FrameRateLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"MaxInstancesPerVm", BasicTypeParser<unsigned int, unsigned int>},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_vgpuTypeExtraKeyHandlers = {
        // The following snippet is generated from try_to_write_vgpu_type_extra_key_handler
        {"Capabilities", {BasicKeyTypeParser<int, nvmlVgpuCapability_t>, BasicTypeParser<unsigned int, unsigned int>}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_vgpuInstanceHandlers = {
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"MdevUUID", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"UUID", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"VmDriverVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FbUsage", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"LicenseStatus", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"Type", BasicTypeParser<int, nvmlVgpuTypeId_t>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FrameRateLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EccMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EncoderCapacity", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EncoderStats", EncoderStatsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EncoderSessions", EncoderSessionsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FBCStats", FBCStatsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FBCSessions", FBCSessionsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"GpuInstanceId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"GpuPciId", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"AccountingMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"AccountingPids", AccountingPidsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"AccountingStats", AccountingStatsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"LicenseInfo", VgpuLicenseInfoParser},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_generalHandlers = {
        // The following snippet is generated from try_to_write_general_handler
        {"DriverVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_general_handler
        {"NVMLVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_general_handler
        {"CudaDriverVersion", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_general_handler
        {"CudaDriverVersion_v2", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_general_handler
        {"Count", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_general_handler
        {"Count_v2", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_general_handler
        {"ExcludedDeviceCount", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_general_handler
        {"ConfComputeState", ConfComputeSystemStateParser},
    };
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::DeviceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_deviceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_deviceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::GpuInstanceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_gpuInstanceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_gpuInstanceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::ComputeInstanceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_computeInstanceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_computeInstanceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::VgpuTypeHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_vgpuTypeHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_vgpuTypeHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::VgpuInstanceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_vgpuInstanceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_vgpuInstanceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::GeneralHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_generalHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_generalHandlers[key](node);
}

// The following snippet is generated from write_extra_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::DeviceExtraKeyHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_deviceExtraKeyHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>> ret;
    auto &[keyParser, valueParser] = m_deviceExtraKeyHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key2Opt = keyParser(innerKey);
        if (!key2Opt)
        {
            return std::nullopt;
        }
        auto valOpt = valueParser(innerValue);
        if (!valOpt)
        {
            return std::nullopt;
        }
        ret.emplace_back(key2Opt.value(), valOpt.value());
    }
    return ret;
}

// The following snippet is generated from write_extra_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::GpuInstanceExtraKeyHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_gpuInstanceExtraKeyHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>> ret;
    auto &[keyParser, valueParser] = m_gpuInstanceExtraKeyHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key2Opt = keyParser(innerKey);
        if (!key2Opt)
        {
            return std::nullopt;
        }
        auto valOpt = valueParser(innerValue);
        if (!valOpt)
        {
            return std::nullopt;
        }
        ret.emplace_back(key2Opt.value(), valOpt.value());
    }
    return ret;
}

// The following snippet is generated from write_extra_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::VgpuTypeExtraKeyHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_vgpuTypeExtraKeyHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>> ret;
    auto &[keyParser, valueParser] = m_vgpuTypeExtraKeyHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key2Opt = keyParser(innerKey);
        if (!key2Opt)
        {
            return std::nullopt;
        }
        auto valOpt = valueParser(innerValue);
        if (!valOpt)
        {
            return std::nullopt;
        }
        ret.emplace_back(key2Opt.value(), valOpt.value());
    }
    return ret;
}

// The following snippet is generated from write_three_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::DeviceThreeKeysHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_deviceThreeKeysHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>> ret;
    auto &[key1Parser, key2Parser, valueParser] = m_deviceThreeKeysHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key1Opt = key1Parser(innerKey);
        if (!key1Opt)
        {
            return std::nullopt;
        }
        for (YAML::const_iterator layerThreeIt = innerValue.begin(); layerThreeIt != innerValue.end(); ++layerThreeIt)
        {
            YAML::Node layerThreeKey = layerThreeIt->first;
            YAML::Node layerThreeValue = layerThreeIt->second;
            auto key2Opt = key2Parser(layerThreeKey);
            if (!key2Opt)
            {
                return std::nullopt;
            }
            auto valOpt = valueParser(layerThreeValue);
            if (!valOpt)
            {
                return std::nullopt;
            }
            ret.emplace_back(key1Opt.value(), key2Opt.value(), valOpt.value());
        }
    }
    return ret;
}

// The following snippet is generated from write_three_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::GpuInstanceThreeKeysHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_gpuInstanceThreeKeysHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>> ret;
    auto &[key1Parser, key2Parser, valueParser] = m_gpuInstanceThreeKeysHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key1Opt = key1Parser(innerKey);
        if (!key1Opt)
        {
            return std::nullopt;
        }
        for (YAML::const_iterator layerThreeIt = innerValue.begin(); layerThreeIt != innerValue.end(); ++layerThreeIt)
        {
            YAML::Node layerThreeKey = layerThreeIt->first;
            YAML::Node layerThreeValue = layerThreeIt->second;
            auto key2Opt = key2Parser(layerThreeKey);
            if (!key2Opt)
            {
                return std::nullopt;
            }
            auto valOpt = valueParser(layerThreeValue);
            if (!valOpt)
            {
                return std::nullopt;
            }
            ret.emplace_back(key1Opt.value(), key2Opt.value(), valOpt.value());
        }
    }
    return ret;
}

