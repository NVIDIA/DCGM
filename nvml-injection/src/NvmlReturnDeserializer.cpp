/*
 * Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * NOTE: This code is auto-generated by generate_nvml_stubs.py
 * DO NOT EDIT MANUALLY
 */


// clang-format off
#pragma GCC diagnostic ignored "-Wunused-function"
#include "NvmlReturnDeserializer.h"

#include <functional>
#include <optional>
#include <unordered_map>

#include "nvml.h"
#include <yaml-cpp/yaml.h>
#include <yaml-cpp/node/node.h>

#include "NvmlLogging.h"
#include "NvmlFuncReturn.h"

namespace {

// The following snippet is generated from write_deserializer_declare
nvmlPciInfoExt_t *nvmlPciInfoExt_tDeserializer(const YAML::Node &node);
nvmlPciInfo_t *nvmlPciInfo_tDeserializer(const YAML::Node &node);
nvmlEccErrorCounts_t *nvmlEccErrorCounts_tDeserializer(const YAML::Node &node);
nvmlUtilization_t *nvmlUtilization_tDeserializer(const YAML::Node &node);
nvmlMemory_t *nvmlMemory_tDeserializer(const YAML::Node &node);
nvmlMemory_v2_t *nvmlMemory_v2_tDeserializer(const YAML::Node &node);
nvmlBAR1Memory_t *nvmlBAR1Memory_tDeserializer(const YAML::Node &node);
nvmlProcessInfo_v1_t *nvmlProcessInfo_v1_tDeserializer(const YAML::Node &node);
nvmlProcessInfo_t *nvmlProcessInfo_tDeserializer(const YAML::Node &node);
nvmlProcessDetail_v1_t *nvmlProcessDetail_v1_tDeserializer(const YAML::Node &node);
nvmlProcessDetailList_t *nvmlProcessDetailList_tDeserializer(const YAML::Node &node);
nvmlDeviceAttributes_t *nvmlDeviceAttributes_tDeserializer(const YAML::Node &node);
nvmlC2cModeInfo_v1_t *nvmlC2cModeInfo_v1_tDeserializer(const YAML::Node &node);
nvmlRowRemapperHistogramValues_t *nvmlRowRemapperHistogramValues_tDeserializer(const YAML::Node &node);
nvmlNvLinkUtilizationControl_t *nvmlNvLinkUtilizationControl_tDeserializer(const YAML::Node &node);
nvmlBridgeChipInfo_t *nvmlBridgeChipInfo_tDeserializer(const YAML::Node &node);
nvmlBridgeChipHierarchy_t *nvmlBridgeChipHierarchy_tDeserializer(const YAML::Node &node);
nvmlViolationTime_t *nvmlViolationTime_tDeserializer(const YAML::Node &node);
nvmlCoolerInfo_t *nvmlCoolerInfo_tDeserializer(const YAML::Node &node);
nvmlClkMonFaultInfo_t *nvmlClkMonFaultInfo_tDeserializer(const YAML::Node &node);
nvmlClkMonStatus_t *nvmlClkMonStatus_tDeserializer(const YAML::Node &node);
nvmlClockOffset_t *nvmlClockOffset_tDeserializer(const YAML::Node &node);
nvmlFanSpeedInfo_t *nvmlFanSpeedInfo_tDeserializer(const YAML::Node &node);
nvmlDevicePerfModes_t *nvmlDevicePerfModes_tDeserializer(const YAML::Node &node);
nvmlDeviceCurrentClockFreqs_t *nvmlDeviceCurrentClockFreqs_tDeserializer(const YAML::Node &node);
nvmlProcessUtilizationSample_t *nvmlProcessUtilizationSample_tDeserializer(const YAML::Node &node);
nvmlProcessUtilizationInfo_v1_t *nvmlProcessUtilizationInfo_v1_tDeserializer(const YAML::Node &node);
nvmlProcessesUtilizationInfo_t *nvmlProcessesUtilizationInfo_tDeserializer(const YAML::Node &node);
nvmlEccSramErrorStatus_t *nvmlEccSramErrorStatus_tDeserializer(const YAML::Node &node);
nvmlPlatformInfo_t *nvmlPlatformInfo_tDeserializer(const YAML::Node &node);
nvmlPowerValue_v2_t *nvmlPowerValue_v2_tDeserializer(const YAML::Node &node);
nvmlVgpuHeterogeneousMode_t *nvmlVgpuHeterogeneousMode_tDeserializer(const YAML::Node &node);
nvmlVgpuPlacementId_t *nvmlVgpuPlacementId_tDeserializer(const YAML::Node &node);
nvmlVgpuPlacementList_v1_t *nvmlVgpuPlacementList_v1_tDeserializer(const YAML::Node &node);
nvmlVgpuPlacementList_t *nvmlVgpuPlacementList_tDeserializer(const YAML::Node &node);
nvmlVgpuTypeBar1Info_t *nvmlVgpuTypeBar1Info_tDeserializer(const YAML::Node &node);
nvmlVgpuInstancesUtilizationInfo_t *nvmlVgpuInstancesUtilizationInfo_tDeserializer(const YAML::Node &node);
nvmlVgpuProcessUtilizationSample_t *nvmlVgpuProcessUtilizationSample_tDeserializer(const YAML::Node &node);
nvmlVgpuProcessUtilizationInfo_v1_t *nvmlVgpuProcessUtilizationInfo_v1_tDeserializer(const YAML::Node &node);
nvmlVgpuProcessesUtilizationInfo_t *nvmlVgpuProcessesUtilizationInfo_tDeserializer(const YAML::Node &node);
nvmlVgpuSchedulerLogEntry_t *nvmlVgpuSchedulerLogEntry_tDeserializer(const YAML::Node &node);
nvmlVgpuSchedulerLog_t *nvmlVgpuSchedulerLog_tDeserializer(const YAML::Node &node);
nvmlVgpuSchedulerGetState_t *nvmlVgpuSchedulerGetState_tDeserializer(const YAML::Node &node);
nvmlVgpuSchedulerSetState_t *nvmlVgpuSchedulerSetState_tDeserializer(const YAML::Node &node);
nvmlVgpuSchedulerCapabilities_t *nvmlVgpuSchedulerCapabilities_tDeserializer(const YAML::Node &node);
nvmlVgpuLicenseExpiry_t *nvmlVgpuLicenseExpiry_tDeserializer(const YAML::Node &node);
nvmlVgpuLicenseInfo_t *nvmlVgpuLicenseInfo_tDeserializer(const YAML::Node &node);
nvmlGridLicenseExpiry_t *nvmlGridLicenseExpiry_tDeserializer(const YAML::Node &node);
nvmlGridLicensableFeature_t *nvmlGridLicensableFeature_tDeserializer(const YAML::Node &node);
nvmlGridLicensableFeatures_t *nvmlGridLicensableFeatures_tDeserializer(const YAML::Node &node);
nvmlNvLinkPowerThres_t *nvmlNvLinkPowerThres_tDeserializer(const YAML::Node &node);
nvmlHwbcEntry_t *nvmlHwbcEntry_tDeserializer(const YAML::Node &node);
nvmlLedState_t *nvmlLedState_tDeserializer(const YAML::Node &node);
nvmlUnitInfo_t *nvmlUnitInfo_tDeserializer(const YAML::Node &node);
nvmlPSUInfo_t *nvmlPSUInfo_tDeserializer(const YAML::Node &node);
nvmlUnitFanInfo_t *nvmlUnitFanInfo_tDeserializer(const YAML::Node &node);
nvmlUnitFanSpeeds_t *nvmlUnitFanSpeeds_tDeserializer(const YAML::Node &node);
nvmlAccountingStats_t *nvmlAccountingStats_tDeserializer(const YAML::Node &node);
nvmlEncoderSessionInfo_t *nvmlEncoderSessionInfo_tDeserializer(const YAML::Node &node);
nvmlFBCStats_t *nvmlFBCStats_tDeserializer(const YAML::Node &node);
nvmlFBCSessionInfo_t *nvmlFBCSessionInfo_tDeserializer(const YAML::Node &node);
nvmlConfComputeSystemCaps_t *nvmlConfComputeSystemCaps_tDeserializer(const YAML::Node &node);
nvmlConfComputeSystemState_t *nvmlConfComputeSystemState_tDeserializer(const YAML::Node &node);
nvmlSystemConfComputeSettings_t *nvmlSystemConfComputeSettings_tDeserializer(const YAML::Node &node);
nvmlConfComputeMemSizeInfo_t *nvmlConfComputeMemSizeInfo_tDeserializer(const YAML::Node &node);
nvmlConfComputeGpuCertificate_t *nvmlConfComputeGpuCertificate_tDeserializer(const YAML::Node &node);
nvmlConfComputeGpuAttestationReport_t *nvmlConfComputeGpuAttestationReport_tDeserializer(const YAML::Node &node);
nvmlConfComputeSetKeyRotationThresholdInfo_v1_t *nvmlConfComputeSetKeyRotationThresholdInfo_v1_tDeserializer(const YAML::Node &node);
nvmlConfComputeGetKeyRotationThresholdInfo_v1_t *nvmlConfComputeGetKeyRotationThresholdInfo_v1_tDeserializer(const YAML::Node &node);
nvmlGpuFabricInfo_t *nvmlGpuFabricInfo_tDeserializer(const YAML::Node &node);
nvmlGpuFabricInfoV_t *nvmlGpuFabricInfoV_tDeserializer(const YAML::Node &node);
nvmlSystemDriverBranchInfo_t *nvmlSystemDriverBranchInfo_tDeserializer(const YAML::Node &node);
nvmlTemperature_t *nvmlTemperature_tDeserializer(const YAML::Node &node);
nvmlVgpuVersion_t *nvmlVgpuVersion_tDeserializer(const YAML::Node &node);
nvmlVgpuMetadata_t *nvmlVgpuMetadata_tDeserializer(const YAML::Node &node);
nvmlVgpuPgpuMetadata_t *nvmlVgpuPgpuMetadata_tDeserializer(const YAML::Node &node);
nvmlVgpuPgpuCompatibility_t *nvmlVgpuPgpuCompatibility_tDeserializer(const YAML::Node &node);
nvmlExcludedDeviceInfo_t *nvmlExcludedDeviceInfo_tDeserializer(const YAML::Node &node);
nvmlGpuInstancePlacement_t *nvmlGpuInstancePlacement_tDeserializer(const YAML::Node &node);
nvmlGpuInstanceProfileInfo_t *nvmlGpuInstanceProfileInfo_tDeserializer(const YAML::Node &node);
nvmlGpuInstanceProfileInfo_v2_t *nvmlGpuInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node);
nvmlGpuInstanceProfileInfo_v3_t *nvmlGpuInstanceProfileInfo_v3_tDeserializer(const YAML::Node &node);
nvmlComputeInstancePlacement_t *nvmlComputeInstancePlacement_tDeserializer(const YAML::Node &node);
nvmlComputeInstanceProfileInfo_t *nvmlComputeInstanceProfileInfo_tDeserializer(const YAML::Node &node);
nvmlComputeInstanceProfileInfo_v2_t *nvmlComputeInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node);
nvmlComputeInstanceProfileInfo_v3_t *nvmlComputeInstanceProfileInfo_v3_tDeserializer(const YAML::Node &node);
nvmlGpmSupport_t *nvmlGpmSupport_tDeserializer(const YAML::Node &node);
nvmlDeviceCapabilities_t *nvmlDeviceCapabilities_tDeserializer(const YAML::Node &node);
nvmlMask255_t *nvmlMask255_tDeserializer(const YAML::Node &node);
nvmlWorkloadPowerProfileInfo_t *nvmlWorkloadPowerProfileInfo_tDeserializer(const YAML::Node &node);
nvmlWorkloadPowerProfileProfilesInfo_t *nvmlWorkloadPowerProfileProfilesInfo_tDeserializer(const YAML::Node &node);
nvmlWorkloadPowerProfileCurrentProfiles_t *nvmlWorkloadPowerProfileCurrentProfiles_tDeserializer(const YAML::Node &node);
nvmlWorkloadPowerProfileRequestedProfiles_t *nvmlWorkloadPowerProfileRequestedProfiles_tDeserializer(const YAML::Node &node);

// The following snippet is generated from write_deserializer_definition
nvmlPciInfoExt_t *nvmlPciInfoExt_tDeserializer(const YAML::Node &node)
{
    auto *pciInfoExt = reinterpret_cast<nvmlPciInfoExt_t *>(malloc(sizeof(nvmlPciInfoExt_t)));
    if (pciInfoExt == nullptr)
    {
        return nullptr;
    }
    memset(pciInfoExt, 0, sizeof(*pciInfoExt));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlPciInfoExt_t");
    }
    if (node["domain"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->domain = node["domain"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing domain for struct nvmlPciInfoExt_t");
    }
    if (node["bus"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->bus = node["bus"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing bus for struct nvmlPciInfoExt_t");
    }
    if (node["device"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->device = node["device"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing device for struct nvmlPciInfoExt_t");
    }
    if (node["pciDeviceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->pciDeviceId = node["pciDeviceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pciDeviceId for struct nvmlPciInfoExt_t");
    }
    if (node["pciSubSystemId"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->pciSubSystemId = node["pciSubSystemId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pciSubSystemId for struct nvmlPciInfoExt_t");
    }
    if (node["baseClass"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->baseClass = node["baseClass"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing baseClass for struct nvmlPciInfoExt_t");
    }
    if (node["subClass"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfoExt->subClass = node["subClass"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing subClass for struct nvmlPciInfoExt_t");
    }
    if (node["busId"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto busId = node["busId"].as<std::string>();
        std::memcpy(&pciInfoExt->busId, busId.data(), sizeof(pciInfoExt->busId));
    }
    else
    {
        NVML_LOG_ERR("missing busId for struct nvmlPciInfoExt_t");
    }
    return pciInfoExt;
}

// The following snippet is generated from write_deserializer_definition
nvmlPciInfo_t *nvmlPciInfo_tDeserializer(const YAML::Node &node)
{
    auto *pciInfo = reinterpret_cast<nvmlPciInfo_t *>(malloc(sizeof(nvmlPciInfo_t)));
    if (pciInfo == nullptr)
    {
        return nullptr;
    }
    memset(pciInfo, 0, sizeof(*pciInfo));
    if (node["busIdLegacy"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto busIdLegacy = node["busIdLegacy"].as<std::string>();
        std::memcpy(&pciInfo->busIdLegacy, busIdLegacy.data(), sizeof(pciInfo->busIdLegacy));
    }
    else
    {
        NVML_LOG_ERR("missing busIdLegacy for struct nvmlPciInfo_t");
    }
    if (node["domain"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->domain = node["domain"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing domain for struct nvmlPciInfo_t");
    }
    if (node["bus"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->bus = node["bus"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing bus for struct nvmlPciInfo_t");
    }
    if (node["device"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->device = node["device"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing device for struct nvmlPciInfo_t");
    }
    if (node["pciDeviceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->pciDeviceId = node["pciDeviceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pciDeviceId for struct nvmlPciInfo_t");
    }
    if (node["pciSubSystemId"])
    {
        // The following snippet is generated from write_deserializer_definition
        pciInfo->pciSubSystemId = node["pciSubSystemId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pciSubSystemId for struct nvmlPciInfo_t");
    }
    if (node["busId"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto busId = node["busId"].as<std::string>();
        std::memcpy(&pciInfo->busId, busId.data(), sizeof(pciInfo->busId));
    }
    else
    {
        NVML_LOG_ERR("missing busId for struct nvmlPciInfo_t");
    }
    return pciInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlEccErrorCounts_t *nvmlEccErrorCounts_tDeserializer(const YAML::Node &node)
{
    auto *eccErrorCounts = reinterpret_cast<nvmlEccErrorCounts_t *>(malloc(sizeof(nvmlEccErrorCounts_t)));
    if (eccErrorCounts == nullptr)
    {
        return nullptr;
    }
    memset(eccErrorCounts, 0, sizeof(*eccErrorCounts));
    if (node["l1Cache"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->l1Cache = node["l1Cache"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing l1Cache for struct nvmlEccErrorCounts_t");
    }
    if (node["l2Cache"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->l2Cache = node["l2Cache"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing l2Cache for struct nvmlEccErrorCounts_t");
    }
    if (node["deviceMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->deviceMemory = node["deviceMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing deviceMemory for struct nvmlEccErrorCounts_t");
    }
    if (node["registerFile"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccErrorCounts->registerFile = node["registerFile"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing registerFile for struct nvmlEccErrorCounts_t");
    }
    return eccErrorCounts;
}

// The following snippet is generated from write_deserializer_definition
nvmlUtilization_t *nvmlUtilization_tDeserializer(const YAML::Node &node)
{
    auto *utilization = reinterpret_cast<nvmlUtilization_t *>(malloc(sizeof(nvmlUtilization_t)));
    if (utilization == nullptr)
    {
        return nullptr;
    }
    memset(utilization, 0, sizeof(*utilization));
    if (node["gpu"])
    {
        // The following snippet is generated from write_deserializer_definition
        utilization->gpu = node["gpu"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpu for struct nvmlUtilization_t");
    }
    if (node["memory"])
    {
        // The following snippet is generated from write_deserializer_definition
        utilization->memory = node["memory"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memory for struct nvmlUtilization_t");
    }
    return utilization;
}

// The following snippet is generated from write_deserializer_definition
nvmlMemory_t *nvmlMemory_tDeserializer(const YAML::Node &node)
{
    auto *memory = reinterpret_cast<nvmlMemory_t *>(malloc(sizeof(nvmlMemory_t)));
    if (memory == nullptr)
    {
        return nullptr;
    }
    memset(memory, 0, sizeof(*memory));
    if (node["total"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory->total = node["total"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing total for struct nvmlMemory_t");
    }
    if (node["free"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory->free = node["free"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing free for struct nvmlMemory_t");
    }
    if (node["used"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory->used = node["used"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing used for struct nvmlMemory_t");
    }
    return memory;
}

// The following snippet is generated from write_deserializer_definition
nvmlMemory_v2_t *nvmlMemory_v2_tDeserializer(const YAML::Node &node)
{
    auto *memory_v2 = reinterpret_cast<nvmlMemory_v2_t *>(malloc(sizeof(nvmlMemory_v2_t)));
    if (memory_v2 == nullptr)
    {
        return nullptr;
    }
    memset(memory_v2, 0, sizeof(*memory_v2));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->version = node["version"].as<unsigned int>();
    }
    if (node["total"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->total = node["total"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing total for struct nvmlMemory_v2_t");
    }
    if (node["reserved"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->reserved = node["reserved"].as<unsigned long long>();
    }
    if (node["free"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->free = node["free"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing free for struct nvmlMemory_v2_t");
    }
    if (node["used"])
    {
        // The following snippet is generated from write_deserializer_definition
        memory_v2->used = node["used"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing used for struct nvmlMemory_v2_t");
    }
    return memory_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlBAR1Memory_t *nvmlBAR1Memory_tDeserializer(const YAML::Node &node)
{
    auto *bAR1Memory = reinterpret_cast<nvmlBAR1Memory_t *>(malloc(sizeof(nvmlBAR1Memory_t)));
    if (bAR1Memory == nullptr)
    {
        return nullptr;
    }
    memset(bAR1Memory, 0, sizeof(*bAR1Memory));
    if (node["bar1Total"])
    {
        // The following snippet is generated from write_deserializer_definition
        bAR1Memory->bar1Total = node["bar1Total"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing bar1Total for struct nvmlBAR1Memory_t");
    }
    if (node["bar1Free"])
    {
        // The following snippet is generated from write_deserializer_definition
        bAR1Memory->bar1Free = node["bar1Free"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing bar1Free for struct nvmlBAR1Memory_t");
    }
    if (node["bar1Used"])
    {
        // The following snippet is generated from write_deserializer_definition
        bAR1Memory->bar1Used = node["bar1Used"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing bar1Used for struct nvmlBAR1Memory_t");
    }
    return bAR1Memory;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessInfo_v1_t *nvmlProcessInfo_v1_tDeserializer(const YAML::Node &node)
{
    auto *processInfo_v1 = reinterpret_cast<nvmlProcessInfo_v1_t *>(malloc(sizeof(nvmlProcessInfo_v1_t)));
    if (processInfo_v1 == nullptr)
    {
        return nullptr;
    }
    memset(processInfo_v1, 0, sizeof(*processInfo_v1));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v1->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessInfo_v1_t");
    }
    if (node["usedGpuMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo_v1->usedGpuMemory = node["usedGpuMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing usedGpuMemory for struct nvmlProcessInfo_v1_t");
    }
    return processInfo_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessInfo_t *nvmlProcessInfo_tDeserializer(const YAML::Node &node)
{
    auto *processInfo = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t)));
    if (processInfo == nullptr)
    {
        return nullptr;
    }
    memset(processInfo, 0, sizeof(*processInfo));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessInfo_t");
    }
    if (node["usedGpuMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->usedGpuMemory = node["usedGpuMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing usedGpuMemory for struct nvmlProcessInfo_t");
    }
    if (node["gpuInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->gpuInstanceId = node["gpuInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuInstanceId for struct nvmlProcessInfo_t");
    }
    if (node["computeInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processInfo->computeInstanceId = node["computeInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing computeInstanceId for struct nvmlProcessInfo_t");
    }
    return processInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessDetail_v1_t *nvmlProcessDetail_v1_tDeserializer(const YAML::Node &node)
{
    auto *processDetail_v1 = reinterpret_cast<nvmlProcessDetail_v1_t *>(malloc(sizeof(nvmlProcessDetail_v1_t)));
    if (processDetail_v1 == nullptr)
    {
        return nullptr;
    }
    memset(processDetail_v1, 0, sizeof(*processDetail_v1));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetail_v1->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessDetail_v1_t");
    }
    if (node["usedGpuMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetail_v1->usedGpuMemory = node["usedGpuMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing usedGpuMemory for struct nvmlProcessDetail_v1_t");
    }
    if (node["gpuInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetail_v1->gpuInstanceId = node["gpuInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuInstanceId for struct nvmlProcessDetail_v1_t");
    }
    if (node["computeInstanceId"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetail_v1->computeInstanceId = node["computeInstanceId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing computeInstanceId for struct nvmlProcessDetail_v1_t");
    }
    if (node["usedGpuCcProtectedMemory"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetail_v1->usedGpuCcProtectedMemory = node["usedGpuCcProtectedMemory"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing usedGpuCcProtectedMemory for struct nvmlProcessDetail_v1_t");
    }
    return processDetail_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessDetailList_t *nvmlProcessDetailList_tDeserializer(const YAML::Node &node)
{
    auto *processDetailList = reinterpret_cast<nvmlProcessDetailList_t *>(malloc(sizeof(nvmlProcessDetailList_t)));
    if (processDetailList == nullptr)
    {
        return nullptr;
    }
    memset(processDetailList, 0, sizeof(*processDetailList));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetailList->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlProcessDetailList_t");
    }
    if (node["mode"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetailList->mode = node["mode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing mode for struct nvmlProcessDetailList_t");
    }
    if (node["numProcArrayEntries"])
    {
        // The following snippet is generated from write_deserializer_definition
        processDetailList->numProcArrayEntries = node["numProcArrayEntries"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing numProcArrayEntries for struct nvmlProcessDetailList_t");
    }
    if (node["procArray"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlProcessDetail_v1_tDeserializer(node["procArray"]);
        if (!tmp0)
        {
            free(processDetailList);
            return nullptr;
        }
        std::memcpy(processDetailList->procArray, tmp0, sizeof(nvmlProcessDetail_v1_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing procArray for struct nvmlProcessDetailList_t");
    }
    return processDetailList;
}

// The following snippet is generated from write_deserializer_definition
nvmlDeviceAttributes_t *nvmlDeviceAttributes_tDeserializer(const YAML::Node &node)
{
    auto *deviceAttributes = reinterpret_cast<nvmlDeviceAttributes_t *>(malloc(sizeof(nvmlDeviceAttributes_t)));
    if (deviceAttributes == nullptr)
    {
        return nullptr;
    }
    memset(deviceAttributes, 0, sizeof(*deviceAttributes));
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedCopyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedCopyEngineCount = node["sharedCopyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedCopyEngineCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedDecoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedDecoderCount = node["sharedDecoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedDecoderCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedEncoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedEncoderCount = node["sharedEncoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedEncoderCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedJpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedJpegCount = node["sharedJpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedJpegCount for struct nvmlDeviceAttributes_t");
    }
    if (node["sharedOfaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->sharedOfaCount = node["sharedOfaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedOfaCount for struct nvmlDeviceAttributes_t");
    }
    if (node["gpuInstanceSliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->gpuInstanceSliceCount = node["gpuInstanceSliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuInstanceSliceCount for struct nvmlDeviceAttributes_t");
    }
    if (node["computeInstanceSliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->computeInstanceSliceCount = node["computeInstanceSliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing computeInstanceSliceCount for struct nvmlDeviceAttributes_t");
    }
    if (node["memorySizeMB"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceAttributes->memorySizeMB = node["memorySizeMB"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing memorySizeMB for struct nvmlDeviceAttributes_t");
    }
    return deviceAttributes;
}

// The following snippet is generated from write_deserializer_definition
nvmlC2cModeInfo_v1_t *nvmlC2cModeInfo_v1_tDeserializer(const YAML::Node &node)
{
    auto *c2cModeInfo_v1 = reinterpret_cast<nvmlC2cModeInfo_v1_t *>(malloc(sizeof(nvmlC2cModeInfo_v1_t)));
    if (c2cModeInfo_v1 == nullptr)
    {
        return nullptr;
    }
    memset(c2cModeInfo_v1, 0, sizeof(*c2cModeInfo_v1));
    if (node["isC2cEnabled"])
    {
        // The following snippet is generated from write_deserializer_definition
        c2cModeInfo_v1->isC2cEnabled = node["isC2cEnabled"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isC2cEnabled for struct nvmlC2cModeInfo_v1_t");
    }
    return c2cModeInfo_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlRowRemapperHistogramValues_t *nvmlRowRemapperHistogramValues_tDeserializer(const YAML::Node &node)
{
    auto *rowRemapperHistogramValues = reinterpret_cast<nvmlRowRemapperHistogramValues_t *>(malloc(sizeof(nvmlRowRemapperHistogramValues_t)));
    if (rowRemapperHistogramValues == nullptr)
    {
        return nullptr;
    }
    memset(rowRemapperHistogramValues, 0, sizeof(*rowRemapperHistogramValues));
    if (node["max"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->max = node["max"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing max for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["high"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->high = node["high"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing high for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["partial"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->partial = node["partial"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing partial for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["low"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->low = node["low"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing low for struct nvmlRowRemapperHistogramValues_t");
    }
    if (node["none"])
    {
        // The following snippet is generated from write_deserializer_definition
        rowRemapperHistogramValues->none = node["none"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing none for struct nvmlRowRemapperHistogramValues_t");
    }
    return rowRemapperHistogramValues;
}

// The following snippet is generated from write_deserializer_definition
nvmlNvLinkUtilizationControl_t *nvmlNvLinkUtilizationControl_tDeserializer(const YAML::Node &node)
{
    auto *nvLinkUtilizationControl = reinterpret_cast<nvmlNvLinkUtilizationControl_t *>(malloc(sizeof(nvmlNvLinkUtilizationControl_t)));
    if (nvLinkUtilizationControl == nullptr)
    {
        return nullptr;
    }
    memset(nvLinkUtilizationControl, 0, sizeof(*nvLinkUtilizationControl));
    if (node["units"])
    {
        // The following snippet is generated from write_deserializer_definition
        nvLinkUtilizationControl->units = static_cast<nvmlNvLinkUtilizationCountUnits_t>(node["units"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing units for struct nvmlNvLinkUtilizationControl_t");
    }
    if (node["pktfilter"])
    {
        // The following snippet is generated from write_deserializer_definition
        nvLinkUtilizationControl->pktfilter = static_cast<nvmlNvLinkUtilizationCountPktTypes_t>(node["pktfilter"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing pktfilter for struct nvmlNvLinkUtilizationControl_t");
    }
    return nvLinkUtilizationControl;
}

// The following snippet is generated from write_deserializer_definition
nvmlBridgeChipInfo_t *nvmlBridgeChipInfo_tDeserializer(const YAML::Node &node)
{
    auto *bridgeChipInfo = reinterpret_cast<nvmlBridgeChipInfo_t *>(malloc(sizeof(nvmlBridgeChipInfo_t)));
    if (bridgeChipInfo == nullptr)
    {
        return nullptr;
    }
    memset(bridgeChipInfo, 0, sizeof(*bridgeChipInfo));
    if (node["type"])
    {
        // The following snippet is generated from write_deserializer_definition
        bridgeChipInfo->type = static_cast<nvmlBridgeChipType_t>(node["type"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing type for struct nvmlBridgeChipInfo_t");
    }
    if (node["fwVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        bridgeChipInfo->fwVersion = node["fwVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing fwVersion for struct nvmlBridgeChipInfo_t");
    }
    return bridgeChipInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlBridgeChipHierarchy_t *nvmlBridgeChipHierarchy_tDeserializer(const YAML::Node &node)
{
    auto *bridgeChipHierarchy = reinterpret_cast<nvmlBridgeChipHierarchy_t *>(malloc(sizeof(nvmlBridgeChipHierarchy_t)));
    if (bridgeChipHierarchy == nullptr)
    {
        return nullptr;
    }
    memset(bridgeChipHierarchy, 0, sizeof(*bridgeChipHierarchy));
    if (node["bridgeCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        bridgeChipHierarchy->bridgeCount = node["bridgeCount"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing bridgeCount for struct nvmlBridgeChipHierarchy_t");
    }
    if (node["bridgeChipInfo"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["bridgeChipInfo"].size(), sizeof(bridgeChipHierarchy->bridgeChipInfo) / sizeof(nvmlBridgeChipInfo_t));
        for (YAML::const_iterator it = node["bridgeChipInfo"].begin(); it != node["bridgeChipInfo"].end(); ++it)
        {
            auto *tmp = nvmlBridgeChipInfo_tDeserializer(*it);
            if (!tmp)
            {
                free(bridgeChipHierarchy);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&bridgeChipHierarchy->bridgeChipInfo[idx++], tmp, sizeof(nvmlBridgeChipInfo_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing bridgeChipInfo for struct nvmlBridgeChipHierarchy_t");
    }
    return bridgeChipHierarchy;
}

// The following snippet is generated from write_deserializer_definition
nvmlViolationTime_t *nvmlViolationTime_tDeserializer(const YAML::Node &node)
{
    auto *violationTime = reinterpret_cast<nvmlViolationTime_t *>(malloc(sizeof(nvmlViolationTime_t)));
    if (violationTime == nullptr)
    {
        return nullptr;
    }
    memset(violationTime, 0, sizeof(*violationTime));
    if (node["referenceTime"])
    {
        // The following snippet is generated from write_deserializer_definition
        violationTime->referenceTime = node["referenceTime"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing referenceTime for struct nvmlViolationTime_t");
    }
    if (node["violationTime"])
    {
        // The following snippet is generated from write_deserializer_definition
        violationTime->violationTime = node["violationTime"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing violationTime for struct nvmlViolationTime_t");
    }
    return violationTime;
}

// The following snippet is generated from write_deserializer_definition
nvmlCoolerInfo_t *nvmlCoolerInfo_tDeserializer(const YAML::Node &node)
{
    auto *coolerInfo = reinterpret_cast<nvmlCoolerInfo_t *>(malloc(sizeof(nvmlCoolerInfo_t)));
    if (coolerInfo == nullptr)
    {
        return nullptr;
    }
    memset(coolerInfo, 0, sizeof(*coolerInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        coolerInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlCoolerInfo_t");
    }
    if (node["index"])
    {
        // The following snippet is generated from write_deserializer_definition
        coolerInfo->index = node["index"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing index for struct nvmlCoolerInfo_t");
    }
    if (node["signalType"])
    {
        // The following snippet is generated from write_deserializer_definition
        coolerInfo->signalType = static_cast<nvmlCoolerControl_t>(node["signalType"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing signalType for struct nvmlCoolerInfo_t");
    }
    if (node["target"])
    {
        // The following snippet is generated from write_deserializer_definition
        coolerInfo->target = static_cast<nvmlCoolerTarget_t>(node["target"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing target for struct nvmlCoolerInfo_t");
    }
    return coolerInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlClkMonFaultInfo_t *nvmlClkMonFaultInfo_tDeserializer(const YAML::Node &node)
{
    auto *clkMonFaultInfo = reinterpret_cast<nvmlClkMonFaultInfo_t *>(malloc(sizeof(nvmlClkMonFaultInfo_t)));
    if (clkMonFaultInfo == nullptr)
    {
        return nullptr;
    }
    memset(clkMonFaultInfo, 0, sizeof(*clkMonFaultInfo));
    if (node["clkApiDomain"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonFaultInfo->clkApiDomain = node["clkApiDomain"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing clkApiDomain for struct nvmlClkMonFaultInfo_t");
    }
    if (node["clkDomainFaultMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonFaultInfo->clkDomainFaultMask = node["clkDomainFaultMask"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing clkDomainFaultMask for struct nvmlClkMonFaultInfo_t");
    }
    return clkMonFaultInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlClkMonStatus_t *nvmlClkMonStatus_tDeserializer(const YAML::Node &node)
{
    auto *clkMonStatus = reinterpret_cast<nvmlClkMonStatus_t *>(malloc(sizeof(nvmlClkMonStatus_t)));
    if (clkMonStatus == nullptr)
    {
        return nullptr;
    }
    memset(clkMonStatus, 0, sizeof(*clkMonStatus));
    if (node["bGlobalStatus"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonStatus->bGlobalStatus = node["bGlobalStatus"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing bGlobalStatus for struct nvmlClkMonStatus_t");
    }
    if (node["clkMonListSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        clkMonStatus->clkMonListSize = node["clkMonListSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing clkMonListSize for struct nvmlClkMonStatus_t");
    }
    if (node["clkMonList"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["clkMonList"].size(), sizeof(clkMonStatus->clkMonList) / sizeof(nvmlClkMonFaultInfo_t));
        for (YAML::const_iterator it = node["clkMonList"].begin(); it != node["clkMonList"].end(); ++it)
        {
            auto *tmp = nvmlClkMonFaultInfo_tDeserializer(*it);
            if (!tmp)
            {
                free(clkMonStatus);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&clkMonStatus->clkMonList[idx++], tmp, sizeof(nvmlClkMonFaultInfo_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing clkMonList for struct nvmlClkMonStatus_t");
    }
    return clkMonStatus;
}

// The following snippet is generated from write_deserializer_definition
nvmlClockOffset_t *nvmlClockOffset_tDeserializer(const YAML::Node &node)
{
    auto *clockOffset = reinterpret_cast<nvmlClockOffset_t *>(malloc(sizeof(nvmlClockOffset_t)));
    if (clockOffset == nullptr)
    {
        return nullptr;
    }
    memset(clockOffset, 0, sizeof(*clockOffset));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        clockOffset->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlClockOffset_t");
    }
    if (node["type"])
    {
        // The following snippet is generated from write_deserializer_definition
        clockOffset->type = static_cast<nvmlClockType_t>(node["type"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing type for struct nvmlClockOffset_t");
    }
    if (node["pstate"])
    {
        // The following snippet is generated from write_deserializer_definition
        clockOffset->pstate = static_cast<nvmlPstates_t>(node["pstate"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing pstate for struct nvmlClockOffset_t");
    }
    if (node["clockOffsetMHz"])
    {
        // The following snippet is generated from write_deserializer_definition
        clockOffset->clockOffsetMHz = node["clockOffsetMHz"].as<int>();
    }
    else
    {
        NVML_LOG_ERR("missing clockOffsetMHz for struct nvmlClockOffset_t");
    }
    if (node["minClockOffsetMHz"])
    {
        // The following snippet is generated from write_deserializer_definition
        clockOffset->minClockOffsetMHz = node["minClockOffsetMHz"].as<int>();
    }
    else
    {
        NVML_LOG_ERR("missing minClockOffsetMHz for struct nvmlClockOffset_t");
    }
    if (node["maxClockOffsetMHz"])
    {
        // The following snippet is generated from write_deserializer_definition
        clockOffset->maxClockOffsetMHz = node["maxClockOffsetMHz"].as<int>();
    }
    else
    {
        NVML_LOG_ERR("missing maxClockOffsetMHz for struct nvmlClockOffset_t");
    }
    return clockOffset;
}

// The following snippet is generated from write_deserializer_definition
nvmlFanSpeedInfo_t *nvmlFanSpeedInfo_tDeserializer(const YAML::Node &node)
{
    auto *fanSpeedInfo = reinterpret_cast<nvmlFanSpeedInfo_t *>(malloc(sizeof(nvmlFanSpeedInfo_t)));
    if (fanSpeedInfo == nullptr)
    {
        return nullptr;
    }
    memset(fanSpeedInfo, 0, sizeof(*fanSpeedInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        fanSpeedInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlFanSpeedInfo_t");
    }
    if (node["fan"])
    {
        // The following snippet is generated from write_deserializer_definition
        fanSpeedInfo->fan = node["fan"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing fan for struct nvmlFanSpeedInfo_t");
    }
    if (node["speed"])
    {
        // The following snippet is generated from write_deserializer_definition
        fanSpeedInfo->speed = node["speed"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing speed for struct nvmlFanSpeedInfo_t");
    }
    return fanSpeedInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlDevicePerfModes_t *nvmlDevicePerfModes_tDeserializer(const YAML::Node &node)
{
    auto *devicePerfModes = reinterpret_cast<nvmlDevicePerfModes_t *>(malloc(sizeof(nvmlDevicePerfModes_t)));
    if (devicePerfModes == nullptr)
    {
        return nullptr;
    }
    memset(devicePerfModes, 0, sizeof(*devicePerfModes));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        devicePerfModes->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlDevicePerfModes_t");
    }
    if (node["str"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto str = node["str"].as<std::string>();
        std::memcpy(&devicePerfModes->str, str.data(), sizeof(devicePerfModes->str));
    }
    else
    {
        NVML_LOG_ERR("missing str for struct nvmlDevicePerfModes_t");
    }
    return devicePerfModes;
}

// The following snippet is generated from write_deserializer_definition
nvmlDeviceCurrentClockFreqs_t *nvmlDeviceCurrentClockFreqs_tDeserializer(const YAML::Node &node)
{
    auto *deviceCurrentClockFreqs = reinterpret_cast<nvmlDeviceCurrentClockFreqs_t *>(malloc(sizeof(nvmlDeviceCurrentClockFreqs_t)));
    if (deviceCurrentClockFreqs == nullptr)
    {
        return nullptr;
    }
    memset(deviceCurrentClockFreqs, 0, sizeof(*deviceCurrentClockFreqs));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceCurrentClockFreqs->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlDeviceCurrentClockFreqs_t");
    }
    if (node["str"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto str = node["str"].as<std::string>();
        std::memcpy(&deviceCurrentClockFreqs->str, str.data(), sizeof(deviceCurrentClockFreqs->str));
    }
    else
    {
        NVML_LOG_ERR("missing str for struct nvmlDeviceCurrentClockFreqs_t");
    }
    return deviceCurrentClockFreqs;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessUtilizationSample_t *nvmlProcessUtilizationSample_tDeserializer(const YAML::Node &node)
{
    auto *processUtilizationSample = reinterpret_cast<nvmlProcessUtilizationSample_t *>(malloc(sizeof(nvmlProcessUtilizationSample_t)));
    if (processUtilizationSample == nullptr)
    {
        return nullptr;
    }
    memset(processUtilizationSample, 0, sizeof(*processUtilizationSample));
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessUtilizationSample_t");
    }
    if (node["timeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->timeStamp = node["timeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeStamp for struct nvmlProcessUtilizationSample_t");
    }
    if (node["smUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->smUtil = node["smUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing smUtil for struct nvmlProcessUtilizationSample_t");
    }
    if (node["memUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->memUtil = node["memUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memUtil for struct nvmlProcessUtilizationSample_t");
    }
    if (node["encUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->encUtil = node["encUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encUtil for struct nvmlProcessUtilizationSample_t");
    }
    if (node["decUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationSample->decUtil = node["decUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decUtil for struct nvmlProcessUtilizationSample_t");
    }
    return processUtilizationSample;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessUtilizationInfo_v1_t *nvmlProcessUtilizationInfo_v1_tDeserializer(const YAML::Node &node)
{
    auto *processUtilizationInfo_v1 = reinterpret_cast<nvmlProcessUtilizationInfo_v1_t *>(malloc(sizeof(nvmlProcessUtilizationInfo_v1_t)));
    if (processUtilizationInfo_v1 == nullptr)
    {
        return nullptr;
    }
    memset(processUtilizationInfo_v1, 0, sizeof(*processUtilizationInfo_v1));
    if (node["timeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->timeStamp = node["timeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeStamp for struct nvmlProcessUtilizationInfo_v1_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlProcessUtilizationInfo_v1_t");
    }
    if (node["smUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->smUtil = node["smUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing smUtil for struct nvmlProcessUtilizationInfo_v1_t");
    }
    if (node["memUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->memUtil = node["memUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memUtil for struct nvmlProcessUtilizationInfo_v1_t");
    }
    if (node["encUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->encUtil = node["encUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encUtil for struct nvmlProcessUtilizationInfo_v1_t");
    }
    if (node["decUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->decUtil = node["decUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decUtil for struct nvmlProcessUtilizationInfo_v1_t");
    }
    if (node["jpgUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->jpgUtil = node["jpgUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing jpgUtil for struct nvmlProcessUtilizationInfo_v1_t");
    }
    if (node["ofaUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        processUtilizationInfo_v1->ofaUtil = node["ofaUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ofaUtil for struct nvmlProcessUtilizationInfo_v1_t");
    }
    return processUtilizationInfo_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlProcessesUtilizationInfo_t *nvmlProcessesUtilizationInfo_tDeserializer(const YAML::Node &node)
{
    auto *processesUtilizationInfo = reinterpret_cast<nvmlProcessesUtilizationInfo_t *>(malloc(sizeof(nvmlProcessesUtilizationInfo_t)));
    if (processesUtilizationInfo == nullptr)
    {
        return nullptr;
    }
    memset(processesUtilizationInfo, 0, sizeof(*processesUtilizationInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        processesUtilizationInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlProcessesUtilizationInfo_t");
    }
    if (node["processSamplesCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        processesUtilizationInfo->processSamplesCount = node["processSamplesCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing processSamplesCount for struct nvmlProcessesUtilizationInfo_t");
    }
    if (node["lastSeenTimeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        processesUtilizationInfo->lastSeenTimeStamp = node["lastSeenTimeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing lastSeenTimeStamp for struct nvmlProcessesUtilizationInfo_t");
    }
    if (node["procUtilArray"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlProcessUtilizationInfo_v1_tDeserializer(node["procUtilArray"]);
        if (!tmp0)
        {
            free(processesUtilizationInfo);
            return nullptr;
        }
        std::memcpy(processesUtilizationInfo->procUtilArray, tmp0, sizeof(nvmlProcessUtilizationInfo_v1_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing procUtilArray for struct nvmlProcessesUtilizationInfo_t");
    }
    return processesUtilizationInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlEccSramErrorStatus_t *nvmlEccSramErrorStatus_tDeserializer(const YAML::Node &node)
{
    auto *eccSramErrorStatus = reinterpret_cast<nvmlEccSramErrorStatus_t *>(malloc(sizeof(nvmlEccSramErrorStatus_t)));
    if (eccSramErrorStatus == nullptr)
    {
        return nullptr;
    }
    memset(eccSramErrorStatus, 0, sizeof(*eccSramErrorStatus));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateUncParity"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateUncParity = node["aggregateUncParity"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateUncParity for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateUncSecDed"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateUncSecDed = node["aggregateUncSecDed"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateUncSecDed for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateCor"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateCor = node["aggregateCor"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateCor for struct nvmlEccSramErrorStatus_t");
    }
    if (node["volatileUncParity"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->volatileUncParity = node["volatileUncParity"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing volatileUncParity for struct nvmlEccSramErrorStatus_t");
    }
    if (node["volatileUncSecDed"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->volatileUncSecDed = node["volatileUncSecDed"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing volatileUncSecDed for struct nvmlEccSramErrorStatus_t");
    }
    if (node["volatileCor"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->volatileCor = node["volatileCor"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing volatileCor for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateUncBucketL2"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateUncBucketL2 = node["aggregateUncBucketL2"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateUncBucketL2 for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateUncBucketSm"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateUncBucketSm = node["aggregateUncBucketSm"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateUncBucketSm for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateUncBucketPcie"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateUncBucketPcie = node["aggregateUncBucketPcie"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateUncBucketPcie for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateUncBucketMcu"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateUncBucketMcu = node["aggregateUncBucketMcu"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateUncBucketMcu for struct nvmlEccSramErrorStatus_t");
    }
    if (node["aggregateUncBucketOther"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->aggregateUncBucketOther = node["aggregateUncBucketOther"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing aggregateUncBucketOther for struct nvmlEccSramErrorStatus_t");
    }
    if (node["bThresholdExceeded"])
    {
        // The following snippet is generated from write_deserializer_definition
        eccSramErrorStatus->bThresholdExceeded = node["bThresholdExceeded"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing bThresholdExceeded for struct nvmlEccSramErrorStatus_t");
    }
    return eccSramErrorStatus;
}

// The following snippet is generated from write_deserializer_definition
nvmlPlatformInfo_t *nvmlPlatformInfo_tDeserializer(const YAML::Node &node)
{
    auto *platformInfo = reinterpret_cast<nvmlPlatformInfo_t *>(malloc(sizeof(nvmlPlatformInfo_t)));
    if (platformInfo == nullptr)
    {
        return nullptr;
    }
    memset(platformInfo, 0, sizeof(*platformInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        platformInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlPlatformInfo_t");
    }
    if (node["ibGuid"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto ibGuid = node["ibGuid"].as<std::string>();
        std::memcpy(&platformInfo->ibGuid, ibGuid.data(), sizeof(platformInfo->ibGuid));
    }
    else
    {
        NVML_LOG_ERR("missing ibGuid for struct nvmlPlatformInfo_t");
    }
    if (node["rackGuid"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto rackGuid = node["rackGuid"].as<std::string>();
        std::memcpy(&platformInfo->rackGuid, rackGuid.data(), sizeof(platformInfo->rackGuid));
    }
    else
    {
        NVML_LOG_ERR("missing rackGuid for struct nvmlPlatformInfo_t");
    }
    if (node["chassisPhysicalSlotNumber"])
    {
        // The following snippet is generated from write_deserializer_definition
        platformInfo->chassisPhysicalSlotNumber = node["chassisPhysicalSlotNumber"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing chassisPhysicalSlotNumber for struct nvmlPlatformInfo_t");
    }
    if (node["computeSlotIndex"])
    {
        // The following snippet is generated from write_deserializer_definition
        platformInfo->computeSlotIndex = node["computeSlotIndex"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing computeSlotIndex for struct nvmlPlatformInfo_t");
    }
    if (node["nodeIndex"])
    {
        // The following snippet is generated from write_deserializer_definition
        platformInfo->nodeIndex = node["nodeIndex"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing nodeIndex for struct nvmlPlatformInfo_t");
    }
    if (node["peerType"])
    {
        // The following snippet is generated from write_deserializer_definition
        platformInfo->peerType = node["peerType"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing peerType for struct nvmlPlatformInfo_t");
    }
    if (node["moduleId"])
    {
        // The following snippet is generated from write_deserializer_definition
        platformInfo->moduleId = node["moduleId"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing moduleId for struct nvmlPlatformInfo_t");
    }
    return platformInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlPowerValue_v2_t *nvmlPowerValue_v2_tDeserializer(const YAML::Node &node)
{
    auto *powerValue_v2 = reinterpret_cast<nvmlPowerValue_v2_t *>(malloc(sizeof(nvmlPowerValue_v2_t)));
    if (powerValue_v2 == nullptr)
    {
        return nullptr;
    }
    memset(powerValue_v2, 0, sizeof(*powerValue_v2));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        powerValue_v2->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlPowerValue_v2_t");
    }
    if (node["powerScope"])
    {
        // The following snippet is generated from write_deserializer_definition
        powerValue_v2->powerScope = static_cast<nvmlPowerScopeType_t>(node["powerScope"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing powerScope for struct nvmlPowerValue_v2_t");
    }
    if (node["powerValueMw"])
    {
        // The following snippet is generated from write_deserializer_definition
        powerValue_v2->powerValueMw = node["powerValueMw"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing powerValueMw for struct nvmlPowerValue_v2_t");
    }
    return powerValue_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuHeterogeneousMode_t *nvmlVgpuHeterogeneousMode_tDeserializer(const YAML::Node &node)
{
    auto *vgpuHeterogeneousMode = reinterpret_cast<nvmlVgpuHeterogeneousMode_t *>(malloc(sizeof(nvmlVgpuHeterogeneousMode_t)));
    if (vgpuHeterogeneousMode == nullptr)
    {
        return nullptr;
    }
    memset(vgpuHeterogeneousMode, 0, sizeof(*vgpuHeterogeneousMode));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuHeterogeneousMode->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuHeterogeneousMode_t");
    }
    if (node["mode"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuHeterogeneousMode->mode = node["mode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing mode for struct nvmlVgpuHeterogeneousMode_t");
    }
    return vgpuHeterogeneousMode;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuPlacementId_t *nvmlVgpuPlacementId_tDeserializer(const YAML::Node &node)
{
    auto *vgpuPlacementId = reinterpret_cast<nvmlVgpuPlacementId_t *>(malloc(sizeof(nvmlVgpuPlacementId_t)));
    if (vgpuPlacementId == nullptr)
    {
        return nullptr;
    }
    memset(vgpuPlacementId, 0, sizeof(*vgpuPlacementId));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementId->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuPlacementId_t");
    }
    if (node["placementId"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementId->placementId = node["placementId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing placementId for struct nvmlVgpuPlacementId_t");
    }
    return vgpuPlacementId;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuPlacementList_v1_t *nvmlVgpuPlacementList_v1_tDeserializer(const YAML::Node &node)
{
    auto *vgpuPlacementList_v1 = reinterpret_cast<nvmlVgpuPlacementList_v1_t *>(malloc(sizeof(nvmlVgpuPlacementList_v1_t)));
    if (vgpuPlacementList_v1 == nullptr)
    {
        return nullptr;
    }
    memset(vgpuPlacementList_v1, 0, sizeof(*vgpuPlacementList_v1));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementList_v1->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuPlacementList_v1_t");
    }
    if (node["placementSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementList_v1->placementSize = node["placementSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing placementSize for struct nvmlVgpuPlacementList_v1_t");
    }
    if (node["count"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementList_v1->count = node["count"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing count for struct nvmlVgpuPlacementList_v1_t");
    }
    if (node["placementIds"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto const tmp0 = node["placementIds"].as<std::vector<unsigned int>>();
        vgpuPlacementList_v1->placementIds = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * tmp0.size()));
        for (unsigned int ii = 0; ii < tmp0.size(); ++ii)
        {
            vgpuPlacementList_v1->placementIds[ii] = tmp0[ii];
        }
    }
    else
    {
        NVML_LOG_ERR("missing placementIds for struct nvmlVgpuPlacementList_v1_t");
    }
    return vgpuPlacementList_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuPlacementList_t *nvmlVgpuPlacementList_tDeserializer(const YAML::Node &node)
{
    auto *vgpuPlacementList = reinterpret_cast<nvmlVgpuPlacementList_t *>(malloc(sizeof(nvmlVgpuPlacementList_t)));
    if (vgpuPlacementList == nullptr)
    {
        return nullptr;
    }
    memset(vgpuPlacementList, 0, sizeof(*vgpuPlacementList));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementList->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuPlacementList_t");
    }
    if (node["placementSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementList->placementSize = node["placementSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing placementSize for struct nvmlVgpuPlacementList_t");
    }
    if (node["count"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementList->count = node["count"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing count for struct nvmlVgpuPlacementList_t");
    }
    if (node["placementIds"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto const tmp0 = node["placementIds"].as<std::vector<unsigned int>>();
        vgpuPlacementList->placementIds = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * tmp0.size()));
        for (unsigned int ii = 0; ii < tmp0.size(); ++ii)
        {
            vgpuPlacementList->placementIds[ii] = tmp0[ii];
        }
    }
    else
    {
        NVML_LOG_ERR("missing placementIds for struct nvmlVgpuPlacementList_t");
    }
    if (node["mode"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPlacementList->mode = node["mode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing mode for struct nvmlVgpuPlacementList_t");
    }
    return vgpuPlacementList;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuTypeBar1Info_t *nvmlVgpuTypeBar1Info_tDeserializer(const YAML::Node &node)
{
    auto *vgpuTypeBar1Info = reinterpret_cast<nvmlVgpuTypeBar1Info_t *>(malloc(sizeof(nvmlVgpuTypeBar1Info_t)));
    if (vgpuTypeBar1Info == nullptr)
    {
        return nullptr;
    }
    memset(vgpuTypeBar1Info, 0, sizeof(*vgpuTypeBar1Info));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuTypeBar1Info->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuTypeBar1Info_t");
    }
    if (node["bar1Size"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuTypeBar1Info->bar1Size = node["bar1Size"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing bar1Size for struct nvmlVgpuTypeBar1Info_t");
    }
    return vgpuTypeBar1Info;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuInstancesUtilizationInfo_t *nvmlVgpuInstancesUtilizationInfo_tDeserializer(const YAML::Node &node)
{
    auto *vgpuInstancesUtilizationInfo = reinterpret_cast<nvmlVgpuInstancesUtilizationInfo_t *>(malloc(sizeof(nvmlVgpuInstancesUtilizationInfo_t)));
    if (vgpuInstancesUtilizationInfo == nullptr)
    {
        return nullptr;
    }
    memset(vgpuInstancesUtilizationInfo, 0, sizeof(*vgpuInstancesUtilizationInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuInstancesUtilizationInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuInstancesUtilizationInfo_t");
    }
    if (node["sampleValType"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuInstancesUtilizationInfo->sampleValType = static_cast<nvmlValueType_t>(node["sampleValType"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing sampleValType for struct nvmlVgpuInstancesUtilizationInfo_t");
    }
    if (node["vgpuInstanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuInstancesUtilizationInfo->vgpuInstanceCount = node["vgpuInstanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstanceCount for struct nvmlVgpuInstancesUtilizationInfo_t");
    }
    if (node["lastSeenTimeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuInstancesUtilizationInfo->lastSeenTimeStamp = node["lastSeenTimeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing lastSeenTimeStamp for struct nvmlVgpuInstancesUtilizationInfo_t");
    }
    if (node["vgpuUtilArray"])
    {
        // The following snippet is generated from write_deserializer_definition
        NVML_LOG_ERR("Skipping loading vgpuUtilArray for struct nvmlVgpuInstancesUtilizationInfo_t");
    }
    else
    {
        NVML_LOG_ERR("missing vgpuUtilArray for struct nvmlVgpuInstancesUtilizationInfo_t");
    }
    return vgpuInstancesUtilizationInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuProcessUtilizationSample_t *nvmlVgpuProcessUtilizationSample_tDeserializer(const YAML::Node &node)
{
    auto *vgpuProcessUtilizationSample = reinterpret_cast<nvmlVgpuProcessUtilizationSample_t *>(malloc(sizeof(nvmlVgpuProcessUtilizationSample_t)));
    if (vgpuProcessUtilizationSample == nullptr)
    {
        return nullptr;
    }
    memset(vgpuProcessUtilizationSample, 0, sizeof(*vgpuProcessUtilizationSample));
    if (node["vgpuInstance"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->vgpuInstance = static_cast<nvmlVgpuInstance_t>(node["vgpuInstance"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstance for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["processName"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto processName = node["processName"].as<std::string>();
        std::memcpy(&vgpuProcessUtilizationSample->processName, processName.data(), sizeof(vgpuProcessUtilizationSample->processName));
    }
    else
    {
        NVML_LOG_ERR("missing processName for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["timeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->timeStamp = node["timeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeStamp for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["smUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->smUtil = node["smUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing smUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["memUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->memUtil = node["memUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["encUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->encUtil = node["encUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    if (node["decUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationSample->decUtil = node["decUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decUtil for struct nvmlVgpuProcessUtilizationSample_t");
    }
    return vgpuProcessUtilizationSample;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuProcessUtilizationInfo_v1_t *nvmlVgpuProcessUtilizationInfo_v1_tDeserializer(const YAML::Node &node)
{
    auto *vgpuProcessUtilizationInfo_v1 = reinterpret_cast<nvmlVgpuProcessUtilizationInfo_v1_t *>(malloc(sizeof(nvmlVgpuProcessUtilizationInfo_v1_t)));
    if (vgpuProcessUtilizationInfo_v1 == nullptr)
    {
        return nullptr;
    }
    memset(vgpuProcessUtilizationInfo_v1, 0, sizeof(*vgpuProcessUtilizationInfo_v1));
    if (node["processName"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto processName = node["processName"].as<std::string>();
        std::memcpy(&vgpuProcessUtilizationInfo_v1->processName, processName.data(), sizeof(vgpuProcessUtilizationInfo_v1->processName));
    }
    else
    {
        NVML_LOG_ERR("missing processName for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["timeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->timeStamp = node["timeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeStamp for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["vgpuInstance"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->vgpuInstance = static_cast<nvmlVgpuInstance_t>(node["vgpuInstance"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstance for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["smUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->smUtil = node["smUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing smUtil for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["memUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->memUtil = node["memUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memUtil for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["encUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->encUtil = node["encUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encUtil for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["decUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->decUtil = node["decUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decUtil for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["jpgUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->jpgUtil = node["jpgUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing jpgUtil for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    if (node["ofaUtil"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessUtilizationInfo_v1->ofaUtil = node["ofaUtil"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ofaUtil for struct nvmlVgpuProcessUtilizationInfo_v1_t");
    }
    return vgpuProcessUtilizationInfo_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuProcessesUtilizationInfo_t *nvmlVgpuProcessesUtilizationInfo_tDeserializer(const YAML::Node &node)
{
    auto *vgpuProcessesUtilizationInfo = reinterpret_cast<nvmlVgpuProcessesUtilizationInfo_t *>(malloc(sizeof(nvmlVgpuProcessesUtilizationInfo_t)));
    if (vgpuProcessesUtilizationInfo == nullptr)
    {
        return nullptr;
    }
    memset(vgpuProcessesUtilizationInfo, 0, sizeof(*vgpuProcessesUtilizationInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessesUtilizationInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuProcessesUtilizationInfo_t");
    }
    if (node["vgpuProcessCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessesUtilizationInfo->vgpuProcessCount = node["vgpuProcessCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vgpuProcessCount for struct nvmlVgpuProcessesUtilizationInfo_t");
    }
    if (node["lastSeenTimeStamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuProcessesUtilizationInfo->lastSeenTimeStamp = node["lastSeenTimeStamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing lastSeenTimeStamp for struct nvmlVgpuProcessesUtilizationInfo_t");
    }
    if (node["vgpuProcUtilArray"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlVgpuProcessUtilizationInfo_v1_tDeserializer(node["vgpuProcUtilArray"]);
        if (!tmp0)
        {
            free(vgpuProcessesUtilizationInfo);
            return nullptr;
        }
        std::memcpy(vgpuProcessesUtilizationInfo->vgpuProcUtilArray, tmp0, sizeof(nvmlVgpuProcessUtilizationInfo_v1_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing vgpuProcUtilArray for struct nvmlVgpuProcessesUtilizationInfo_t");
    }
    return vgpuProcessesUtilizationInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuSchedulerLogEntry_t *nvmlVgpuSchedulerLogEntry_tDeserializer(const YAML::Node &node)
{
    auto *vgpuSchedulerLogEntry = reinterpret_cast<nvmlVgpuSchedulerLogEntry_t *>(malloc(sizeof(nvmlVgpuSchedulerLogEntry_t)));
    if (vgpuSchedulerLogEntry == nullptr)
    {
        return nullptr;
    }
    memset(vgpuSchedulerLogEntry, 0, sizeof(*vgpuSchedulerLogEntry));
    if (node["timestamp"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLogEntry->timestamp = node["timestamp"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timestamp for struct nvmlVgpuSchedulerLogEntry_t");
    }
    if (node["timeRunTotal"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLogEntry->timeRunTotal = node["timeRunTotal"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeRunTotal for struct nvmlVgpuSchedulerLogEntry_t");
    }
    if (node["timeRun"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLogEntry->timeRun = node["timeRun"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing timeRun for struct nvmlVgpuSchedulerLogEntry_t");
    }
    if (node["swRunlistId"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLogEntry->swRunlistId = node["swRunlistId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing swRunlistId for struct nvmlVgpuSchedulerLogEntry_t");
    }
    if (node["targetTimeSlice"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLogEntry->targetTimeSlice = node["targetTimeSlice"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing targetTimeSlice for struct nvmlVgpuSchedulerLogEntry_t");
    }
    if (node["cumulativePreemptionTime"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLogEntry->cumulativePreemptionTime = node["cumulativePreemptionTime"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing cumulativePreemptionTime for struct nvmlVgpuSchedulerLogEntry_t");
    }
    return vgpuSchedulerLogEntry;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuSchedulerLog_t *nvmlVgpuSchedulerLog_tDeserializer(const YAML::Node &node)
{
    auto *vgpuSchedulerLog = reinterpret_cast<nvmlVgpuSchedulerLog_t *>(malloc(sizeof(nvmlVgpuSchedulerLog_t)));
    if (vgpuSchedulerLog == nullptr)
    {
        return nullptr;
    }
    memset(vgpuSchedulerLog, 0, sizeof(*vgpuSchedulerLog));
    if (node["engineId"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLog->engineId = node["engineId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing engineId for struct nvmlVgpuSchedulerLog_t");
    }
    if (node["schedulerPolicy"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLog->schedulerPolicy = node["schedulerPolicy"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing schedulerPolicy for struct nvmlVgpuSchedulerLog_t");
    }
    if (node["arrMode"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLog->arrMode = node["arrMode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing arrMode for struct nvmlVgpuSchedulerLog_t");
    }
    if (node["schedulerParams"])
    {
        // The following snippet is generated from write_deserializer_definition
        NVML_LOG_ERR("Skipping loading schedulerParams for struct nvmlVgpuSchedulerLog_t");
    }
    else
    {
        NVML_LOG_ERR("missing schedulerParams for struct nvmlVgpuSchedulerLog_t");
    }
    if (node["entriesCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerLog->entriesCount = node["entriesCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing entriesCount for struct nvmlVgpuSchedulerLog_t");
    }
    if (node["logEntries"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["logEntries"].size(), sizeof(vgpuSchedulerLog->logEntries) / sizeof(nvmlVgpuSchedulerLogEntry_t));
        for (YAML::const_iterator it = node["logEntries"].begin(); it != node["logEntries"].end(); ++it)
        {
            auto *tmp = nvmlVgpuSchedulerLogEntry_tDeserializer(*it);
            if (!tmp)
            {
                free(vgpuSchedulerLog);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&vgpuSchedulerLog->logEntries[idx++], tmp, sizeof(nvmlVgpuSchedulerLogEntry_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing logEntries for struct nvmlVgpuSchedulerLog_t");
    }
    return vgpuSchedulerLog;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuSchedulerGetState_t *nvmlVgpuSchedulerGetState_tDeserializer(const YAML::Node &node)
{
    auto *vgpuSchedulerGetState = reinterpret_cast<nvmlVgpuSchedulerGetState_t *>(malloc(sizeof(nvmlVgpuSchedulerGetState_t)));
    if (vgpuSchedulerGetState == nullptr)
    {
        return nullptr;
    }
    memset(vgpuSchedulerGetState, 0, sizeof(*vgpuSchedulerGetState));
    if (node["schedulerPolicy"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerGetState->schedulerPolicy = node["schedulerPolicy"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing schedulerPolicy for struct nvmlVgpuSchedulerGetState_t");
    }
    if (node["arrMode"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerGetState->arrMode = node["arrMode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing arrMode for struct nvmlVgpuSchedulerGetState_t");
    }
    if (node["schedulerParams"])
    {
        // The following snippet is generated from write_deserializer_definition
        NVML_LOG_ERR("Skipping loading schedulerParams for struct nvmlVgpuSchedulerGetState_t");
    }
    else
    {
        NVML_LOG_ERR("missing schedulerParams for struct nvmlVgpuSchedulerGetState_t");
    }
    return vgpuSchedulerGetState;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuSchedulerSetState_t *nvmlVgpuSchedulerSetState_tDeserializer(const YAML::Node &node)
{
    auto *vgpuSchedulerSetState = reinterpret_cast<nvmlVgpuSchedulerSetState_t *>(malloc(sizeof(nvmlVgpuSchedulerSetState_t)));
    if (vgpuSchedulerSetState == nullptr)
    {
        return nullptr;
    }
    memset(vgpuSchedulerSetState, 0, sizeof(*vgpuSchedulerSetState));
    if (node["schedulerPolicy"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerSetState->schedulerPolicy = node["schedulerPolicy"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing schedulerPolicy for struct nvmlVgpuSchedulerSetState_t");
    }
    if (node["enableARRMode"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerSetState->enableARRMode = node["enableARRMode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing enableARRMode for struct nvmlVgpuSchedulerSetState_t");
    }
    if (node["schedulerParams"])
    {
        // The following snippet is generated from write_deserializer_definition
        NVML_LOG_ERR("Skipping loading schedulerParams for struct nvmlVgpuSchedulerSetState_t");
    }
    else
    {
        NVML_LOG_ERR("missing schedulerParams for struct nvmlVgpuSchedulerSetState_t");
    }
    return vgpuSchedulerSetState;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuSchedulerCapabilities_t *nvmlVgpuSchedulerCapabilities_tDeserializer(const YAML::Node &node)
{
    auto *vgpuSchedulerCapabilities = reinterpret_cast<nvmlVgpuSchedulerCapabilities_t *>(malloc(sizeof(nvmlVgpuSchedulerCapabilities_t)));
    if (vgpuSchedulerCapabilities == nullptr)
    {
        return nullptr;
    }
    memset(vgpuSchedulerCapabilities, 0, sizeof(*vgpuSchedulerCapabilities));
    if (node["supportedSchedulers"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto const tmp0 = node["supportedSchedulers"].as<std::vector<unsigned int>>();
        for (unsigned int ii = 0; ii < tmp0.size(); ++ii)
        {
            vgpuSchedulerCapabilities->supportedSchedulers[ii] = tmp0[ii];
        }
    }
    else
    {
        NVML_LOG_ERR("missing supportedSchedulers for struct nvmlVgpuSchedulerCapabilities_t");
    }
    if (node["maxTimeslice"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerCapabilities->maxTimeslice = node["maxTimeslice"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing maxTimeslice for struct nvmlVgpuSchedulerCapabilities_t");
    }
    if (node["minTimeslice"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerCapabilities->minTimeslice = node["minTimeslice"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing minTimeslice for struct nvmlVgpuSchedulerCapabilities_t");
    }
    if (node["isArrModeSupported"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerCapabilities->isArrModeSupported = node["isArrModeSupported"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isArrModeSupported for struct nvmlVgpuSchedulerCapabilities_t");
    }
    if (node["maxFrequencyForARR"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerCapabilities->maxFrequencyForARR = node["maxFrequencyForARR"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing maxFrequencyForARR for struct nvmlVgpuSchedulerCapabilities_t");
    }
    if (node["minFrequencyForARR"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerCapabilities->minFrequencyForARR = node["minFrequencyForARR"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing minFrequencyForARR for struct nvmlVgpuSchedulerCapabilities_t");
    }
    if (node["maxAvgFactorForARR"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerCapabilities->maxAvgFactorForARR = node["maxAvgFactorForARR"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing maxAvgFactorForARR for struct nvmlVgpuSchedulerCapabilities_t");
    }
    if (node["minAvgFactorForARR"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuSchedulerCapabilities->minAvgFactorForARR = node["minAvgFactorForARR"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing minAvgFactorForARR for struct nvmlVgpuSchedulerCapabilities_t");
    }
    return vgpuSchedulerCapabilities;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuLicenseExpiry_t *nvmlVgpuLicenseExpiry_tDeserializer(const YAML::Node &node)
{
    auto *vgpuLicenseExpiry = reinterpret_cast<nvmlVgpuLicenseExpiry_t *>(malloc(sizeof(nvmlVgpuLicenseExpiry_t)));
    if (vgpuLicenseExpiry == nullptr)
    {
        return nullptr;
    }
    memset(vgpuLicenseExpiry, 0, sizeof(*vgpuLicenseExpiry));
    if (node["year"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->year = node["year"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing year for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["month"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->month = node["month"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing month for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["day"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->day = node["day"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing day for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["hour"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->hour = node["hour"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing hour for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["min"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->min = node["min"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing min for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["sec"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->sec = node["sec"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing sec for struct nvmlVgpuLicenseExpiry_t");
    }
    if (node["status"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseExpiry->status = node["status"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing status for struct nvmlVgpuLicenseExpiry_t");
    }
    return vgpuLicenseExpiry;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuLicenseInfo_t *nvmlVgpuLicenseInfo_tDeserializer(const YAML::Node &node)
{
    auto *vgpuLicenseInfo = reinterpret_cast<nvmlVgpuLicenseInfo_t *>(malloc(sizeof(nvmlVgpuLicenseInfo_t)));
    if (vgpuLicenseInfo == nullptr)
    {
        return nullptr;
    }
    memset(vgpuLicenseInfo, 0, sizeof(*vgpuLicenseInfo));
    if (node["isLicensed"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseInfo->isLicensed = node["isLicensed"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing isLicensed for struct nvmlVgpuLicenseInfo_t");
    }
    if (node["licenseExpiry"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlVgpuLicenseExpiry_tDeserializer(node["licenseExpiry"]);
        if (!tmp0)
        {
            free(vgpuLicenseInfo);
            return nullptr;
        }
        std::memcpy(&vgpuLicenseInfo->licenseExpiry, tmp0, sizeof(nvmlVgpuLicenseExpiry_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing licenseExpiry for struct nvmlVgpuLicenseInfo_t");
    }
    if (node["currentState"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuLicenseInfo->currentState = node["currentState"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing currentState for struct nvmlVgpuLicenseInfo_t");
    }
    return vgpuLicenseInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlGridLicenseExpiry_t *nvmlGridLicenseExpiry_tDeserializer(const YAML::Node &node)
{
    auto *gridLicenseExpiry = reinterpret_cast<nvmlGridLicenseExpiry_t *>(malloc(sizeof(nvmlGridLicenseExpiry_t)));
    if (gridLicenseExpiry == nullptr)
    {
        return nullptr;
    }
    memset(gridLicenseExpiry, 0, sizeof(*gridLicenseExpiry));
    if (node["year"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->year = node["year"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing year for struct nvmlGridLicenseExpiry_t");
    }
    if (node["month"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->month = node["month"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing month for struct nvmlGridLicenseExpiry_t");
    }
    if (node["day"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->day = node["day"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing day for struct nvmlGridLicenseExpiry_t");
    }
    if (node["hour"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->hour = node["hour"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing hour for struct nvmlGridLicenseExpiry_t");
    }
    if (node["min"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->min = node["min"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing min for struct nvmlGridLicenseExpiry_t");
    }
    if (node["sec"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->sec = node["sec"].as<unsigned short>();
    }
    else
    {
        NVML_LOG_ERR("missing sec for struct nvmlGridLicenseExpiry_t");
    }
    if (node["status"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicenseExpiry->status = node["status"].as<unsigned char>();
    }
    else
    {
        NVML_LOG_ERR("missing status for struct nvmlGridLicenseExpiry_t");
    }
    return gridLicenseExpiry;
}

// The following snippet is generated from write_deserializer_definition
nvmlGridLicensableFeature_t *nvmlGridLicensableFeature_tDeserializer(const YAML::Node &node)
{
    auto *gridLicensableFeature = reinterpret_cast<nvmlGridLicensableFeature_t *>(malloc(sizeof(nvmlGridLicensableFeature_t)));
    if (gridLicensableFeature == nullptr)
    {
        return nullptr;
    }
    memset(gridLicensableFeature, 0, sizeof(*gridLicensableFeature));
    if (node["featureCode"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeature->featureCode = static_cast<nvmlGridLicenseFeatureCode_t>(node["featureCode"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing featureCode for struct nvmlGridLicensableFeature_t");
    }
    if (node["featureState"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeature->featureState = node["featureState"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing featureState for struct nvmlGridLicensableFeature_t");
    }
    if (node["licenseInfo"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto licenseInfo = node["licenseInfo"].as<std::string>();
        std::memcpy(&gridLicensableFeature->licenseInfo, licenseInfo.data(), sizeof(gridLicensableFeature->licenseInfo));
    }
    else
    {
        NVML_LOG_ERR("missing licenseInfo for struct nvmlGridLicensableFeature_t");
    }
    if (node["productName"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto productName = node["productName"].as<std::string>();
        std::memcpy(&gridLicensableFeature->productName, productName.data(), sizeof(gridLicensableFeature->productName));
    }
    else
    {
        NVML_LOG_ERR("missing productName for struct nvmlGridLicensableFeature_t");
    }
    if (node["featureEnabled"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeature->featureEnabled = node["featureEnabled"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing featureEnabled for struct nvmlGridLicensableFeature_t");
    }
    if (node["licenseExpiry"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlGridLicenseExpiry_tDeserializer(node["licenseExpiry"]);
        if (!tmp0)
        {
            free(gridLicensableFeature);
            return nullptr;
        }
        std::memcpy(&gridLicensableFeature->licenseExpiry, tmp0, sizeof(nvmlGridLicenseExpiry_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing licenseExpiry for struct nvmlGridLicensableFeature_t");
    }
    return gridLicensableFeature;
}

// The following snippet is generated from write_deserializer_definition
nvmlGridLicensableFeatures_t *nvmlGridLicensableFeatures_tDeserializer(const YAML::Node &node)
{
    auto *gridLicensableFeatures = reinterpret_cast<nvmlGridLicensableFeatures_t *>(malloc(sizeof(nvmlGridLicensableFeatures_t)));
    if (gridLicensableFeatures == nullptr)
    {
        return nullptr;
    }
    memset(gridLicensableFeatures, 0, sizeof(*gridLicensableFeatures));
    if (node["isGridLicenseSupported"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeatures->isGridLicenseSupported = node["isGridLicenseSupported"].as<int>();
    }
    else
    {
        NVML_LOG_ERR("missing isGridLicenseSupported for struct nvmlGridLicensableFeatures_t");
    }
    if (node["licensableFeaturesCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gridLicensableFeatures->licensableFeaturesCount = node["licensableFeaturesCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing licensableFeaturesCount for struct nvmlGridLicensableFeatures_t");
    }
    if (node["gridLicensableFeatures"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["gridLicensableFeatures"].size(), sizeof(gridLicensableFeatures->gridLicensableFeatures) / sizeof(nvmlGridLicensableFeature_t));
        for (YAML::const_iterator it = node["gridLicensableFeatures"].begin(); it != node["gridLicensableFeatures"].end(); ++it)
        {
            auto *tmp = nvmlGridLicensableFeature_tDeserializer(*it);
            if (!tmp)
            {
                free(gridLicensableFeatures);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&gridLicensableFeatures->gridLicensableFeatures[idx++], tmp, sizeof(nvmlGridLicensableFeature_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing gridLicensableFeatures for struct nvmlGridLicensableFeatures_t");
    }
    return gridLicensableFeatures;
}

// The following snippet is generated from write_deserializer_definition
nvmlNvLinkPowerThres_t *nvmlNvLinkPowerThres_tDeserializer(const YAML::Node &node)
{
    auto *nvLinkPowerThres = reinterpret_cast<nvmlNvLinkPowerThres_t *>(malloc(sizeof(nvmlNvLinkPowerThres_t)));
    if (nvLinkPowerThres == nullptr)
    {
        return nullptr;
    }
    memset(nvLinkPowerThres, 0, sizeof(*nvLinkPowerThres));
    if (node["lowPwrThreshold"])
    {
        // The following snippet is generated from write_deserializer_definition
        nvLinkPowerThres->lowPwrThreshold = node["lowPwrThreshold"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing lowPwrThreshold for struct nvmlNvLinkPowerThres_t");
    }
    return nvLinkPowerThres;
}

// The following snippet is generated from write_deserializer_definition
nvmlHwbcEntry_t *nvmlHwbcEntry_tDeserializer(const YAML::Node &node)
{
    auto *hwbcEntry = reinterpret_cast<nvmlHwbcEntry_t *>(malloc(sizeof(nvmlHwbcEntry_t)));
    if (hwbcEntry == nullptr)
    {
        return nullptr;
    }
    memset(hwbcEntry, 0, sizeof(*hwbcEntry));
    if (node["hwbcId"])
    {
        // The following snippet is generated from write_deserializer_definition
        hwbcEntry->hwbcId = node["hwbcId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hwbcId for struct nvmlHwbcEntry_t");
    }
    if (node["firmwareVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto firmwareVersion = node["firmwareVersion"].as<std::string>();
        std::memcpy(&hwbcEntry->firmwareVersion, firmwareVersion.data(), sizeof(hwbcEntry->firmwareVersion));
    }
    else
    {
        NVML_LOG_ERR("missing firmwareVersion for struct nvmlHwbcEntry_t");
    }
    return hwbcEntry;
}

// The following snippet is generated from write_deserializer_definition
nvmlLedState_t *nvmlLedState_tDeserializer(const YAML::Node &node)
{
    auto *ledState = reinterpret_cast<nvmlLedState_t *>(malloc(sizeof(nvmlLedState_t)));
    if (ledState == nullptr)
    {
        return nullptr;
    }
    memset(ledState, 0, sizeof(*ledState));
    if (node["cause"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto cause = node["cause"].as<std::string>();
        std::memcpy(&ledState->cause, cause.data(), sizeof(ledState->cause));
    }
    else
    {
        NVML_LOG_ERR("missing cause for struct nvmlLedState_t");
    }
    if (node["color"])
    {
        // The following snippet is generated from write_deserializer_definition
        ledState->color = static_cast<nvmlLedColor_t>(node["color"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing color for struct nvmlLedState_t");
    }
    return ledState;
}

// The following snippet is generated from write_deserializer_definition
nvmlUnitInfo_t *nvmlUnitInfo_tDeserializer(const YAML::Node &node)
{
    auto *unitInfo = reinterpret_cast<nvmlUnitInfo_t *>(malloc(sizeof(nvmlUnitInfo_t)));
    if (unitInfo == nullptr)
    {
        return nullptr;
    }
    memset(unitInfo, 0, sizeof(*unitInfo));
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&unitInfo->name, name.data(), sizeof(unitInfo->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlUnitInfo_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto id = node["id"].as<std::string>();
        std::memcpy(&unitInfo->id, id.data(), sizeof(unitInfo->id));
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlUnitInfo_t");
    }
    if (node["serial"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto serial = node["serial"].as<std::string>();
        std::memcpy(&unitInfo->serial, serial.data(), sizeof(unitInfo->serial));
    }
    else
    {
        NVML_LOG_ERR("missing serial for struct nvmlUnitInfo_t");
    }
    if (node["firmwareVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto firmwareVersion = node["firmwareVersion"].as<std::string>();
        std::memcpy(&unitInfo->firmwareVersion, firmwareVersion.data(), sizeof(unitInfo->firmwareVersion));
    }
    else
    {
        NVML_LOG_ERR("missing firmwareVersion for struct nvmlUnitInfo_t");
    }
    return unitInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlPSUInfo_t *nvmlPSUInfo_tDeserializer(const YAML::Node &node)
{
    auto *pSUInfo = reinterpret_cast<nvmlPSUInfo_t *>(malloc(sizeof(nvmlPSUInfo_t)));
    if (pSUInfo == nullptr)
    {
        return nullptr;
    }
    memset(pSUInfo, 0, sizeof(*pSUInfo));
    if (node["state"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto state = node["state"].as<std::string>();
        std::memcpy(&pSUInfo->state, state.data(), sizeof(pSUInfo->state));
    }
    else
    {
        NVML_LOG_ERR("missing state for struct nvmlPSUInfo_t");
    }
    if (node["current"])
    {
        // The following snippet is generated from write_deserializer_definition
        pSUInfo->current = node["current"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing current for struct nvmlPSUInfo_t");
    }
    if (node["voltage"])
    {
        // The following snippet is generated from write_deserializer_definition
        pSUInfo->voltage = node["voltage"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing voltage for struct nvmlPSUInfo_t");
    }
    if (node["power"])
    {
        // The following snippet is generated from write_deserializer_definition
        pSUInfo->power = node["power"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing power for struct nvmlPSUInfo_t");
    }
    return pSUInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlUnitFanInfo_t *nvmlUnitFanInfo_tDeserializer(const YAML::Node &node)
{
    auto *unitFanInfo = reinterpret_cast<nvmlUnitFanInfo_t *>(malloc(sizeof(nvmlUnitFanInfo_t)));
    if (unitFanInfo == nullptr)
    {
        return nullptr;
    }
    memset(unitFanInfo, 0, sizeof(*unitFanInfo));
    if (node["speed"])
    {
        // The following snippet is generated from write_deserializer_definition
        unitFanInfo->speed = node["speed"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing speed for struct nvmlUnitFanInfo_t");
    }
    if (node["state"])
    {
        // The following snippet is generated from write_deserializer_definition
        unitFanInfo->state = static_cast<nvmlFanState_t>(node["state"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing state for struct nvmlUnitFanInfo_t");
    }
    return unitFanInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlUnitFanSpeeds_t *nvmlUnitFanSpeeds_tDeserializer(const YAML::Node &node)
{
    auto *unitFanSpeeds = reinterpret_cast<nvmlUnitFanSpeeds_t *>(malloc(sizeof(nvmlUnitFanSpeeds_t)));
    if (unitFanSpeeds == nullptr)
    {
        return nullptr;
    }
    memset(unitFanSpeeds, 0, sizeof(*unitFanSpeeds));
    if (node["fans"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["fans"].size(), sizeof(unitFanSpeeds->fans) / sizeof(nvmlUnitFanInfo_t));
        for (YAML::const_iterator it = node["fans"].begin(); it != node["fans"].end(); ++it)
        {
            auto *tmp = nvmlUnitFanInfo_tDeserializer(*it);
            if (!tmp)
            {
                free(unitFanSpeeds);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&unitFanSpeeds->fans[idx++], tmp, sizeof(nvmlUnitFanInfo_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing fans for struct nvmlUnitFanSpeeds_t");
    }
    if (node["count"])
    {
        // The following snippet is generated from write_deserializer_definition
        unitFanSpeeds->count = node["count"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing count for struct nvmlUnitFanSpeeds_t");
    }
    return unitFanSpeeds;
}

// The following snippet is generated from write_deserializer_definition
nvmlAccountingStats_t *nvmlAccountingStats_tDeserializer(const YAML::Node &node)
{
    auto *accountingStats = reinterpret_cast<nvmlAccountingStats_t *>(malloc(sizeof(nvmlAccountingStats_t)));
    if (accountingStats == nullptr)
    {
        return nullptr;
    }
    memset(accountingStats, 0, sizeof(*accountingStats));
    if (node["gpuUtilization"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->gpuUtilization = node["gpuUtilization"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpuUtilization for struct nvmlAccountingStats_t");
    }
    if (node["memoryUtilization"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->memoryUtilization = node["memoryUtilization"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing memoryUtilization for struct nvmlAccountingStats_t");
    }
    if (node["maxMemoryUsage"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->maxMemoryUsage = node["maxMemoryUsage"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing maxMemoryUsage for struct nvmlAccountingStats_t");
    }
    if (node["time"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->time = node["time"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing time for struct nvmlAccountingStats_t");
    }
    if (node["startTime"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->startTime = node["startTime"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing startTime for struct nvmlAccountingStats_t");
    }
    if (node["isRunning"])
    {
        // The following snippet is generated from write_deserializer_definition
        accountingStats->isRunning = node["isRunning"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isRunning for struct nvmlAccountingStats_t");
    }
    return accountingStats;
}

// The following snippet is generated from write_deserializer_definition
nvmlEncoderSessionInfo_t *nvmlEncoderSessionInfo_tDeserializer(const YAML::Node &node)
{
    auto *encoderSessionInfo = reinterpret_cast<nvmlEncoderSessionInfo_t *>(malloc(sizeof(nvmlEncoderSessionInfo_t)));
    if (encoderSessionInfo == nullptr)
    {
        return nullptr;
    }
    memset(encoderSessionInfo, 0, sizeof(*encoderSessionInfo));
    if (node["sessionId"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->sessionId = node["sessionId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionId for struct nvmlEncoderSessionInfo_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlEncoderSessionInfo_t");
    }
    if (node["vgpuInstance"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->vgpuInstance = static_cast<nvmlVgpuInstance_t>(node["vgpuInstance"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstance for struct nvmlEncoderSessionInfo_t");
    }
    if (node["codecType"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->codecType = static_cast<nvmlEncoderType_t>(node["codecType"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing codecType for struct nvmlEncoderSessionInfo_t");
    }
    if (node["hResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->hResolution = node["hResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hResolution for struct nvmlEncoderSessionInfo_t");
    }
    if (node["vResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->vResolution = node["vResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vResolution for struct nvmlEncoderSessionInfo_t");
    }
    if (node["averageFps"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->averageFps = node["averageFps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageFps for struct nvmlEncoderSessionInfo_t");
    }
    if (node["averageLatency"])
    {
        // The following snippet is generated from write_deserializer_definition
        encoderSessionInfo->averageLatency = node["averageLatency"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageLatency for struct nvmlEncoderSessionInfo_t");
    }
    return encoderSessionInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlFBCStats_t *nvmlFBCStats_tDeserializer(const YAML::Node &node)
{
    auto *fBCStats = reinterpret_cast<nvmlFBCStats_t *>(malloc(sizeof(nvmlFBCStats_t)));
    if (fBCStats == nullptr)
    {
        return nullptr;
    }
    memset(fBCStats, 0, sizeof(*fBCStats));
    if (node["sessionsCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCStats->sessionsCount = node["sessionsCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionsCount for struct nvmlFBCStats_t");
    }
    if (node["averageFPS"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCStats->averageFPS = node["averageFPS"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageFPS for struct nvmlFBCStats_t");
    }
    if (node["averageLatency"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCStats->averageLatency = node["averageLatency"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageLatency for struct nvmlFBCStats_t");
    }
    return fBCStats;
}

// The following snippet is generated from write_deserializer_definition
nvmlFBCSessionInfo_t *nvmlFBCSessionInfo_tDeserializer(const YAML::Node &node)
{
    auto *fBCSessionInfo = reinterpret_cast<nvmlFBCSessionInfo_t *>(malloc(sizeof(nvmlFBCSessionInfo_t)));
    if (fBCSessionInfo == nullptr)
    {
        return nullptr;
    }
    memset(fBCSessionInfo, 0, sizeof(*fBCSessionInfo));
    if (node["sessionId"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->sessionId = node["sessionId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionId for struct nvmlFBCSessionInfo_t");
    }
    if (node["pid"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->pid = node["pid"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pid for struct nvmlFBCSessionInfo_t");
    }
    if (node["vgpuInstance"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->vgpuInstance = static_cast<nvmlVgpuInstance_t>(node["vgpuInstance"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuInstance for struct nvmlFBCSessionInfo_t");
    }
    if (node["displayOrdinal"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->displayOrdinal = node["displayOrdinal"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing displayOrdinal for struct nvmlFBCSessionInfo_t");
    }
    if (node["sessionType"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->sessionType = static_cast<nvmlFBCSessionType_t>(node["sessionType"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing sessionType for struct nvmlFBCSessionInfo_t");
    }
    if (node["sessionFlags"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->sessionFlags = node["sessionFlags"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sessionFlags for struct nvmlFBCSessionInfo_t");
    }
    if (node["hMaxResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->hMaxResolution = node["hMaxResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hMaxResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["vMaxResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->vMaxResolution = node["vMaxResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vMaxResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["hResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->hResolution = node["hResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing hResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["vResolution"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->vResolution = node["vResolution"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vResolution for struct nvmlFBCSessionInfo_t");
    }
    if (node["averageFPS"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->averageFPS = node["averageFPS"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageFPS for struct nvmlFBCSessionInfo_t");
    }
    if (node["averageLatency"])
    {
        // The following snippet is generated from write_deserializer_definition
        fBCSessionInfo->averageLatency = node["averageLatency"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing averageLatency for struct nvmlFBCSessionInfo_t");
    }
    return fBCSessionInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeSystemCaps_t *nvmlConfComputeSystemCaps_tDeserializer(const YAML::Node &node)
{
    auto *confComputeSystemCaps = reinterpret_cast<nvmlConfComputeSystemCaps_t *>(malloc(sizeof(nvmlConfComputeSystemCaps_t)));
    if (confComputeSystemCaps == nullptr)
    {
        return nullptr;
    }
    memset(confComputeSystemCaps, 0, sizeof(*confComputeSystemCaps));
    if (node["cpuCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemCaps->cpuCaps = node["cpuCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing cpuCaps for struct nvmlConfComputeSystemCaps_t");
    }
    if (node["gpusCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemCaps->gpusCaps = node["gpusCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing gpusCaps for struct nvmlConfComputeSystemCaps_t");
    }
    return confComputeSystemCaps;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeSystemState_t *nvmlConfComputeSystemState_tDeserializer(const YAML::Node &node)
{
    auto *confComputeSystemState = reinterpret_cast<nvmlConfComputeSystemState_t *>(malloc(sizeof(nvmlConfComputeSystemState_t)));
    if (confComputeSystemState == nullptr)
    {
        return nullptr;
    }
    memset(confComputeSystemState, 0, sizeof(*confComputeSystemState));
    if (node["environment"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemState->environment = node["environment"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing environment for struct nvmlConfComputeSystemState_t");
    }
    if (node["ccFeature"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemState->ccFeature = node["ccFeature"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ccFeature for struct nvmlConfComputeSystemState_t");
    }
    if (node["devToolsMode"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSystemState->devToolsMode = node["devToolsMode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing devToolsMode for struct nvmlConfComputeSystemState_t");
    }
    return confComputeSystemState;
}

// The following snippet is generated from write_deserializer_definition
nvmlSystemConfComputeSettings_t *nvmlSystemConfComputeSettings_tDeserializer(const YAML::Node &node)
{
    auto *systemConfComputeSettings = reinterpret_cast<nvmlSystemConfComputeSettings_t *>(malloc(sizeof(nvmlSystemConfComputeSettings_t)));
    if (systemConfComputeSettings == nullptr)
    {
        return nullptr;
    }
    memset(systemConfComputeSettings, 0, sizeof(*systemConfComputeSettings));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        systemConfComputeSettings->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlSystemConfComputeSettings_t");
    }
    if (node["environment"])
    {
        // The following snippet is generated from write_deserializer_definition
        systemConfComputeSettings->environment = node["environment"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing environment for struct nvmlSystemConfComputeSettings_t");
    }
    if (node["ccFeature"])
    {
        // The following snippet is generated from write_deserializer_definition
        systemConfComputeSettings->ccFeature = node["ccFeature"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ccFeature for struct nvmlSystemConfComputeSettings_t");
    }
    if (node["devToolsMode"])
    {
        // The following snippet is generated from write_deserializer_definition
        systemConfComputeSettings->devToolsMode = node["devToolsMode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing devToolsMode for struct nvmlSystemConfComputeSettings_t");
    }
    if (node["multiGpuMode"])
    {
        // The following snippet is generated from write_deserializer_definition
        systemConfComputeSettings->multiGpuMode = node["multiGpuMode"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiGpuMode for struct nvmlSystemConfComputeSettings_t");
    }
    return systemConfComputeSettings;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeMemSizeInfo_t *nvmlConfComputeMemSizeInfo_tDeserializer(const YAML::Node &node)
{
    auto *confComputeMemSizeInfo = reinterpret_cast<nvmlConfComputeMemSizeInfo_t *>(malloc(sizeof(nvmlConfComputeMemSizeInfo_t)));
    if (confComputeMemSizeInfo == nullptr)
    {
        return nullptr;
    }
    memset(confComputeMemSizeInfo, 0, sizeof(*confComputeMemSizeInfo));
    if (node["protectedMemSizeKib"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeMemSizeInfo->protectedMemSizeKib = node["protectedMemSizeKib"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing protectedMemSizeKib for struct nvmlConfComputeMemSizeInfo_t");
    }
    if (node["unprotectedMemSizeKib"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeMemSizeInfo->unprotectedMemSizeKib = node["unprotectedMemSizeKib"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing unprotectedMemSizeKib for struct nvmlConfComputeMemSizeInfo_t");
    }
    return confComputeMemSizeInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeGpuCertificate_t *nvmlConfComputeGpuCertificate_tDeserializer(const YAML::Node &node)
{
    auto *confComputeGpuCertificate = reinterpret_cast<nvmlConfComputeGpuCertificate_t *>(malloc(sizeof(nvmlConfComputeGpuCertificate_t)));
    if (confComputeGpuCertificate == nullptr)
    {
        return nullptr;
    }
    memset(confComputeGpuCertificate, 0, sizeof(*confComputeGpuCertificate));
    if (node["certChainSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuCertificate->certChainSize = node["certChainSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing certChainSize for struct nvmlConfComputeGpuCertificate_t");
    }
    if (node["attestationCertChainSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuCertificate->attestationCertChainSize = node["attestationCertChainSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing attestationCertChainSize for struct nvmlConfComputeGpuCertificate_t");
    }
    if (node["certChain"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto certChain = node["certChain"].as<std::string>();
        std::memcpy(&confComputeGpuCertificate->certChain, certChain.data(), sizeof(confComputeGpuCertificate->certChain));
    }
    else
    {
        NVML_LOG_ERR("missing certChain for struct nvmlConfComputeGpuCertificate_t");
    }
    if (node["attestationCertChain"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto attestationCertChain = node["attestationCertChain"].as<std::string>();
        std::memcpy(&confComputeGpuCertificate->attestationCertChain, attestationCertChain.data(), sizeof(confComputeGpuCertificate->attestationCertChain));
    }
    else
    {
        NVML_LOG_ERR("missing attestationCertChain for struct nvmlConfComputeGpuCertificate_t");
    }
    return confComputeGpuCertificate;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeGpuAttestationReport_t *nvmlConfComputeGpuAttestationReport_tDeserializer(const YAML::Node &node)
{
    auto *confComputeGpuAttestationReport = reinterpret_cast<nvmlConfComputeGpuAttestationReport_t *>(malloc(sizeof(nvmlConfComputeGpuAttestationReport_t)));
    if (confComputeGpuAttestationReport == nullptr)
    {
        return nullptr;
    }
    memset(confComputeGpuAttestationReport, 0, sizeof(*confComputeGpuAttestationReport));
    if (node["isCecAttestationReportPresent"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuAttestationReport->isCecAttestationReportPresent = node["isCecAttestationReportPresent"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isCecAttestationReportPresent for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["attestationReportSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuAttestationReport->attestationReportSize = node["attestationReportSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing attestationReportSize for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["cecAttestationReportSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGpuAttestationReport->cecAttestationReportSize = node["cecAttestationReportSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing cecAttestationReportSize for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["nonce"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto nonce = node["nonce"].as<std::string>();
        std::memcpy(&confComputeGpuAttestationReport->nonce, nonce.data(), sizeof(confComputeGpuAttestationReport->nonce));
    }
    else
    {
        NVML_LOG_ERR("missing nonce for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["attestationReport"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto attestationReport = node["attestationReport"].as<std::string>();
        std::memcpy(&confComputeGpuAttestationReport->attestationReport, attestationReport.data(), sizeof(confComputeGpuAttestationReport->attestationReport));
    }
    else
    {
        NVML_LOG_ERR("missing attestationReport for struct nvmlConfComputeGpuAttestationReport_t");
    }
    if (node["cecAttestationReport"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto cecAttestationReport = node["cecAttestationReport"].as<std::string>();
        std::memcpy(&confComputeGpuAttestationReport->cecAttestationReport, cecAttestationReport.data(), sizeof(confComputeGpuAttestationReport->cecAttestationReport));
    }
    else
    {
        NVML_LOG_ERR("missing cecAttestationReport for struct nvmlConfComputeGpuAttestationReport_t");
    }
    return confComputeGpuAttestationReport;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeSetKeyRotationThresholdInfo_v1_t *nvmlConfComputeSetKeyRotationThresholdInfo_v1_tDeserializer(const YAML::Node &node)
{
    auto *confComputeSetKeyRotationThresholdInfo_v1 = reinterpret_cast<nvmlConfComputeSetKeyRotationThresholdInfo_v1_t *>(malloc(sizeof(nvmlConfComputeSetKeyRotationThresholdInfo_v1_t)));
    if (confComputeSetKeyRotationThresholdInfo_v1 == nullptr)
    {
        return nullptr;
    }
    memset(confComputeSetKeyRotationThresholdInfo_v1, 0, sizeof(*confComputeSetKeyRotationThresholdInfo_v1));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSetKeyRotationThresholdInfo_v1->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlConfComputeSetKeyRotationThresholdInfo_v1_t");
    }
    if (node["maxAttackerAdvantage"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeSetKeyRotationThresholdInfo_v1->maxAttackerAdvantage = node["maxAttackerAdvantage"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing maxAttackerAdvantage for struct nvmlConfComputeSetKeyRotationThresholdInfo_v1_t");
    }
    return confComputeSetKeyRotationThresholdInfo_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlConfComputeGetKeyRotationThresholdInfo_v1_t *nvmlConfComputeGetKeyRotationThresholdInfo_v1_tDeserializer(const YAML::Node &node)
{
    auto *confComputeGetKeyRotationThresholdInfo_v1 = reinterpret_cast<nvmlConfComputeGetKeyRotationThresholdInfo_v1_t *>(malloc(sizeof(nvmlConfComputeGetKeyRotationThresholdInfo_v1_t)));
    if (confComputeGetKeyRotationThresholdInfo_v1 == nullptr)
    {
        return nullptr;
    }
    memset(confComputeGetKeyRotationThresholdInfo_v1, 0, sizeof(*confComputeGetKeyRotationThresholdInfo_v1));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGetKeyRotationThresholdInfo_v1->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlConfComputeGetKeyRotationThresholdInfo_v1_t");
    }
    if (node["attackerAdvantage"])
    {
        // The following snippet is generated from write_deserializer_definition
        confComputeGetKeyRotationThresholdInfo_v1->attackerAdvantage = node["attackerAdvantage"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing attackerAdvantage for struct nvmlConfComputeGetKeyRotationThresholdInfo_v1_t");
    }
    return confComputeGetKeyRotationThresholdInfo_v1;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuFabricInfo_t *nvmlGpuFabricInfo_tDeserializer(const YAML::Node &node)
{
    auto *gpuFabricInfo = reinterpret_cast<nvmlGpuFabricInfo_t *>(malloc(sizeof(nvmlGpuFabricInfo_t)));
    if (gpuFabricInfo == nullptr)
    {
        return nullptr;
    }
    memset(gpuFabricInfo, 0, sizeof(*gpuFabricInfo));
    if (node["clusterUuid"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto clusterUuid = node["clusterUuid"].as<std::string>();
        std::memcpy(&gpuFabricInfo->clusterUuid, clusterUuid.data(), sizeof(gpuFabricInfo->clusterUuid));
    }
    else
    {
        NVML_LOG_ERR("missing clusterUuid for struct nvmlGpuFabricInfo_t");
    }
    if (node["status"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfo->status = static_cast<nvmlReturn_t>(node["status"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing status for struct nvmlGpuFabricInfo_t");
    }
    if (node["cliqueId"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfo->cliqueId = node["cliqueId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing cliqueId for struct nvmlGpuFabricInfo_t");
    }
    if (node["state"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfo->state = static_cast<nvmlGpuFabricState_t>(node["state"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing state for struct nvmlGpuFabricInfo_t");
    }
    return gpuFabricInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuFabricInfoV_t *nvmlGpuFabricInfoV_tDeserializer(const YAML::Node &node)
{
    auto *gpuFabricInfoV = reinterpret_cast<nvmlGpuFabricInfoV_t *>(malloc(sizeof(nvmlGpuFabricInfoV_t)));
    if (gpuFabricInfoV == nullptr)
    {
        return nullptr;
    }
    memset(gpuFabricInfoV, 0, sizeof(*gpuFabricInfoV));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfoV->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlGpuFabricInfoV_t");
    }
    if (node["clusterUuid"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto clusterUuid = node["clusterUuid"].as<std::string>();
        std::memcpy(&gpuFabricInfoV->clusterUuid, clusterUuid.data(), sizeof(gpuFabricInfoV->clusterUuid));
    }
    else
    {
        NVML_LOG_ERR("missing clusterUuid for struct nvmlGpuFabricInfoV_t");
    }
    if (node["status"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfoV->status = static_cast<nvmlReturn_t>(node["status"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing status for struct nvmlGpuFabricInfoV_t");
    }
    if (node["cliqueId"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfoV->cliqueId = node["cliqueId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing cliqueId for struct nvmlGpuFabricInfoV_t");
    }
    if (node["state"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfoV->state = static_cast<nvmlGpuFabricState_t>(node["state"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing state for struct nvmlGpuFabricInfoV_t");
    }
    if (node["healthMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuFabricInfoV->healthMask = node["healthMask"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing healthMask for struct nvmlGpuFabricInfoV_t");
    }
    return gpuFabricInfoV;
}

// The following snippet is generated from write_deserializer_definition
nvmlSystemDriverBranchInfo_t *nvmlSystemDriverBranchInfo_tDeserializer(const YAML::Node &node)
{
    auto *systemDriverBranchInfo = reinterpret_cast<nvmlSystemDriverBranchInfo_t *>(malloc(sizeof(nvmlSystemDriverBranchInfo_t)));
    if (systemDriverBranchInfo == nullptr)
    {
        return nullptr;
    }
    memset(systemDriverBranchInfo, 0, sizeof(*systemDriverBranchInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        systemDriverBranchInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlSystemDriverBranchInfo_t");
    }
    if (node["branch"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto branch = node["branch"].as<std::string>();
        std::memcpy(&systemDriverBranchInfo->branch, branch.data(), sizeof(systemDriverBranchInfo->branch));
    }
    else
    {
        NVML_LOG_ERR("missing branch for struct nvmlSystemDriverBranchInfo_t");
    }
    return systemDriverBranchInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlTemperature_t *nvmlTemperature_tDeserializer(const YAML::Node &node)
{
    auto *temperature = reinterpret_cast<nvmlTemperature_t *>(malloc(sizeof(nvmlTemperature_t)));
    if (temperature == nullptr)
    {
        return nullptr;
    }
    memset(temperature, 0, sizeof(*temperature));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        temperature->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlTemperature_t");
    }
    if (node["sensorType"])
    {
        // The following snippet is generated from write_deserializer_definition
        temperature->sensorType = static_cast<nvmlTemperatureSensors_t>(node["sensorType"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing sensorType for struct nvmlTemperature_t");
    }
    if (node["temperature"])
    {
        // The following snippet is generated from write_deserializer_definition
        temperature->temperature = node["temperature"].as<int>();
    }
    else
    {
        NVML_LOG_ERR("missing temperature for struct nvmlTemperature_t");
    }
    return temperature;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuVersion_t *nvmlVgpuVersion_tDeserializer(const YAML::Node &node)
{
    auto *vgpuVersion = reinterpret_cast<nvmlVgpuVersion_t *>(malloc(sizeof(nvmlVgpuVersion_t)));
    if (vgpuVersion == nullptr)
    {
        return nullptr;
    }
    memset(vgpuVersion, 0, sizeof(*vgpuVersion));
    if (node["minVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuVersion->minVersion = node["minVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing minVersion for struct nvmlVgpuVersion_t");
    }
    if (node["maxVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuVersion->maxVersion = node["maxVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing maxVersion for struct nvmlVgpuVersion_t");
    }
    return vgpuVersion;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuMetadata_t *nvmlVgpuMetadata_tDeserializer(const YAML::Node &node)
{
    auto *vgpuMetadata = reinterpret_cast<nvmlVgpuMetadata_t *>(malloc(sizeof(nvmlVgpuMetadata_t)));
    if (vgpuMetadata == nullptr)
    {
        return nullptr;
    }
    memset(vgpuMetadata, 0, sizeof(*vgpuMetadata));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuMetadata_t");
    }
    if (node["revision"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->revision = node["revision"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing revision for struct nvmlVgpuMetadata_t");
    }
    if (node["guestInfoState"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->guestInfoState = static_cast<nvmlVgpuGuestInfoState_t>(node["guestInfoState"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing guestInfoState for struct nvmlVgpuMetadata_t");
    }
    if (node["guestDriverVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto guestDriverVersion = node["guestDriverVersion"].as<std::string>();
        std::memcpy(&vgpuMetadata->guestDriverVersion, guestDriverVersion.data(), sizeof(vgpuMetadata->guestDriverVersion));
    }
    else
    {
        NVML_LOG_ERR("missing guestDriverVersion for struct nvmlVgpuMetadata_t");
    }
    if (node["hostDriverVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto hostDriverVersion = node["hostDriverVersion"].as<std::string>();
        std::memcpy(&vgpuMetadata->hostDriverVersion, hostDriverVersion.data(), sizeof(vgpuMetadata->hostDriverVersion));
    }
    else
    {
        NVML_LOG_ERR("missing hostDriverVersion for struct nvmlVgpuMetadata_t");
    }
    if (node["vgpuVirtualizationCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->vgpuVirtualizationCaps = node["vgpuVirtualizationCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing vgpuVirtualizationCaps for struct nvmlVgpuMetadata_t");
    }
    if (node["guestVgpuVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->guestVgpuVersion = node["guestVgpuVersion"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing guestVgpuVersion for struct nvmlVgpuMetadata_t");
    }
    if (node["opaqueDataSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuMetadata->opaqueDataSize = node["opaqueDataSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing opaqueDataSize for struct nvmlVgpuMetadata_t");
    }
    return vgpuMetadata;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuPgpuMetadata_t *nvmlVgpuPgpuMetadata_tDeserializer(const YAML::Node &node)
{
    auto *vgpuPgpuMetadata = reinterpret_cast<nvmlVgpuPgpuMetadata_t *>(malloc(sizeof(nvmlVgpuPgpuMetadata_t)));
    if (vgpuPgpuMetadata == nullptr)
    {
        return nullptr;
    }
    memset(vgpuPgpuMetadata, 0, sizeof(*vgpuPgpuMetadata));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["revision"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->revision = node["revision"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing revision for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["hostDriverVersion"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto hostDriverVersion = node["hostDriverVersion"].as<std::string>();
        std::memcpy(&vgpuPgpuMetadata->hostDriverVersion, hostDriverVersion.data(), sizeof(vgpuPgpuMetadata->hostDriverVersion));
    }
    else
    {
        NVML_LOG_ERR("missing hostDriverVersion for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["pgpuVirtualizationCaps"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->pgpuVirtualizationCaps = node["pgpuVirtualizationCaps"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing pgpuVirtualizationCaps for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["hostSupportedVgpuRange"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlVgpuVersion_tDeserializer(node["hostSupportedVgpuRange"]);
        if (!tmp0)
        {
            free(vgpuPgpuMetadata);
            return nullptr;
        }
        std::memcpy(&vgpuPgpuMetadata->hostSupportedVgpuRange, tmp0, sizeof(nvmlVgpuVersion_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing hostSupportedVgpuRange for struct nvmlVgpuPgpuMetadata_t");
    }
    if (node["opaqueDataSize"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuMetadata->opaqueDataSize = node["opaqueDataSize"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing opaqueDataSize for struct nvmlVgpuPgpuMetadata_t");
    }
    return vgpuPgpuMetadata;
}

// The following snippet is generated from write_deserializer_definition
nvmlVgpuPgpuCompatibility_t *nvmlVgpuPgpuCompatibility_tDeserializer(const YAML::Node &node)
{
    auto *vgpuPgpuCompatibility = reinterpret_cast<nvmlVgpuPgpuCompatibility_t *>(malloc(sizeof(nvmlVgpuPgpuCompatibility_t)));
    if (vgpuPgpuCompatibility == nullptr)
    {
        return nullptr;
    }
    memset(vgpuPgpuCompatibility, 0, sizeof(*vgpuPgpuCompatibility));
    if (node["vgpuVmCompatibility"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuCompatibility->vgpuVmCompatibility = static_cast<nvmlVgpuVmCompatibility_t>(node["vgpuVmCompatibility"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing vgpuVmCompatibility for struct nvmlVgpuPgpuCompatibility_t");
    }
    if (node["compatibilityLimitCode"])
    {
        // The following snippet is generated from write_deserializer_definition
        vgpuPgpuCompatibility->compatibilityLimitCode = static_cast<nvmlVgpuPgpuCompatibilityLimitCode_t>(node["compatibilityLimitCode"].as<int>());
    }
    else
    {
        NVML_LOG_ERR("missing compatibilityLimitCode for struct nvmlVgpuPgpuCompatibility_t");
    }
    return vgpuPgpuCompatibility;
}

// The following snippet is generated from write_deserializer_definition
nvmlExcludedDeviceInfo_t *nvmlExcludedDeviceInfo_tDeserializer(const YAML::Node &node)
{
    auto *excludedDeviceInfo = reinterpret_cast<nvmlExcludedDeviceInfo_t *>(malloc(sizeof(nvmlExcludedDeviceInfo_t)));
    if (excludedDeviceInfo == nullptr)
    {
        return nullptr;
    }
    memset(excludedDeviceInfo, 0, sizeof(*excludedDeviceInfo));
    if (node["pciInfo"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlPciInfo_tDeserializer(node["pciInfo"]);
        if (!tmp0)
        {
            free(excludedDeviceInfo);
            return nullptr;
        }
        std::memcpy(&excludedDeviceInfo->pciInfo, tmp0, sizeof(nvmlPciInfo_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing pciInfo for struct nvmlExcludedDeviceInfo_t");
    }
    if (node["uuid"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto uuid = node["uuid"].as<std::string>();
        std::memcpy(&excludedDeviceInfo->uuid, uuid.data(), sizeof(excludedDeviceInfo->uuid));
    }
    else
    {
        NVML_LOG_ERR("missing uuid for struct nvmlExcludedDeviceInfo_t");
    }
    return excludedDeviceInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuInstancePlacement_t *nvmlGpuInstancePlacement_tDeserializer(const YAML::Node &node)
{
    auto *gpuInstancePlacement = reinterpret_cast<nvmlGpuInstancePlacement_t *>(malloc(sizeof(nvmlGpuInstancePlacement_t)));
    if (gpuInstancePlacement == nullptr)
    {
        return nullptr;
    }
    memset(gpuInstancePlacement, 0, sizeof(*gpuInstancePlacement));
    if (node["start"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstancePlacement->start = node["start"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing start for struct nvmlGpuInstancePlacement_t");
    }
    if (node["size"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstancePlacement->size = node["size"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing size for struct nvmlGpuInstancePlacement_t");
    }
    return gpuInstancePlacement;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuInstanceProfileInfo_t *nvmlGpuInstanceProfileInfo_tDeserializer(const YAML::Node &node)
{
    auto *gpuInstanceProfileInfo = reinterpret_cast<nvmlGpuInstanceProfileInfo_t *>(malloc(sizeof(nvmlGpuInstanceProfileInfo_t)));
    if (gpuInstanceProfileInfo == nullptr)
    {
        return nullptr;
    }
    memset(gpuInstanceProfileInfo, 0, sizeof(*gpuInstanceProfileInfo));
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["isP2pSupported"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->isP2pSupported = node["isP2pSupported"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isP2pSupported for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["copyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->copyEngineCount = node["copyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing copyEngineCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["decoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->decoderCount = node["decoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decoderCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["encoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->encoderCount = node["encoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encoderCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["jpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->jpegCount = node["jpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing jpegCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["ofaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->ofaCount = node["ofaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ofaCount for struct nvmlGpuInstanceProfileInfo_t");
    }
    if (node["memorySizeMB"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo->memorySizeMB = node["memorySizeMB"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing memorySizeMB for struct nvmlGpuInstanceProfileInfo_t");
    }
    return gpuInstanceProfileInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuInstanceProfileInfo_v2_t *nvmlGpuInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node)
{
    auto *gpuInstanceProfileInfo_v2 = reinterpret_cast<nvmlGpuInstanceProfileInfo_v2_t *>(malloc(sizeof(nvmlGpuInstanceProfileInfo_v2_t)));
    if (gpuInstanceProfileInfo_v2 == nullptr)
    {
        return nullptr;
    }
    memset(gpuInstanceProfileInfo_v2, 0, sizeof(*gpuInstanceProfileInfo_v2));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["isP2pSupported"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->isP2pSupported = node["isP2pSupported"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isP2pSupported for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["copyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->copyEngineCount = node["copyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing copyEngineCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["decoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->decoderCount = node["decoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decoderCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["encoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->encoderCount = node["encoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encoderCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["jpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->jpegCount = node["jpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing jpegCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["ofaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->ofaCount = node["ofaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ofaCount for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["memorySizeMB"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v2->memorySizeMB = node["memorySizeMB"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing memorySizeMB for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&gpuInstanceProfileInfo_v2->name, name.data(), sizeof(gpuInstanceProfileInfo_v2->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlGpuInstanceProfileInfo_v2_t");
    }
    return gpuInstanceProfileInfo_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpuInstanceProfileInfo_v3_t *nvmlGpuInstanceProfileInfo_v3_tDeserializer(const YAML::Node &node)
{
    auto *gpuInstanceProfileInfo_v3 = reinterpret_cast<nvmlGpuInstanceProfileInfo_v3_t *>(malloc(sizeof(nvmlGpuInstanceProfileInfo_v3_t)));
    if (gpuInstanceProfileInfo_v3 == nullptr)
    {
        return nullptr;
    }
    memset(gpuInstanceProfileInfo_v3, 0, sizeof(*gpuInstanceProfileInfo_v3));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["copyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->copyEngineCount = node["copyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing copyEngineCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["decoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->decoderCount = node["decoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing decoderCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["encoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->encoderCount = node["encoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing encoderCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["jpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->jpegCount = node["jpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing jpegCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["ofaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->ofaCount = node["ofaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing ofaCount for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["memorySizeMB"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->memorySizeMB = node["memorySizeMB"].as<unsigned long long>();
    }
    else
    {
        NVML_LOG_ERR("missing memorySizeMB for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&gpuInstanceProfileInfo_v3->name, name.data(), sizeof(gpuInstanceProfileInfo_v3->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    if (node["capabilities"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpuInstanceProfileInfo_v3->capabilities = node["capabilities"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing capabilities for struct nvmlGpuInstanceProfileInfo_v3_t");
    }
    return gpuInstanceProfileInfo_v3;
}

// The following snippet is generated from write_deserializer_definition
nvmlComputeInstancePlacement_t *nvmlComputeInstancePlacement_tDeserializer(const YAML::Node &node)
{
    auto *computeInstancePlacement = reinterpret_cast<nvmlComputeInstancePlacement_t *>(malloc(sizeof(nvmlComputeInstancePlacement_t)));
    if (computeInstancePlacement == nullptr)
    {
        return nullptr;
    }
    memset(computeInstancePlacement, 0, sizeof(*computeInstancePlacement));
    if (node["start"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstancePlacement->start = node["start"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing start for struct nvmlComputeInstancePlacement_t");
    }
    if (node["size"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstancePlacement->size = node["size"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing size for struct nvmlComputeInstancePlacement_t");
    }
    return computeInstancePlacement;
}

// The following snippet is generated from write_deserializer_definition
nvmlComputeInstanceProfileInfo_t *nvmlComputeInstanceProfileInfo_tDeserializer(const YAML::Node &node)
{
    auto *computeInstanceProfileInfo = reinterpret_cast<nvmlComputeInstanceProfileInfo_t *>(malloc(sizeof(nvmlComputeInstanceProfileInfo_t)));
    if (computeInstanceProfileInfo == nullptr)
    {
        return nullptr;
    }
    memset(computeInstanceProfileInfo, 0, sizeof(*computeInstanceProfileInfo));
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedCopyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedCopyEngineCount = node["sharedCopyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedCopyEngineCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedDecoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedDecoderCount = node["sharedDecoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedDecoderCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedEncoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedEncoderCount = node["sharedEncoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedEncoderCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedJpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedJpegCount = node["sharedJpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedJpegCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    if (node["sharedOfaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo->sharedOfaCount = node["sharedOfaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedOfaCount for struct nvmlComputeInstanceProfileInfo_t");
    }
    return computeInstanceProfileInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlComputeInstanceProfileInfo_v2_t *nvmlComputeInstanceProfileInfo_v2_tDeserializer(const YAML::Node &node)
{
    auto *computeInstanceProfileInfo_v2 = reinterpret_cast<nvmlComputeInstanceProfileInfo_v2_t *>(malloc(sizeof(nvmlComputeInstanceProfileInfo_v2_t)));
    if (computeInstanceProfileInfo_v2 == nullptr)
    {
        return nullptr;
    }
    memset(computeInstanceProfileInfo_v2, 0, sizeof(*computeInstanceProfileInfo_v2));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedCopyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedCopyEngineCount = node["sharedCopyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedCopyEngineCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedDecoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedDecoderCount = node["sharedDecoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedDecoderCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedEncoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedEncoderCount = node["sharedEncoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedEncoderCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedJpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedJpegCount = node["sharedJpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedJpegCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["sharedOfaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v2->sharedOfaCount = node["sharedOfaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedOfaCount for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&computeInstanceProfileInfo_v2->name, name.data(), sizeof(computeInstanceProfileInfo_v2->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlComputeInstanceProfileInfo_v2_t");
    }
    return computeInstanceProfileInfo_v2;
}

// The following snippet is generated from write_deserializer_definition
nvmlComputeInstanceProfileInfo_v3_t *nvmlComputeInstanceProfileInfo_v3_tDeserializer(const YAML::Node &node)
{
    auto *computeInstanceProfileInfo_v3 = reinterpret_cast<nvmlComputeInstanceProfileInfo_v3_t *>(malloc(sizeof(nvmlComputeInstanceProfileInfo_v3_t)));
    if (computeInstanceProfileInfo_v3 == nullptr)
    {
        return nullptr;
    }
    memset(computeInstanceProfileInfo_v3, 0, sizeof(*computeInstanceProfileInfo_v3));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["id"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->id = node["id"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing id for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["sliceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->sliceCount = node["sliceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sliceCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["instanceCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->instanceCount = node["instanceCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing instanceCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["multiprocessorCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->multiprocessorCount = node["multiprocessorCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing multiprocessorCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["sharedCopyEngineCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->sharedCopyEngineCount = node["sharedCopyEngineCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedCopyEngineCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["sharedDecoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->sharedDecoderCount = node["sharedDecoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedDecoderCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["sharedEncoderCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->sharedEncoderCount = node["sharedEncoderCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedEncoderCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["sharedJpegCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->sharedJpegCount = node["sharedJpegCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedJpegCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["sharedOfaCount"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->sharedOfaCount = node["sharedOfaCount"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing sharedOfaCount for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["name"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto name = node["name"].as<std::string>();
        std::memcpy(&computeInstanceProfileInfo_v3->name, name.data(), sizeof(computeInstanceProfileInfo_v3->name));
    }
    else
    {
        NVML_LOG_ERR("missing name for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    if (node["capabilities"])
    {
        // The following snippet is generated from write_deserializer_definition
        computeInstanceProfileInfo_v3->capabilities = node["capabilities"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing capabilities for struct nvmlComputeInstanceProfileInfo_v3_t");
    }
    return computeInstanceProfileInfo_v3;
}

// The following snippet is generated from write_deserializer_definition
nvmlGpmSupport_t *nvmlGpmSupport_tDeserializer(const YAML::Node &node)
{
    auto *gpmSupport = reinterpret_cast<nvmlGpmSupport_t *>(malloc(sizeof(nvmlGpmSupport_t)));
    if (gpmSupport == nullptr)
    {
        return nullptr;
    }
    memset(gpmSupport, 0, sizeof(*gpmSupport));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpmSupport->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlGpmSupport_t");
    }
    if (node["isSupportedDevice"])
    {
        // The following snippet is generated from write_deserializer_definition
        gpmSupport->isSupportedDevice = node["isSupportedDevice"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing isSupportedDevice for struct nvmlGpmSupport_t");
    }
    return gpmSupport;
}

// The following snippet is generated from write_deserializer_definition
nvmlDeviceCapabilities_t *nvmlDeviceCapabilities_tDeserializer(const YAML::Node &node)
{
    auto *deviceCapabilities = reinterpret_cast<nvmlDeviceCapabilities_t *>(malloc(sizeof(nvmlDeviceCapabilities_t)));
    if (deviceCapabilities == nullptr)
    {
        return nullptr;
    }
    memset(deviceCapabilities, 0, sizeof(*deviceCapabilities));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceCapabilities->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlDeviceCapabilities_t");
    }
    if (node["capMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        deviceCapabilities->capMask = node["capMask"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing capMask for struct nvmlDeviceCapabilities_t");
    }
    return deviceCapabilities;
}

// The following snippet is generated from write_deserializer_definition
nvmlMask255_t *nvmlMask255_tDeserializer(const YAML::Node &node)
{
    auto *mask255 = reinterpret_cast<nvmlMask255_t *>(malloc(sizeof(nvmlMask255_t)));
    if (mask255 == nullptr)
    {
        return nullptr;
    }
    memset(mask255, 0, sizeof(*mask255));
    if (node["mask"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto const tmp0 = node["mask"].as<std::vector<unsigned int>>();
        for (unsigned int ii = 0; ii < tmp0.size(); ++ii)
        {
            mask255->mask[ii] = tmp0[ii];
        }
    }
    else
    {
        NVML_LOG_ERR("missing mask for struct nvmlMask255_t");
    }
    return mask255;
}

// The following snippet is generated from write_deserializer_definition
nvmlWorkloadPowerProfileInfo_t *nvmlWorkloadPowerProfileInfo_tDeserializer(const YAML::Node &node)
{
    auto *workloadPowerProfileInfo = reinterpret_cast<nvmlWorkloadPowerProfileInfo_t *>(malloc(sizeof(nvmlWorkloadPowerProfileInfo_t)));
    if (workloadPowerProfileInfo == nullptr)
    {
        return nullptr;
    }
    memset(workloadPowerProfileInfo, 0, sizeof(*workloadPowerProfileInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        workloadPowerProfileInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlWorkloadPowerProfileInfo_t");
    }
    if (node["profileId"])
    {
        // The following snippet is generated from write_deserializer_definition
        workloadPowerProfileInfo->profileId = node["profileId"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing profileId for struct nvmlWorkloadPowerProfileInfo_t");
    }
    if (node["priority"])
    {
        // The following snippet is generated from write_deserializer_definition
        workloadPowerProfileInfo->priority = node["priority"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing priority for struct nvmlWorkloadPowerProfileInfo_t");
    }
    if (node["conflictingMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlMask255_tDeserializer(node["conflictingMask"]);
        if (!tmp0)
        {
            free(workloadPowerProfileInfo);
            return nullptr;
        }
        std::memcpy(&workloadPowerProfileInfo->conflictingMask, tmp0, sizeof(nvmlMask255_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing conflictingMask for struct nvmlWorkloadPowerProfileInfo_t");
    }
    return workloadPowerProfileInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlWorkloadPowerProfileProfilesInfo_t *nvmlWorkloadPowerProfileProfilesInfo_tDeserializer(const YAML::Node &node)
{
    auto *workloadPowerProfileProfilesInfo = reinterpret_cast<nvmlWorkloadPowerProfileProfilesInfo_t *>(malloc(sizeof(nvmlWorkloadPowerProfileProfilesInfo_t)));
    if (workloadPowerProfileProfilesInfo == nullptr)
    {
        return nullptr;
    }
    memset(workloadPowerProfileProfilesInfo, 0, sizeof(*workloadPowerProfileProfilesInfo));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        workloadPowerProfileProfilesInfo->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlWorkloadPowerProfileProfilesInfo_t");
    }
    if (node["perfProfilesMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlMask255_tDeserializer(node["perfProfilesMask"]);
        if (!tmp0)
        {
            free(workloadPowerProfileProfilesInfo);
            return nullptr;
        }
        std::memcpy(&workloadPowerProfileProfilesInfo->perfProfilesMask, tmp0, sizeof(nvmlMask255_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing perfProfilesMask for struct nvmlWorkloadPowerProfileProfilesInfo_t");
    }
    if (node["perfProfile"])
    {
        // The following snippet is generated from write_deserializer_definition
        int idx = 0;
        int size = std::min(node["perfProfile"].size(), sizeof(workloadPowerProfileProfilesInfo->perfProfile) / sizeof(nvmlWorkloadPowerProfileInfo_t));
        for (YAML::const_iterator it = node["perfProfile"].begin(); it != node["perfProfile"].end(); ++it)
        {
            auto *tmp = nvmlWorkloadPowerProfileInfo_tDeserializer(*it);
            if (!tmp)
            {
                free(workloadPowerProfileProfilesInfo);
                return nullptr;
            }
            if (idx >= size)
            {
                break;
            }
            std::memcpy(&workloadPowerProfileProfilesInfo->perfProfile[idx++], tmp, sizeof(nvmlWorkloadPowerProfileInfo_t));
            free(tmp);
        }
    }
    else
    {
        NVML_LOG_ERR("missing perfProfile for struct nvmlWorkloadPowerProfileProfilesInfo_t");
    }
    return workloadPowerProfileProfilesInfo;
}

// The following snippet is generated from write_deserializer_definition
nvmlWorkloadPowerProfileCurrentProfiles_t *nvmlWorkloadPowerProfileCurrentProfiles_tDeserializer(const YAML::Node &node)
{
    auto *workloadPowerProfileCurrentProfiles = reinterpret_cast<nvmlWorkloadPowerProfileCurrentProfiles_t *>(malloc(sizeof(nvmlWorkloadPowerProfileCurrentProfiles_t)));
    if (workloadPowerProfileCurrentProfiles == nullptr)
    {
        return nullptr;
    }
    memset(workloadPowerProfileCurrentProfiles, 0, sizeof(*workloadPowerProfileCurrentProfiles));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        workloadPowerProfileCurrentProfiles->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlWorkloadPowerProfileCurrentProfiles_t");
    }
    if (node["perfProfilesMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlMask255_tDeserializer(node["perfProfilesMask"]);
        if (!tmp0)
        {
            free(workloadPowerProfileCurrentProfiles);
            return nullptr;
        }
        std::memcpy(&workloadPowerProfileCurrentProfiles->perfProfilesMask, tmp0, sizeof(nvmlMask255_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing perfProfilesMask for struct nvmlWorkloadPowerProfileCurrentProfiles_t");
    }
    if (node["requestedProfilesMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp1 = nvmlMask255_tDeserializer(node["requestedProfilesMask"]);
        if (!tmp1)
        {
            free(workloadPowerProfileCurrentProfiles);
            return nullptr;
        }
        std::memcpy(&workloadPowerProfileCurrentProfiles->requestedProfilesMask, tmp1, sizeof(nvmlMask255_t));
        free(tmp1);
    }
    else
    {
        NVML_LOG_ERR("missing requestedProfilesMask for struct nvmlWorkloadPowerProfileCurrentProfiles_t");
    }
    if (node["enforcedProfilesMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp2 = nvmlMask255_tDeserializer(node["enforcedProfilesMask"]);
        if (!tmp2)
        {
            free(workloadPowerProfileCurrentProfiles);
            return nullptr;
        }
        std::memcpy(&workloadPowerProfileCurrentProfiles->enforcedProfilesMask, tmp2, sizeof(nvmlMask255_t));
        free(tmp2);
    }
    else
    {
        NVML_LOG_ERR("missing enforcedProfilesMask for struct nvmlWorkloadPowerProfileCurrentProfiles_t");
    }
    return workloadPowerProfileCurrentProfiles;
}

// The following snippet is generated from write_deserializer_definition
nvmlWorkloadPowerProfileRequestedProfiles_t *nvmlWorkloadPowerProfileRequestedProfiles_tDeserializer(const YAML::Node &node)
{
    auto *workloadPowerProfileRequestedProfiles = reinterpret_cast<nvmlWorkloadPowerProfileRequestedProfiles_t *>(malloc(sizeof(nvmlWorkloadPowerProfileRequestedProfiles_t)));
    if (workloadPowerProfileRequestedProfiles == nullptr)
    {
        return nullptr;
    }
    memset(workloadPowerProfileRequestedProfiles, 0, sizeof(*workloadPowerProfileRequestedProfiles));
    if (node["version"])
    {
        // The following snippet is generated from write_deserializer_definition
        workloadPowerProfileRequestedProfiles->version = node["version"].as<unsigned int>();
    }
    else
    {
        NVML_LOG_ERR("missing version for struct nvmlWorkloadPowerProfileRequestedProfiles_t");
    }
    if (node["requestedProfilesMask"])
    {
        // The following snippet is generated from write_deserializer_definition
        auto *tmp0 = nvmlMask255_tDeserializer(node["requestedProfilesMask"]);
        if (!tmp0)
        {
            free(workloadPowerProfileRequestedProfiles);
            return nullptr;
        }
        std::memcpy(&workloadPowerProfileRequestedProfiles->requestedProfilesMask, tmp0, sizeof(nvmlMask255_t));
        free(tmp0);
    }
    else
    {
        NVML_LOG_ERR("missing requestedProfilesMask for struct nvmlWorkloadPowerProfileRequestedProfiles_t");
    }
    return workloadPowerProfileRequestedProfiles;
}

// The following snippet is generated from write_basic_type_parser
template <typename underlyType, typename resultType>
std::optional<NvmlFuncReturn> BasicTypeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto value = static_cast<resultType>(node["ReturnValue"].as<underlyType>());
    return NvmlFuncReturn(ret, std::move(value));
}

// The following snippet is generated from write_basic_key_type_parser
template <typename underlyType, typename resultType>
std::optional<InjectionArgument> BasicKeyTypeParser(const YAML::Node &node)
{
    if (!node)
    {
        return std::nullopt;
    }
    return static_cast<resultType>(node.as<underlyType>());
}

// The following snippet is generated from write_nvml_return_parser
std::optional<NvmlFuncReturn> NvmlReturnParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    return NvmlFuncReturn(ret);
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> PciInfoExtParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *pciInfoExt = nvmlPciInfoExt_tDeserializer(node["ReturnValue"]);
    if (pciInfoExt == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {pciInfoExt, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> PciInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *pciInfo = nvmlPciInfo_tDeserializer(node["ReturnValue"]);
    if (pciInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {pciInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> EccErrorCountsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *eccErrorCounts = nvmlEccErrorCounts_tDeserializer(node["ReturnValue"]);
    if (eccErrorCounts == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {eccErrorCounts, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> UtilizationParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *utilization = nvmlUtilization_tDeserializer(node["ReturnValue"]);
    if (utilization == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {utilization, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> MemoryParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *memory = nvmlMemory_tDeserializer(node["ReturnValue"]);
    if (memory == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {memory, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> Memory_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *memory_v2 = nvmlMemory_v2_tDeserializer(node["ReturnValue"]);
    if (memory_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {memory_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> BAR1MemoryParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *bAR1Memory = nvmlBAR1Memory_tDeserializer(node["ReturnValue"]);
    if (bAR1Memory == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {bAR1Memory, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessInfo_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processInfo_v1 = nvmlProcessInfo_v1_tDeserializer(node["ReturnValue"]);
    if (processInfo_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processInfo_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processInfo = nvmlProcessInfo_tDeserializer(node["ReturnValue"]);
    if (processInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessDetail_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processDetail_v1 = nvmlProcessDetail_v1_tDeserializer(node["ReturnValue"]);
    if (processDetail_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processDetail_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessDetailListParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processDetailList = nvmlProcessDetailList_tDeserializer(node["ReturnValue"]);
    if (processDetailList == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processDetailList, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> DeviceAttributesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *deviceAttributes = nvmlDeviceAttributes_tDeserializer(node["ReturnValue"]);
    if (deviceAttributes == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {deviceAttributes, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> C2cModeInfo_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *c2cModeInfo_v1 = nvmlC2cModeInfo_v1_tDeserializer(node["ReturnValue"]);
    if (c2cModeInfo_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {c2cModeInfo_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> RowRemapperHistogramValuesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *rowRemapperHistogramValues = nvmlRowRemapperHistogramValues_tDeserializer(node["ReturnValue"]);
    if (rowRemapperHistogramValues == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {rowRemapperHistogramValues, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> NvLinkUtilizationControlParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *nvLinkUtilizationControl = nvmlNvLinkUtilizationControl_tDeserializer(node["ReturnValue"]);
    if (nvLinkUtilizationControl == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {nvLinkUtilizationControl, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> BridgeChipHierarchyParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *bridgeChipHierarchy = nvmlBridgeChipHierarchy_tDeserializer(node["ReturnValue"]);
    if (bridgeChipHierarchy == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {bridgeChipHierarchy, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ViolationTimeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *violationTime = nvmlViolationTime_tDeserializer(node["ReturnValue"]);
    if (violationTime == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {violationTime, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> CoolerInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *coolerInfo = nvmlCoolerInfo_tDeserializer(node["ReturnValue"]);
    if (coolerInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {coolerInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ClockOffsetParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *clockOffset = nvmlClockOffset_tDeserializer(node["ReturnValue"]);
    if (clockOffset == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {clockOffset, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> FanSpeedInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *fanSpeedInfo = nvmlFanSpeedInfo_tDeserializer(node["ReturnValue"]);
    if (fanSpeedInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {fanSpeedInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> DevicePerfModesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *devicePerfModes = nvmlDevicePerfModes_tDeserializer(node["ReturnValue"]);
    if (devicePerfModes == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {devicePerfModes, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> DeviceCurrentClockFreqsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *deviceCurrentClockFreqs = nvmlDeviceCurrentClockFreqs_tDeserializer(node["ReturnValue"]);
    if (deviceCurrentClockFreqs == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {deviceCurrentClockFreqs, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessUtilizationSampleParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processUtilizationSample = nvmlProcessUtilizationSample_tDeserializer(node["ReturnValue"]);
    if (processUtilizationSample == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processUtilizationSample, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessUtilizationInfo_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processUtilizationInfo_v1 = nvmlProcessUtilizationInfo_v1_tDeserializer(node["ReturnValue"]);
    if (processUtilizationInfo_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processUtilizationInfo_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ProcessesUtilizationInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *processesUtilizationInfo = nvmlProcessesUtilizationInfo_tDeserializer(node["ReturnValue"]);
    if (processesUtilizationInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {processesUtilizationInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> EccSramErrorStatusParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *eccSramErrorStatus = nvmlEccSramErrorStatus_tDeserializer(node["ReturnValue"]);
    if (eccSramErrorStatus == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {eccSramErrorStatus, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> PlatformInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *platformInfo = nvmlPlatformInfo_tDeserializer(node["ReturnValue"]);
    if (platformInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {platformInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> PowerValue_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *powerValue_v2 = nvmlPowerValue_v2_tDeserializer(node["ReturnValue"]);
    if (powerValue_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {powerValue_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuHeterogeneousModeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuHeterogeneousMode = nvmlVgpuHeterogeneousMode_tDeserializer(node["ReturnValue"]);
    if (vgpuHeterogeneousMode == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuHeterogeneousMode, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuPlacementIdParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuPlacementId = nvmlVgpuPlacementId_tDeserializer(node["ReturnValue"]);
    if (vgpuPlacementId == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuPlacementId, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuPlacementList_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuPlacementList_v1 = nvmlVgpuPlacementList_v1_tDeserializer(node["ReturnValue"]);
    if (vgpuPlacementList_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuPlacementList_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuPlacementListParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuPlacementList = nvmlVgpuPlacementList_tDeserializer(node["ReturnValue"]);
    if (vgpuPlacementList == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuPlacementList, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuTypeBar1InfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuTypeBar1Info = nvmlVgpuTypeBar1Info_tDeserializer(node["ReturnValue"]);
    if (vgpuTypeBar1Info == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuTypeBar1Info, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuInstancesUtilizationInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuInstancesUtilizationInfo = nvmlVgpuInstancesUtilizationInfo_tDeserializer(node["ReturnValue"]);
    if (vgpuInstancesUtilizationInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuInstancesUtilizationInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuProcessUtilizationSampleParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuProcessUtilizationSample = nvmlVgpuProcessUtilizationSample_tDeserializer(node["ReturnValue"]);
    if (vgpuProcessUtilizationSample == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuProcessUtilizationSample, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuProcessUtilizationInfo_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuProcessUtilizationInfo_v1 = nvmlVgpuProcessUtilizationInfo_v1_tDeserializer(node["ReturnValue"]);
    if (vgpuProcessUtilizationInfo_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuProcessUtilizationInfo_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuProcessesUtilizationInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuProcessesUtilizationInfo = nvmlVgpuProcessesUtilizationInfo_tDeserializer(node["ReturnValue"]);
    if (vgpuProcessesUtilizationInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuProcessesUtilizationInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuSchedulerLogEntryParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuSchedulerLogEntry = nvmlVgpuSchedulerLogEntry_tDeserializer(node["ReturnValue"]);
    if (vgpuSchedulerLogEntry == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuSchedulerLogEntry, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuSchedulerLogParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuSchedulerLog = nvmlVgpuSchedulerLog_tDeserializer(node["ReturnValue"]);
    if (vgpuSchedulerLog == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuSchedulerLog, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuSchedulerGetStateParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuSchedulerGetState = nvmlVgpuSchedulerGetState_tDeserializer(node["ReturnValue"]);
    if (vgpuSchedulerGetState == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuSchedulerGetState, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuSchedulerSetStateParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuSchedulerSetState = nvmlVgpuSchedulerSetState_tDeserializer(node["ReturnValue"]);
    if (vgpuSchedulerSetState == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuSchedulerSetState, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuSchedulerCapabilitiesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuSchedulerCapabilities = nvmlVgpuSchedulerCapabilities_tDeserializer(node["ReturnValue"]);
    if (vgpuSchedulerCapabilities == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuSchedulerCapabilities, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuLicenseInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuLicenseInfo = nvmlVgpuLicenseInfo_tDeserializer(node["ReturnValue"]);
    if (vgpuLicenseInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuLicenseInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GridLicensableFeaturesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gridLicensableFeatures = nvmlGridLicensableFeatures_tDeserializer(node["ReturnValue"]);
    if (gridLicensableFeatures == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gridLicensableFeatures, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> NvLinkPowerThresParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *nvLinkPowerThres = nvmlNvLinkPowerThres_tDeserializer(node["ReturnValue"]);
    if (nvLinkPowerThres == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {nvLinkPowerThres, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> HwbcEntryParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *hwbcEntry = nvmlHwbcEntry_tDeserializer(node["ReturnValue"]);
    if (hwbcEntry == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {hwbcEntry, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> LedStateParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *ledState = nvmlLedState_tDeserializer(node["ReturnValue"]);
    if (ledState == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {ledState, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> UnitInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *unitInfo = nvmlUnitInfo_tDeserializer(node["ReturnValue"]);
    if (unitInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {unitInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> PSUInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *pSUInfo = nvmlPSUInfo_tDeserializer(node["ReturnValue"]);
    if (pSUInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {pSUInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> UnitFanSpeedsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *unitFanSpeeds = nvmlUnitFanSpeeds_tDeserializer(node["ReturnValue"]);
    if (unitFanSpeeds == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {unitFanSpeeds, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> AccountingStatsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *accountingStats = nvmlAccountingStats_tDeserializer(node["ReturnValue"]);
    if (accountingStats == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {accountingStats, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> EncoderSessionInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *encoderSessionInfo = nvmlEncoderSessionInfo_tDeserializer(node["ReturnValue"]);
    if (encoderSessionInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {encoderSessionInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> FBCStatsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *fBCStats = nvmlFBCStats_tDeserializer(node["ReturnValue"]);
    if (fBCStats == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {fBCStats, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> FBCSessionInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *fBCSessionInfo = nvmlFBCSessionInfo_tDeserializer(node["ReturnValue"]);
    if (fBCSessionInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {fBCSessionInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ConfComputeSystemStateParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *confComputeSystemState = nvmlConfComputeSystemState_tDeserializer(node["ReturnValue"]);
    if (confComputeSystemState == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {confComputeSystemState, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> SystemConfComputeSettingsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *systemConfComputeSettings = nvmlSystemConfComputeSettings_tDeserializer(node["ReturnValue"]);
    if (systemConfComputeSettings == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {systemConfComputeSettings, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ConfComputeSetKeyRotationThresholdInfo_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *confComputeSetKeyRotationThresholdInfo_v1 = nvmlConfComputeSetKeyRotationThresholdInfo_v1_tDeserializer(node["ReturnValue"]);
    if (confComputeSetKeyRotationThresholdInfo_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {confComputeSetKeyRotationThresholdInfo_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ConfComputeGetKeyRotationThresholdInfo_v1Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *confComputeGetKeyRotationThresholdInfo_v1 = nvmlConfComputeGetKeyRotationThresholdInfo_v1_tDeserializer(node["ReturnValue"]);
    if (confComputeGetKeyRotationThresholdInfo_v1 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {confComputeGetKeyRotationThresholdInfo_v1, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuFabricInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuFabricInfo = nvmlGpuFabricInfo_tDeserializer(node["ReturnValue"]);
    if (gpuFabricInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuFabricInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuFabricInfoVParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuFabricInfoV = nvmlGpuFabricInfoV_tDeserializer(node["ReturnValue"]);
    if (gpuFabricInfoV == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuFabricInfoV, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> SystemDriverBranchInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *systemDriverBranchInfo = nvmlSystemDriverBranchInfo_tDeserializer(node["ReturnValue"]);
    if (systemDriverBranchInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {systemDriverBranchInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> TemperatureParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *temperature = nvmlTemperature_tDeserializer(node["ReturnValue"]);
    if (temperature == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {temperature, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuVersionParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuVersion = nvmlVgpuVersion_tDeserializer(node["ReturnValue"]);
    if (vgpuVersion == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuVersion, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuMetadataParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuMetadata = nvmlVgpuMetadata_tDeserializer(node["ReturnValue"]);
    if (vgpuMetadata == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuMetadata, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuPgpuMetadataParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuPgpuMetadata = nvmlVgpuPgpuMetadata_tDeserializer(node["ReturnValue"]);
    if (vgpuPgpuMetadata == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuPgpuMetadata, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> VgpuPgpuCompatibilityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *vgpuPgpuCompatibility = nvmlVgpuPgpuCompatibility_tDeserializer(node["ReturnValue"]);
    if (vgpuPgpuCompatibility == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {vgpuPgpuCompatibility, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ExcludedDeviceInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *excludedDeviceInfo = nvmlExcludedDeviceInfo_tDeserializer(node["ReturnValue"]);
    if (excludedDeviceInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {excludedDeviceInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuInstancePlacementParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuInstancePlacement = nvmlGpuInstancePlacement_tDeserializer(node["ReturnValue"]);
    if (gpuInstancePlacement == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuInstancePlacement, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuInstanceProfileInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuInstanceProfileInfo = nvmlGpuInstanceProfileInfo_tDeserializer(node["ReturnValue"]);
    if (gpuInstanceProfileInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuInstanceProfileInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuInstanceProfileInfo_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuInstanceProfileInfo_v2 = nvmlGpuInstanceProfileInfo_v2_tDeserializer(node["ReturnValue"]);
    if (gpuInstanceProfileInfo_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuInstanceProfileInfo_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpuInstanceProfileInfo_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpuInstanceProfileInfo_v3 = nvmlGpuInstanceProfileInfo_v3_tDeserializer(node["ReturnValue"]);
    if (gpuInstanceProfileInfo_v3 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpuInstanceProfileInfo_v3, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ComputeInstanceProfileInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *computeInstanceProfileInfo = nvmlComputeInstanceProfileInfo_tDeserializer(node["ReturnValue"]);
    if (computeInstanceProfileInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {computeInstanceProfileInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ComputeInstanceProfileInfo_v2Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *computeInstanceProfileInfo_v2 = nvmlComputeInstanceProfileInfo_v2_tDeserializer(node["ReturnValue"]);
    if (computeInstanceProfileInfo_v2 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {computeInstanceProfileInfo_v2, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> ComputeInstanceProfileInfo_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *computeInstanceProfileInfo_v3 = nvmlComputeInstanceProfileInfo_v3_tDeserializer(node["ReturnValue"]);
    if (computeInstanceProfileInfo_v3 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {computeInstanceProfileInfo_v3, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> GpmSupportParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *gpmSupport = nvmlGpmSupport_tDeserializer(node["ReturnValue"]);
    if (gpmSupport == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {gpmSupport, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> DeviceCapabilitiesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *deviceCapabilities = nvmlDeviceCapabilities_tDeserializer(node["ReturnValue"]);
    if (deviceCapabilities == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {deviceCapabilities, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> Mask255Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *mask255 = nvmlMask255_tDeserializer(node["ReturnValue"]);
    if (mask255 == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {mask255, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> WorkloadPowerProfileInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *workloadPowerProfileInfo = nvmlWorkloadPowerProfileInfo_tDeserializer(node["ReturnValue"]);
    if (workloadPowerProfileInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {workloadPowerProfileInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> WorkloadPowerProfileProfilesInfoParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *workloadPowerProfileProfilesInfo = nvmlWorkloadPowerProfileProfilesInfo_tDeserializer(node["ReturnValue"]);
    if (workloadPowerProfileProfilesInfo == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {workloadPowerProfileProfilesInfo, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> WorkloadPowerProfileCurrentProfilesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *workloadPowerProfileCurrentProfiles = nvmlWorkloadPowerProfileCurrentProfiles_tDeserializer(node["ReturnValue"]);
    if (workloadPowerProfileCurrentProfiles == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {workloadPowerProfileCurrentProfiles, true});
}

// The following snippet is generated from write_known_struct_parser
std::optional<NvmlFuncReturn> WorkloadPowerProfileRequestedProfilesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto *workloadPowerProfileRequestedProfiles = nvmlWorkloadPowerProfileRequestedProfiles_tDeserializer(node["ReturnValue"]);
    if (workloadPowerProfileRequestedProfiles == nullptr)
    {
        return std::nullopt;
    }
    return NvmlFuncReturn(ret, {workloadPowerProfileRequestedProfiles, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> MemoryAffinityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long *>(malloc(sizeof(unsigned long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    return NvmlFuncReturn(ret, {valPtr, size, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> CpuAffinityWithinScopeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long *>(malloc(sizeof(unsigned long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    return NvmlFuncReturn(ret, {valPtr, size, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> CpuAffinityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long *>(malloc(sizeof(unsigned long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    return NvmlFuncReturn(ret, {valPtr, size, true});
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> SupportedGraphicsClocksParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned int>();
    }
        // The following snippet is generated from write_array_funcs_parser
    std::vector<InjectionArgument> args;
    args.emplace_back(idx);
    args.emplace_back(valPtr, idx, true);
    return NvmlFuncReturn(ret, args);
}

// The following snippet is generated from write_array_funcs_parser
std::optional<NvmlFuncReturn> RetiredPagesParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    unsigned int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned long long *>(malloc(sizeof(unsigned long long) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
        // The following snippet is generated from write_array_funcs_parser
        valPtr[idx++] = it->as<unsigned long long>();
    }
        // The following snippet is generated from write_array_funcs_parser
    std::vector<InjectionArgument> args;
    args.emplace_back(idx);
    args.emplace_back(valPtr, idx, true);
    return NvmlFuncReturn(ret, args);
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> SupportedMemoryClocksParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = it->as<unsigned int>();
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> AutoBoostedClocksEnabledParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["isEnabled"].as<int>()));
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["defaultIsEnabled"].as<int>()));
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> PowerManagementLimitConstraintsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["minLimit"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["maxLimit"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> GpuOperationModeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(static_cast<nvmlGpuOperationMode_t>(node["ReturnValue"]["current"].as<int>()));
    args.emplace_back(static_cast<nvmlGpuOperationMode_t>(node["ReturnValue"]["pending"].as<int>()));
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> CudaComputeCapabilityParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["major"].as<int>());
    args.emplace_back(node["ReturnValue"]["minor"].as<int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> EccModeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["current"].as<int>()));
    args.emplace_back(static_cast<nvmlEnableState_t>(node["ReturnValue"]["pending"].as<int>()));
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> EncoderUtilizationParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["utilization"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["samplingPeriodUs"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> EncoderSessionsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlEncoderSessionInfo_t *>(malloc(sizeof(nvmlEncoderSessionInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlEncoderSessionInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlEncoderSessionInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> DecoderUtilizationParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["utilization"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["samplingPeriodUs"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> FBCSessionsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlFBCSessionInfo_t *>(malloc(sizeof(nvmlFBCSessionInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlFBCSessionInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlFBCSessionInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> ComputeRunningProcesses_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlProcessInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlProcessInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> GraphicsRunningProcesses_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlProcessInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlProcessInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> MPSComputeRunningProcesses_v3Parser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlProcessInfo_t *>(malloc(sizeof(nvmlProcessInfo_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        auto *tmp = nvmlProcessInfo_tDeserializer(*it);
        if (!tmp)
        {
            free(valPtr);
            return std::nullopt;
        }
        std::memcpy(&valPtr[idx++], tmp, sizeof(nvmlProcessInfo_t));
        free(tmp);
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> AccountingPidsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<unsigned int *>(malloc(sizeof(unsigned int) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = it->as<unsigned int>();
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> NvLinkUtilizationCounterParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["rxcounter"].as<unsigned long long>());
    args.emplace_back(node["ReturnValue"]["txcounter"].as<unsigned long long>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> SupportedVgpusParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlVgpuTypeId_t *>(malloc(sizeof(nvmlVgpuTypeId_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = static_cast<nvmlVgpuTypeId_t>(it->as<int>());
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> CreatableVgpusParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    auto size = static_cast<unsigned int>(node["ReturnValue"].size());
    int idx = 0;
    auto *valPtr = reinterpret_cast<nvmlVgpuTypeId_t *>(malloc(sizeof(nvmlVgpuTypeId_t) * size));
    for (YAML::const_iterator it = node["ReturnValue"].begin(); it != node["ReturnValue"].end(); ++it)
    {
    // The following snippet is generated from write_two_attrs_funcs_parser
        valPtr[idx++] = static_cast<nvmlVgpuTypeId_t>(it->as<int>());
    }
    args.emplace_back(size);
    args.emplace_back(valPtr, size, true);
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> ClassParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["vgpuTypeClass"].as<char>());
    args.emplace_back(node["ReturnValue"]["size"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> NameParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["vgpuTypeName"].as<char>());
    args.emplace_back(node["ReturnValue"]["size"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> DeviceIDParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["deviceID"].as<unsigned long long>());
    args.emplace_back(node["ReturnValue"]["subsystemID"].as<unsigned long long>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> ResolutionParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["xdim"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["ydim"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> GpuPciIdParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["vgpuPciId"].as<char>());
    args.emplace_back(node["ReturnValue"]["length"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_two_attrs_funcs_parser
std::optional<NvmlFuncReturn> MigModeParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    // The following snippet is generated from write_two_attrs_funcs_parser
    args.emplace_back(node["ReturnValue"]["currentMode"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["pendingMode"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

// The following snippet is generated from write_three_attrs_funcs_parser
std::optional<NvmlFuncReturn> EncoderStatsParser(const YAML::Node &node)
{
    if (!node || !node["FunctionReturn"])
    {
        return NvmlFuncReturn(NVML_ERROR_UNKNOWN);
    }
    auto ret = static_cast<nvmlReturn_t>(node["FunctionReturn"].as<int>(NVML_ERROR_UNKNOWN));
    if (!node["ReturnValue"])
    {
        return NvmlFuncReturn(ret);
    }
    std::vector<InjectionArgument> args;
    args.emplace_back(node["ReturnValue"]["sessionCount"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["averageFps"].as<unsigned int>());
    args.emplace_back(node["ReturnValue"]["averageLatency"].as<unsigned int>());
    return NvmlFuncReturn(ret, std::move(args));
}

}

// The following snippet is generated from nvml_return_deserializer_cpp_writer
NvmlReturnDeserializer::NvmlReturnDeserializer()
{
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_deviceHandlers = {
        // The following snippet is generated from try_to_write_device_handler
        {"Attributes", DeviceAttributesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"Name", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"Brand", BasicTypeParser<int, nvmlBrandType_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"Index", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"Serial", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"CpuAffinity", CpuAffinityParser},
        // The following snippet is generated from try_to_write_device_handler
        {"UUID", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"MinorNumber", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"BoardPartNumber", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"InforomImageVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"InforomConfigurationChecksum", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"ValidateInforom", NvmlReturnParser},
        // The following snippet is generated from try_to_write_device_handler
        {"DisplayMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"DisplayActive", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"PersistenceMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"PciInfo", PciInfoParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MaxPcieLinkGeneration", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"MaxPcieLinkWidth", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrPcieLinkGeneration", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrPcieLinkWidth", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PcieReplayCounter", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"GpcClkVfOffset", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedMemoryClocks", SupportedMemoryClocksParser},
        // The following snippet is generated from try_to_write_device_handler
        {"AutoBoostedClocksEnabled", AutoBoostedClocksEnabledParser},
        // The following snippet is generated from try_to_write_device_handler
        {"FanSpeed", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"NumFans", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PerformanceState", BasicTypeParser<int, nvmlPstates_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrentClocksEventReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"CurrentClocksThrottleReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedClocksEventReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedClocksThrottleReasons", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerState", BasicTypeParser<int, nvmlPstates_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"MemClkVfOffset", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementLimitConstraints", PowerManagementLimitConstraintsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerManagementDefaultLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerUsage", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"TotalEnergyConsumption", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"EnforcedPowerLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"GpuOperationMode", GpuOperationModeParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MemoryInfo", Memory_v2Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"ComputeMode", BasicTypeParser<int, nvmlComputeMode_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"CudaComputeCapability", CudaComputeCapabilityParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EccMode", EccModeParser},
        // The following snippet is generated from try_to_write_device_handler
        {"DefaultEccMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"BoardId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"MultiGpuBoard", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"UtilizationRates", UtilizationParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EncoderUtilization", EncoderUtilizationParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EncoderStats", EncoderStatsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"EncoderSessions", EncoderSessionsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"DecoderUtilization", DecoderUtilizationParser},
        // The following snippet is generated from try_to_write_device_handler
        {"FBCStats", FBCStatsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"FBCSessions", FBCSessionsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"VbiosVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_device_handler
        {"BridgeChipInfo", BridgeChipHierarchyParser},
        // The following snippet is generated from try_to_write_device_handler
        {"ComputeRunningProcesses", ComputeRunningProcesses_v3Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"GraphicsRunningProcesses", GraphicsRunningProcesses_v3Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"MPSComputeRunningProcesses", MPSComputeRunningProcesses_v3Parser},
        // The following snippet is generated from try_to_write_device_handler
        {"BAR1MemoryInfo", BAR1MemoryParser},
        // The following snippet is generated from try_to_write_device_handler
        {"IrqNum", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"NumGpuCores", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PowerSource", BasicTypeParser<int, nvmlPowerSource_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"MemoryBusWidth", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PcieLinkMaxSpeed", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"PcieSpeed", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"AdaptiveClockInfoStatus", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"BusType", BasicTypeParser<int, nvmlBusType_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"GpuFabricInfo", GpuFabricInfoParser},
        // The following snippet is generated from try_to_write_device_handler
        {"GpuFabricInfoV", GpuFabricInfoVParser},
        // The following snippet is generated from try_to_write_device_handler
        {"AccountingMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"AccountingPids", AccountingPidsParser},
        // The following snippet is generated from try_to_write_device_handler
        {"AccountingBufferSize", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"RetiredPagesPendingStatus", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"RowRemapperHistogram", RowRemapperHistogramValuesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"Architecture", BasicTypeParser<int, nvmlDeviceArchitecture_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedEventTypes", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_device_handler
        {"VirtualizationMode", BasicTypeParser<int, nvmlGpuVirtualizationMode_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"HostVgpuMode", BasicTypeParser<int, nvmlHostVgpuMode_t>},
        // The following snippet is generated from try_to_write_device_handler
        {"GridLicensableFeatures", GridLicensableFeaturesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"SupportedVgpus", SupportedVgpusParser},
        // The following snippet is generated from try_to_write_device_handler
        {"CreatableVgpus", CreatableVgpusParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MigMode", MigModeParser},
        // The following snippet is generated from try_to_write_device_handler
        {"MigDeviceHandle", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"GpuInstanceId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"ComputeInstanceId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"MaxMigDeviceCount", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_device_handler
        {"QueryDeviceSupport", GpmSupportParser},
        // The following snippet is generated from try_to_write_device_handler
        {"WorkloadPowerProfileGetProfilesInfo", WorkloadPowerProfileProfilesInfoParser},
        // The following snippet is generated from try_to_write_device_handler
        {"WorkloadPowerProfileGetCurrentProfiles", WorkloadPowerProfileCurrentProfilesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"WorkloadPowerProfileSetRequestedProfiles", WorkloadPowerProfileRequestedProfilesParser},
        // The following snippet is generated from try_to_write_device_handler
        {"WorkloadPowerProfileClearRequestedProfiles", WorkloadPowerProfileRequestedProfilesParser},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_deviceExtraKeyHandlers = {
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MemoryAffinity", {BasicKeyTypeParser<int, nvmlAffinityScope_t>, MemoryAffinityParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"CpuAffinityWithinScope", {BasicKeyTypeParser<int, nvmlAffinityScope_t>, CpuAffinityWithinScopeParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"InforomVersion", {BasicKeyTypeParser<int, nvmlInforomObject_t>, BasicTypeParser<std::string, std::string>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"PcieThroughput", {BasicKeyTypeParser<int, nvmlPcieUtilCounter_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"ClockInfo", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MaxClockInfo", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"ApplicationsClock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"DefaultApplicationsClock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MaxCustomerBoostClock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"SupportedGraphicsClocks", {BasicKeyTypeParser<unsigned int, unsigned int>, SupportedGraphicsClocksParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"FanSpeed", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"TargetFanSpeed", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"Temperature", {BasicKeyTypeParser<int, nvmlTemperatureSensors_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"TemperatureThreshold", {BasicKeyTypeParser<int, nvmlTemperatureThresholds_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"EncoderCapacity", {BasicKeyTypeParser<int, nvmlEncoderType_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"APIRestriction", {BasicKeyTypeParser<int, nvmlRestrictedAPI_t>, BasicTypeParser<int, nvmlEnableState_t>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"ViolationStatus", {BasicKeyTypeParser<int, nvmlPerfPolicyType_t>, ViolationTimeParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"AccountingStats", {BasicKeyTypeParser<unsigned int, unsigned int>, AccountingStatsParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"RetiredPages", {BasicKeyTypeParser<int, nvmlPageRetirementCause_t>, RetiredPagesParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkState", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<int, nvmlEnableState_t>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkVersion", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkRemotePciInfo", {BasicKeyTypeParser<unsigned int, unsigned int>, PciInfoParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"NvLinkRemoteDeviceType", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<int, nvmlIntNvLinkDeviceType_t>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"MaxInstances", {BasicKeyTypeParser<int, nvmlVgpuTypeId_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"GpuInstanceProfileInfo", {BasicKeyTypeParser<unsigned int, unsigned int>, GpuInstanceProfileInfoParser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"GpuInstanceProfileInfoV", {BasicKeyTypeParser<unsigned int, unsigned int>, GpuInstanceProfileInfo_v2Parser}},
        // The following snippet is generated from try_to_write_device_extra_key_handler
        {"GpuInstanceRemainingCapacity", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_deviceThreeKeysHandlers = {
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"Clock", {BasicKeyTypeParser<int, nvmlClockType_t>, BasicKeyTypeParser<int, nvmlClockId_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"TotalEccErrors", {BasicKeyTypeParser<int, nvmlMemoryErrorType_t>, BasicKeyTypeParser<int, nvmlEccCounterType_t>, BasicTypeParser<unsigned long long, unsigned long long>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"DetailedEccErrors", {BasicKeyTypeParser<int, nvmlMemoryErrorType_t>, BasicKeyTypeParser<int, nvmlEccCounterType_t>, EccErrorCountsParser}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"NvLinkCapability", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<int, nvmlNvLinkCapability_t>, BasicTypeParser<unsigned int, unsigned int>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"NvLinkErrorCounter", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<int, nvmlNvLinkErrorCounter_t>, BasicTypeParser<unsigned long long, unsigned long long>}},
        // The following snippet is generated from try_to_write_device_three_keys_handler
        {"NvLinkUtilizationCounter", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<unsigned int, unsigned int>, NvLinkUtilizationCounterParser}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_gpuInstanceHandlers = {
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_gpuInstanceExtraKeyHandlers = {
        // The following snippet is generated from try_to_write_gpu_instance_extra_key_handler
        {"ComputeInstanceRemainingCapacity", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicTypeParser<unsigned int, unsigned int>}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_gpuInstanceThreeKeysHandlers = {
        // The following snippet is generated from try_to_write_gpu_instance_three_keys_handler
        {"ComputeInstanceProfileInfo", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<unsigned int, unsigned int>, ComputeInstanceProfileInfoParser}},
        // The following snippet is generated from try_to_write_gpu_instance_three_keys_handler
        {"ComputeInstanceProfileInfoV", {BasicKeyTypeParser<unsigned int, unsigned int>, BasicKeyTypeParser<unsigned int, unsigned int>, ComputeInstanceProfileInfo_v2Parser}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_computeInstanceHandlers = {
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_vgpuTypeHandlers = {
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"Class", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"Name", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"GpuInstanceProfileId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"DeviceID", DeviceIDParser},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"FramebufferSize", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"NumDisplayHeads", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"Resolution", ResolutionParser},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"License", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"FrameRateLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_type_handler
        {"MaxInstancesPerVm", BasicTypeParser<unsigned int, unsigned int>},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_vgpuTypeExtraKeyHandlers = {
        // The following snippet is generated from try_to_write_vgpu_type_extra_key_handler
        {"Capabilities", {BasicKeyTypeParser<int, nvmlVgpuCapability_t>, BasicTypeParser<unsigned int, unsigned int>}},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_vgpuInstanceHandlers = {
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"UUID", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"VmDriverVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FbUsage", BasicTypeParser<unsigned long long, unsigned long long>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"LicenseStatus", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"Type", BasicTypeParser<int, nvmlVgpuTypeId_t>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FrameRateLimit", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EccMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EncoderCapacity", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EncoderStats", EncoderStatsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"EncoderSessions", EncoderSessionsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FBCStats", FBCStatsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"FBCSessions", FBCSessionsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"GpuInstanceId", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"GpuPciId", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"MdevUUID", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"AccountingMode", BasicTypeParser<int, nvmlEnableState_t>},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"AccountingPids", AccountingPidsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"AccountingStats", AccountingStatsParser},
        // The following snippet is generated from try_to_write_vgpu_instance_handler
        {"LicenseInfo", VgpuLicenseInfoParser},
    };
    // The following snippet is generated from nvml_return_deserializer_cpp_writer
    m_generalHandlers = {
        // The following snippet is generated from try_to_write_general_handler
        {"DriverVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_general_handler
        {"NVMLVersion", BasicTypeParser<std::string, std::string>},
        // The following snippet is generated from try_to_write_general_handler
        {"CudaDriverVersion", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_general_handler
        {"CudaDriverVersion_v2", BasicTypeParser<int, int>},
        // The following snippet is generated from try_to_write_general_handler
        {"Count", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_general_handler
        {"Count_v2", BasicTypeParser<unsigned int, unsigned int>},
        // The following snippet is generated from try_to_write_general_handler
        {"ConfComputeState", ConfComputeSystemStateParser},
        // The following snippet is generated from try_to_write_general_handler
        {"ExcludedDeviceCount", BasicTypeParser<unsigned int, unsigned int>},
    };
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::DeviceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_deviceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_deviceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::GpuInstanceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_gpuInstanceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_gpuInstanceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::ComputeInstanceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_computeInstanceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_computeInstanceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::VgpuTypeHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_vgpuTypeHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_vgpuTypeHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::VgpuInstanceHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_vgpuInstanceHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_vgpuInstanceHandlers[key](node);
}

// The following snippet is generated from write_handle_method
std::optional<NvmlFuncReturn> NvmlReturnDeserializer::GeneralHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_generalHandlers.contains(key))
    {
        return std::nullopt;
    }
    return m_generalHandlers[key](node);
}

// The following snippet is generated from write_extra_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::DeviceExtraKeyHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_deviceExtraKeyHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>> ret;
    auto &[keyParser, valueParser] = m_deviceExtraKeyHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key2Opt = keyParser(innerKey);
        if (!key2Opt)
        {
            return std::nullopt;
        }
        auto valOpt = valueParser(innerValue);
        if (!valOpt)
        {
            return std::nullopt;
        }
        ret.emplace_back(key2Opt.value(), valOpt.value());
    }
    return ret;
}

// The following snippet is generated from write_extra_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::GpuInstanceExtraKeyHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_gpuInstanceExtraKeyHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>> ret;
    auto &[keyParser, valueParser] = m_gpuInstanceExtraKeyHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key2Opt = keyParser(innerKey);
        if (!key2Opt)
        {
            return std::nullopt;
        }
        auto valOpt = valueParser(innerValue);
        if (!valOpt)
        {
            return std::nullopt;
        }
        ret.emplace_back(key2Opt.value(), valOpt.value());
    }
    return ret;
}

// The following snippet is generated from write_extra_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::VgpuTypeExtraKeyHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_vgpuTypeExtraKeyHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, NvmlFuncReturn>> ret;
    auto &[keyParser, valueParser] = m_vgpuTypeExtraKeyHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key2Opt = keyParser(innerKey);
        if (!key2Opt)
        {
            return std::nullopt;
        }
        auto valOpt = valueParser(innerValue);
        if (!valOpt)
        {
            return std::nullopt;
        }
        ret.emplace_back(key2Opt.value(), valOpt.value());
    }
    return ret;
}

// The following snippet is generated from write_three_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::DeviceThreeKeysHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_deviceThreeKeysHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>> ret;
    auto &[key1Parser, key2Parser, valueParser] = m_deviceThreeKeysHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key1Opt = key1Parser(innerKey);
        if (!key1Opt)
        {
            return std::nullopt;
        }
        for (YAML::const_iterator layerThreeIt = innerValue.begin(); layerThreeIt != innerValue.end(); ++layerThreeIt)
        {
            YAML::Node layerThreeKey = layerThreeIt->first;
            YAML::Node layerThreeValue = layerThreeIt->second;
            auto key2Opt = key2Parser(layerThreeKey);
            if (!key2Opt)
            {
                return std::nullopt;
            }
            auto valOpt = valueParser(layerThreeValue);
            if (!valOpt)
            {
                return std::nullopt;
            }
            ret.emplace_back(key1Opt.value(), key2Opt.value(), valOpt.value());
        }
    }
    return ret;
}

// The following snippet is generated from write_three_key_handle_method
std::optional<std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>>> NvmlReturnDeserializer::GpuInstanceThreeKeysHandle(const std::string &key, const YAML::Node &node)
{
    if (!m_gpuInstanceThreeKeysHandlers.contains(key))
    {
        return std::nullopt;
    }
    std::vector<std::tuple<InjectionArgument, InjectionArgument, NvmlFuncReturn>> ret;
    auto &[key1Parser, key2Parser, valueParser] = m_gpuInstanceThreeKeysHandlers[key];
    for (YAML::const_iterator it = node.begin(); it != node.end(); ++it)
    {
        YAML::Node innerKey = it->first;
        YAML::Node innerValue = it->second;
        auto key1Opt = key1Parser(innerKey);
        if (!key1Opt)
        {
            return std::nullopt;
        }
        for (YAML::const_iterator layerThreeIt = innerValue.begin(); layerThreeIt != innerValue.end(); ++layerThreeIt)
        {
            YAML::Node layerThreeKey = layerThreeIt->first;
            YAML::Node layerThreeValue = layerThreeIt->second;
            auto key2Opt = key2Parser(layerThreeKey);
            if (!key2Opt)
            {
                return std::nullopt;
            }
            auto valOpt = valueParser(layerThreeValue);
            if (!valOpt)
            {
                return std::nullopt;
            }
            ret.emplace_back(key1Opt.value(), key2Opt.value(), valOpt.value());
        }
    }
    return ret;
}

