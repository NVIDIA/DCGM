/*
 * Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * NOTE: This code is auto-generated by generate_nvml_stubs.py
 * DO NOT EDIT MANUALLY
 */


// clang-format off
#pragma once

#include <cstring>
#include <nvml.h>
#include <string>

#include "nvml_injection_structs.h"

// The following snippet is generated from write_injection_argument_header
class InjectionArgument
{
private:
    injectionArgType_t m_type;
    simpleValue_t m_value;
    std::string m_str;

    bool m_isArray = false;

    unsigned m_arrLen = 0;

    bool m_inHeap = false;

    // The following snippet is generated from write_injection_argument_deep_copy_function
    // Some type of holding member live in heap. Do deep copy so that our destructor can work well.
    void DeepCopy(const InjectionArgument &other)
    {
        m_type = other.m_type;
        m_value = other.m_value;
        m_str = other.m_str;
        m_isArray = other.m_isArray;
        m_arrLen = other.m_arrLen;
        m_inHeap = other.m_inHeap;
        if (!m_inHeap)
        {
            return;
        }
        switch (m_type)
        {
            case INJECTION_CHAR_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.str = reinterpret_cast<char *>(malloc(allocateNum * sizeof(*other.m_value.str)));
                std::memcpy(m_value.str, other.m_value.str, allocateNum * sizeof(*other.m_value.str));
                break;
            }
            case INJECTION_INT_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.iPtr = reinterpret_cast<int *>(malloc(allocateNum * sizeof(*other.m_value.iPtr)));
                std::memcpy(m_value.iPtr, other.m_value.iPtr, allocateNum * sizeof(*other.m_value.iPtr));
                break;
            }
            case INJECTION_ACCOUNTINGSTATS_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.accountingStatsPtr = reinterpret_cast<nvmlAccountingStats_t *>(malloc(allocateNum * sizeof(*other.m_value.accountingStatsPtr)));
                std::memcpy(m_value.accountingStatsPtr, other.m_value.accountingStatsPtr, allocateNum * sizeof(*other.m_value.accountingStatsPtr));
                break;
            }
            case INJECTION_BAR1MEMORY_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.bar1MemoryPtr = reinterpret_cast<nvmlBAR1Memory_t *>(malloc(allocateNum * sizeof(*other.m_value.bar1MemoryPtr)));
                std::memcpy(m_value.bar1MemoryPtr, other.m_value.bar1MemoryPtr, allocateNum * sizeof(*other.m_value.bar1MemoryPtr));
                break;
            }
            case INJECTION_BRANDTYPE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.brandTypePtr = reinterpret_cast<nvmlBrandType_t *>(malloc(allocateNum * sizeof(*other.m_value.brandTypePtr)));
                std::memcpy(m_value.brandTypePtr, other.m_value.brandTypePtr, allocateNum * sizeof(*other.m_value.brandTypePtr));
                break;
            }
            case INJECTION_BRIDGECHIPHIERARCHY_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.bridgeChipHierarchyPtr = reinterpret_cast<nvmlBridgeChipHierarchy_t *>(malloc(allocateNum * sizeof(*other.m_value.bridgeChipHierarchyPtr)));
                std::memcpy(m_value.bridgeChipHierarchyPtr, other.m_value.bridgeChipHierarchyPtr, allocateNum * sizeof(*other.m_value.bridgeChipHierarchyPtr));
                break;
            }
            case INJECTION_COMPUTEINSTANCEINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.computeInstanceInfoPtr = reinterpret_cast<nvmlComputeInstanceInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.computeInstanceInfoPtr)));
                std::memcpy(m_value.computeInstanceInfoPtr, other.m_value.computeInstanceInfoPtr, allocateNum * sizeof(*other.m_value.computeInstanceInfoPtr));
                break;
            }
            case INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.computeInstanceProfileInfoPtr = reinterpret_cast<nvmlComputeInstanceProfileInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.computeInstanceProfileInfoPtr)));
                std::memcpy(m_value.computeInstanceProfileInfoPtr, other.m_value.computeInstanceProfileInfoPtr, allocateNum * sizeof(*other.m_value.computeInstanceProfileInfoPtr));
                break;
            }
            case INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.computeInstanceProfileInfo_v2Ptr = reinterpret_cast<nvmlComputeInstanceProfileInfo_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.computeInstanceProfileInfo_v2Ptr)));
                std::memcpy(m_value.computeInstanceProfileInfo_v2Ptr, other.m_value.computeInstanceProfileInfo_v2Ptr, allocateNum * sizeof(*other.m_value.computeInstanceProfileInfo_v2Ptr));
                break;
            }
            case INJECTION_COMPUTEINSTANCE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.computeInstancePtr = reinterpret_cast<nvmlComputeInstance_t *>(malloc(allocateNum * sizeof(*other.m_value.computeInstancePtr)));
                std::memcpy(m_value.computeInstancePtr, other.m_value.computeInstancePtr, allocateNum * sizeof(*other.m_value.computeInstancePtr));
                break;
            }
            case INJECTION_COMPUTEMODE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.computeModePtr = reinterpret_cast<nvmlComputeMode_t *>(malloc(allocateNum * sizeof(*other.m_value.computeModePtr)));
                std::memcpy(m_value.computeModePtr, other.m_value.computeModePtr, allocateNum * sizeof(*other.m_value.computeModePtr));
                break;
            }
            case INJECTION_CONFCOMPUTESYSTEMSTATE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.confComputeSystemStatePtr = reinterpret_cast<nvmlConfComputeSystemState_t *>(malloc(allocateNum * sizeof(*other.m_value.confComputeSystemStatePtr)));
                std::memcpy(m_value.confComputeSystemStatePtr, other.m_value.confComputeSystemStatePtr, allocateNum * sizeof(*other.m_value.confComputeSystemStatePtr));
                break;
            }
            case INJECTION_DEVICEATTRIBUTES_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.deviceAttributesPtr = reinterpret_cast<nvmlDeviceAttributes_t *>(malloc(allocateNum * sizeof(*other.m_value.deviceAttributesPtr)));
                std::memcpy(m_value.deviceAttributesPtr, other.m_value.deviceAttributesPtr, allocateNum * sizeof(*other.m_value.deviceAttributesPtr));
                break;
            }
            case INJECTION_DEVICE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.devicePtr = reinterpret_cast<nvmlDevice_t *>(malloc(allocateNum * sizeof(*other.m_value.devicePtr)));
                std::memcpy(m_value.devicePtr, other.m_value.devicePtr, allocateNum * sizeof(*other.m_value.devicePtr));
                break;
            }
            case INJECTION_DRIVERMODEL_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.driverModelPtr = reinterpret_cast<nvmlDriverModel_t *>(malloc(allocateNum * sizeof(*other.m_value.driverModelPtr)));
                std::memcpy(m_value.driverModelPtr, other.m_value.driverModelPtr, allocateNum * sizeof(*other.m_value.driverModelPtr));
                break;
            }
            case INJECTION_ECCERRORCOUNTS_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.eccErrorCountsPtr = reinterpret_cast<nvmlEccErrorCounts_t *>(malloc(allocateNum * sizeof(*other.m_value.eccErrorCountsPtr)));
                std::memcpy(m_value.eccErrorCountsPtr, other.m_value.eccErrorCountsPtr, allocateNum * sizeof(*other.m_value.eccErrorCountsPtr));
                break;
            }
            case INJECTION_ENABLESTATE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.enableStatePtr = reinterpret_cast<nvmlEnableState_t *>(malloc(allocateNum * sizeof(*other.m_value.enableStatePtr)));
                std::memcpy(m_value.enableStatePtr, other.m_value.enableStatePtr, allocateNum * sizeof(*other.m_value.enableStatePtr));
                break;
            }
            case INJECTION_ENCODERSESSIONINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.encoderSessionInfoPtr = reinterpret_cast<nvmlEncoderSessionInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.encoderSessionInfoPtr)));
                std::memcpy(m_value.encoderSessionInfoPtr, other.m_value.encoderSessionInfoPtr, allocateNum * sizeof(*other.m_value.encoderSessionInfoPtr));
                break;
            }
            case INJECTION_EVENTDATA_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.eventDataPtr = reinterpret_cast<nvmlEventData_t *>(malloc(allocateNum * sizeof(*other.m_value.eventDataPtr)));
                std::memcpy(m_value.eventDataPtr, other.m_value.eventDataPtr, allocateNum * sizeof(*other.m_value.eventDataPtr));
                break;
            }
            case INJECTION_EVENTSET_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.eventSetPtr = reinterpret_cast<nvmlEventSet_t *>(malloc(allocateNum * sizeof(*other.m_value.eventSetPtr)));
                std::memcpy(m_value.eventSetPtr, other.m_value.eventSetPtr, allocateNum * sizeof(*other.m_value.eventSetPtr));
                break;
            }
            case INJECTION_EXCLUDEDDEVICEINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.excludedDeviceInfoPtr = reinterpret_cast<nvmlExcludedDeviceInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.excludedDeviceInfoPtr)));
                std::memcpy(m_value.excludedDeviceInfoPtr, other.m_value.excludedDeviceInfoPtr, allocateNum * sizeof(*other.m_value.excludedDeviceInfoPtr));
                break;
            }
            case INJECTION_FBCSESSIONINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.fBCSessionInfoPtr = reinterpret_cast<nvmlFBCSessionInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.fBCSessionInfoPtr)));
                std::memcpy(m_value.fBCSessionInfoPtr, other.m_value.fBCSessionInfoPtr, allocateNum * sizeof(*other.m_value.fBCSessionInfoPtr));
                break;
            }
            case INJECTION_FBCSTATS_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.fBCStatsPtr = reinterpret_cast<nvmlFBCStats_t *>(malloc(allocateNum * sizeof(*other.m_value.fBCStatsPtr)));
                std::memcpy(m_value.fBCStatsPtr, other.m_value.fBCStatsPtr, allocateNum * sizeof(*other.m_value.fBCStatsPtr));
                break;
            }
            case INJECTION_FIELDVALUE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.fieldValuePtr = reinterpret_cast<nvmlFieldValue_t *>(malloc(allocateNum * sizeof(*other.m_value.fieldValuePtr)));
                std::memcpy(m_value.fieldValuePtr, other.m_value.fieldValuePtr, allocateNum * sizeof(*other.m_value.fieldValuePtr));
                break;
            }
            case INJECTION_GPMMETRICSGET_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpmMetricsGetPtr = reinterpret_cast<nvmlGpmMetricsGet_t *>(malloc(allocateNum * sizeof(*other.m_value.gpmMetricsGetPtr)));
                std::memcpy(m_value.gpmMetricsGetPtr, other.m_value.gpmMetricsGetPtr, allocateNum * sizeof(*other.m_value.gpmMetricsGetPtr));
                break;
            }
            case INJECTION_GPMSAMPLE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpmSamplePtr = reinterpret_cast<nvmlGpmSample_t *>(malloc(allocateNum * sizeof(*other.m_value.gpmSamplePtr)));
                std::memcpy(m_value.gpmSamplePtr, other.m_value.gpmSamplePtr, allocateNum * sizeof(*other.m_value.gpmSamplePtr));
                break;
            }
            case INJECTION_GPMSUPPORT_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpmSupportPtr = reinterpret_cast<nvmlGpmSupport_t *>(malloc(allocateNum * sizeof(*other.m_value.gpmSupportPtr)));
                std::memcpy(m_value.gpmSupportPtr, other.m_value.gpmSupportPtr, allocateNum * sizeof(*other.m_value.gpmSupportPtr));
                break;
            }
            case INJECTION_GPUDYNAMICPSTATESINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuDynamicPstatesInfoPtr = reinterpret_cast<nvmlGpuDynamicPstatesInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuDynamicPstatesInfoPtr)));
                std::memcpy(m_value.gpuDynamicPstatesInfoPtr, other.m_value.gpuDynamicPstatesInfoPtr, allocateNum * sizeof(*other.m_value.gpuDynamicPstatesInfoPtr));
                break;
            }
            case INJECTION_GPUINSTANCEINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuInstanceInfoPtr = reinterpret_cast<nvmlGpuInstanceInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuInstanceInfoPtr)));
                std::memcpy(m_value.gpuInstanceInfoPtr, other.m_value.gpuInstanceInfoPtr, allocateNum * sizeof(*other.m_value.gpuInstanceInfoPtr));
                break;
            }
            case INJECTION_GPUINSTANCEPLACEMENT_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuInstancePlacementPtr = reinterpret_cast<nvmlGpuInstancePlacement_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuInstancePlacementPtr)));
                std::memcpy(m_value.gpuInstancePlacementPtr, other.m_value.gpuInstancePlacementPtr, allocateNum * sizeof(*other.m_value.gpuInstancePlacementPtr));
                break;
            }
            case INJECTION_GPUINSTANCEPROFILEINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuInstanceProfileInfoPtr = reinterpret_cast<nvmlGpuInstanceProfileInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuInstanceProfileInfoPtr)));
                std::memcpy(m_value.gpuInstanceProfileInfoPtr, other.m_value.gpuInstanceProfileInfoPtr, allocateNum * sizeof(*other.m_value.gpuInstanceProfileInfoPtr));
                break;
            }
            case INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuInstanceProfileInfo_v2Ptr = reinterpret_cast<nvmlGpuInstanceProfileInfo_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuInstanceProfileInfo_v2Ptr)));
                std::memcpy(m_value.gpuInstanceProfileInfo_v2Ptr, other.m_value.gpuInstanceProfileInfo_v2Ptr, allocateNum * sizeof(*other.m_value.gpuInstanceProfileInfo_v2Ptr));
                break;
            }
            case INJECTION_GPUINSTANCE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuInstancePtr = reinterpret_cast<nvmlGpuInstance_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuInstancePtr)));
                std::memcpy(m_value.gpuInstancePtr, other.m_value.gpuInstancePtr, allocateNum * sizeof(*other.m_value.gpuInstancePtr));
                break;
            }
            case INJECTION_GPUOPERATIONMODE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuOperationModePtr = reinterpret_cast<nvmlGpuOperationMode_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuOperationModePtr)));
                std::memcpy(m_value.gpuOperationModePtr, other.m_value.gpuOperationModePtr, allocateNum * sizeof(*other.m_value.gpuOperationModePtr));
                break;
            }
            case INJECTION_GPUP2PSTATUS_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuP2PStatusPtr = reinterpret_cast<nvmlGpuP2PStatus_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuP2PStatusPtr)));
                std::memcpy(m_value.gpuP2PStatusPtr, other.m_value.gpuP2PStatusPtr, allocateNum * sizeof(*other.m_value.gpuP2PStatusPtr));
                break;
            }
            case INJECTION_GPUTHERMALSETTINGS_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuThermalSettingsPtr = reinterpret_cast<nvmlGpuThermalSettings_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuThermalSettingsPtr)));
                std::memcpy(m_value.gpuThermalSettingsPtr, other.m_value.gpuThermalSettingsPtr, allocateNum * sizeof(*other.m_value.gpuThermalSettingsPtr));
                break;
            }
            case INJECTION_GPUTOPOLOGYLEVEL_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuTopologyLevelPtr = reinterpret_cast<nvmlGpuTopologyLevel_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuTopologyLevelPtr)));
                std::memcpy(m_value.gpuTopologyLevelPtr, other.m_value.gpuTopologyLevelPtr, allocateNum * sizeof(*other.m_value.gpuTopologyLevelPtr));
                break;
            }
            case INJECTION_GPUVIRTUALIZATIONMODE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gpuVirtualizationModePtr = reinterpret_cast<nvmlGpuVirtualizationMode_t *>(malloc(allocateNum * sizeof(*other.m_value.gpuVirtualizationModePtr)));
                std::memcpy(m_value.gpuVirtualizationModePtr, other.m_value.gpuVirtualizationModePtr, allocateNum * sizeof(*other.m_value.gpuVirtualizationModePtr));
                break;
            }
            case INJECTION_GRIDLICENSABLEFEATURES_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.gridLicensableFeaturesPtr = reinterpret_cast<nvmlGridLicensableFeatures_t *>(malloc(allocateNum * sizeof(*other.m_value.gridLicensableFeaturesPtr)));
                std::memcpy(m_value.gridLicensableFeaturesPtr, other.m_value.gridLicensableFeaturesPtr, allocateNum * sizeof(*other.m_value.gridLicensableFeaturesPtr));
                break;
            }
            case INJECTION_HOSTVGPUMODE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.hostVgpuModePtr = reinterpret_cast<nvmlHostVgpuMode_t *>(malloc(allocateNum * sizeof(*other.m_value.hostVgpuModePtr)));
                std::memcpy(m_value.hostVgpuModePtr, other.m_value.hostVgpuModePtr, allocateNum * sizeof(*other.m_value.hostVgpuModePtr));
                break;
            }
            case INJECTION_HWBCENTRY_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.hwbcEntryPtr = reinterpret_cast<nvmlHwbcEntry_t *>(malloc(allocateNum * sizeof(*other.m_value.hwbcEntryPtr)));
                std::memcpy(m_value.hwbcEntryPtr, other.m_value.hwbcEntryPtr, allocateNum * sizeof(*other.m_value.hwbcEntryPtr));
                break;
            }
            case INJECTION_INTNVLINKDEVICETYPE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.intNvLinkDeviceTypePtr = reinterpret_cast<nvmlIntNvLinkDeviceType_t *>(malloc(allocateNum * sizeof(*other.m_value.intNvLinkDeviceTypePtr)));
                std::memcpy(m_value.intNvLinkDeviceTypePtr, other.m_value.intNvLinkDeviceTypePtr, allocateNum * sizeof(*other.m_value.intNvLinkDeviceTypePtr));
                break;
            }
            case INJECTION_LEDSTATE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ledStatePtr = reinterpret_cast<nvmlLedState_t *>(malloc(allocateNum * sizeof(*other.m_value.ledStatePtr)));
                std::memcpy(m_value.ledStatePtr, other.m_value.ledStatePtr, allocateNum * sizeof(*other.m_value.ledStatePtr));
                break;
            }
            case INJECTION_MEMORY_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.memoryPtr = reinterpret_cast<nvmlMemory_t *>(malloc(allocateNum * sizeof(*other.m_value.memoryPtr)));
                std::memcpy(m_value.memoryPtr, other.m_value.memoryPtr, allocateNum * sizeof(*other.m_value.memoryPtr));
                break;
            }
            case INJECTION_MEMORY_V2_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.memory_v2Ptr = reinterpret_cast<nvmlMemory_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.memory_v2Ptr)));
                std::memcpy(m_value.memory_v2Ptr, other.m_value.memory_v2Ptr, allocateNum * sizeof(*other.m_value.memory_v2Ptr));
                break;
            }
            case INJECTION_NVLINKUTILIZATIONCONTROL_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.nvLinkUtilizationControlPtr = reinterpret_cast<nvmlNvLinkUtilizationControl_t *>(malloc(allocateNum * sizeof(*other.m_value.nvLinkUtilizationControlPtr)));
                std::memcpy(m_value.nvLinkUtilizationControlPtr, other.m_value.nvLinkUtilizationControlPtr, allocateNum * sizeof(*other.m_value.nvLinkUtilizationControlPtr));
                break;
            }
            case INJECTION_PSUINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.pSUInfoPtr = reinterpret_cast<nvmlPSUInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.pSUInfoPtr)));
                std::memcpy(m_value.pSUInfoPtr, other.m_value.pSUInfoPtr, allocateNum * sizeof(*other.m_value.pSUInfoPtr));
                break;
            }
            case INJECTION_PCIINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.pciInfoPtr = reinterpret_cast<nvmlPciInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.pciInfoPtr)));
                std::memcpy(m_value.pciInfoPtr, other.m_value.pciInfoPtr, allocateNum * sizeof(*other.m_value.pciInfoPtr));
                break;
            }
            case INJECTION_PROCESSINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.processInfoPtr = reinterpret_cast<nvmlProcessInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.processInfoPtr)));
                std::memcpy(m_value.processInfoPtr, other.m_value.processInfoPtr, allocateNum * sizeof(*other.m_value.processInfoPtr));
                break;
            }
            case INJECTION_PROCESSINFO_V1_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.processInfo_v1Ptr = reinterpret_cast<nvmlProcessInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.processInfo_v1Ptr)));
                std::memcpy(m_value.processInfo_v1Ptr, other.m_value.processInfo_v1Ptr, allocateNum * sizeof(*other.m_value.processInfo_v1Ptr));
                break;
            }
            case INJECTION_PROCESSINFO_V2_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.processInfo_v2Ptr = reinterpret_cast<nvmlProcessInfo_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.processInfo_v2Ptr)));
                std::memcpy(m_value.processInfo_v2Ptr, other.m_value.processInfo_v2Ptr, allocateNum * sizeof(*other.m_value.processInfo_v2Ptr));
                break;
            }
            case INJECTION_PROCESSUTILIZATIONSAMPLE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.processUtilizationSamplePtr = reinterpret_cast<nvmlProcessUtilizationSample_t *>(malloc(allocateNum * sizeof(*other.m_value.processUtilizationSamplePtr)));
                std::memcpy(m_value.processUtilizationSamplePtr, other.m_value.processUtilizationSamplePtr, allocateNum * sizeof(*other.m_value.processUtilizationSamplePtr));
                break;
            }
            case INJECTION_PSTATES_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.pstatesPtr = reinterpret_cast<nvmlPstates_t *>(malloc(allocateNum * sizeof(*other.m_value.pstatesPtr)));
                std::memcpy(m_value.pstatesPtr, other.m_value.pstatesPtr, allocateNum * sizeof(*other.m_value.pstatesPtr));
                break;
            }
            case INJECTION_RETURN_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.nvmlReturnPtr = reinterpret_cast<nvmlReturn_t *>(malloc(allocateNum * sizeof(*other.m_value.nvmlReturnPtr)));
                std::memcpy(m_value.nvmlReturnPtr, other.m_value.nvmlReturnPtr, allocateNum * sizeof(*other.m_value.nvmlReturnPtr));
                break;
            }
            case INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.rowRemapperHistogramValuesPtr = reinterpret_cast<nvmlRowRemapperHistogramValues_t *>(malloc(allocateNum * sizeof(*other.m_value.rowRemapperHistogramValuesPtr)));
                std::memcpy(m_value.rowRemapperHistogramValuesPtr, other.m_value.rowRemapperHistogramValuesPtr, allocateNum * sizeof(*other.m_value.rowRemapperHistogramValuesPtr));
                break;
            }
            case INJECTION_SAMPLE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.samplePtr = reinterpret_cast<nvmlSample_t *>(malloc(allocateNum * sizeof(*other.m_value.samplePtr)));
                std::memcpy(m_value.samplePtr, other.m_value.samplePtr, allocateNum * sizeof(*other.m_value.samplePtr));
                break;
            }
            case INJECTION_UNITFANSPEEDS_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.unitFanSpeedsPtr = reinterpret_cast<nvmlUnitFanSpeeds_t *>(malloc(allocateNum * sizeof(*other.m_value.unitFanSpeedsPtr)));
                std::memcpy(m_value.unitFanSpeedsPtr, other.m_value.unitFanSpeedsPtr, allocateNum * sizeof(*other.m_value.unitFanSpeedsPtr));
                break;
            }
            case INJECTION_UNITINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.unitInfoPtr = reinterpret_cast<nvmlUnitInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.unitInfoPtr)));
                std::memcpy(m_value.unitInfoPtr, other.m_value.unitInfoPtr, allocateNum * sizeof(*other.m_value.unitInfoPtr));
                break;
            }
            case INJECTION_UNIT_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.unitPtr = reinterpret_cast<nvmlUnit_t *>(malloc(allocateNum * sizeof(*other.m_value.unitPtr)));
                std::memcpy(m_value.unitPtr, other.m_value.unitPtr, allocateNum * sizeof(*other.m_value.unitPtr));
                break;
            }
            case INJECTION_UTILIZATION_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.utilizationPtr = reinterpret_cast<nvmlUtilization_t *>(malloc(allocateNum * sizeof(*other.m_value.utilizationPtr)));
                std::memcpy(m_value.utilizationPtr, other.m_value.utilizationPtr, allocateNum * sizeof(*other.m_value.utilizationPtr));
                break;
            }
            case INJECTION_VALUETYPE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.valueTypePtr = reinterpret_cast<nvmlValueType_t *>(malloc(allocateNum * sizeof(*other.m_value.valueTypePtr)));
                std::memcpy(m_value.valueTypePtr, other.m_value.valueTypePtr, allocateNum * sizeof(*other.m_value.valueTypePtr));
                break;
            }
            case INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuInstanceUtilizationSamplePtr = reinterpret_cast<nvmlVgpuInstanceUtilizationSample_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuInstanceUtilizationSamplePtr)));
                std::memcpy(m_value.vgpuInstanceUtilizationSamplePtr, other.m_value.vgpuInstanceUtilizationSamplePtr, allocateNum * sizeof(*other.m_value.vgpuInstanceUtilizationSamplePtr));
                break;
            }
            case INJECTION_VGPULICENSEINFO_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuLicenseInfoPtr = reinterpret_cast<nvmlVgpuLicenseInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuLicenseInfoPtr)));
                std::memcpy(m_value.vgpuLicenseInfoPtr, other.m_value.vgpuLicenseInfoPtr, allocateNum * sizeof(*other.m_value.vgpuLicenseInfoPtr));
                break;
            }
            case INJECTION_VGPUMETADATA_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuMetadataPtr = reinterpret_cast<nvmlVgpuMetadata_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuMetadataPtr)));
                std::memcpy(m_value.vgpuMetadataPtr, other.m_value.vgpuMetadataPtr, allocateNum * sizeof(*other.m_value.vgpuMetadataPtr));
                break;
            }
            case INJECTION_VGPUPGPUCOMPATIBILITY_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuPgpuCompatibilityPtr = reinterpret_cast<nvmlVgpuPgpuCompatibility_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuPgpuCompatibilityPtr)));
                std::memcpy(m_value.vgpuPgpuCompatibilityPtr, other.m_value.vgpuPgpuCompatibilityPtr, allocateNum * sizeof(*other.m_value.vgpuPgpuCompatibilityPtr));
                break;
            }
            case INJECTION_VGPUPGPUMETADATA_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuPgpuMetadataPtr = reinterpret_cast<nvmlVgpuPgpuMetadata_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuPgpuMetadataPtr)));
                std::memcpy(m_value.vgpuPgpuMetadataPtr, other.m_value.vgpuPgpuMetadataPtr, allocateNum * sizeof(*other.m_value.vgpuPgpuMetadataPtr));
                break;
            }
            case INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuProcessUtilizationSamplePtr = reinterpret_cast<nvmlVgpuProcessUtilizationSample_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuProcessUtilizationSamplePtr)));
                std::memcpy(m_value.vgpuProcessUtilizationSamplePtr, other.m_value.vgpuProcessUtilizationSamplePtr, allocateNum * sizeof(*other.m_value.vgpuProcessUtilizationSamplePtr));
                break;
            }
            case INJECTION_VGPUVERSION_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuVersionPtr = reinterpret_cast<nvmlVgpuVersion_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuVersionPtr)));
                std::memcpy(m_value.vgpuVersionPtr, other.m_value.vgpuVersionPtr, allocateNum * sizeof(*other.m_value.vgpuVersionPtr));
                break;
            }
            case INJECTION_VGPUVMIDTYPE_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.vgpuVmIdTypePtr = reinterpret_cast<nvmlVgpuVmIdType_t *>(malloc(allocateNum * sizeof(*other.m_value.vgpuVmIdTypePtr)));
                std::memcpy(m_value.vgpuVmIdTypePtr, other.m_value.vgpuVmIdTypePtr, allocateNum * sizeof(*other.m_value.vgpuVmIdTypePtr));
                break;
            }
            case INJECTION_VIOLATIONTIME_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.violationTimePtr = reinterpret_cast<nvmlViolationTime_t *>(malloc(allocateNum * sizeof(*other.m_value.violationTimePtr)));
                std::memcpy(m_value.violationTimePtr, other.m_value.violationTimePtr, allocateNum * sizeof(*other.m_value.violationTimePtr));
                break;
            }
            case INJECTION_UINT_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.uiPtr = reinterpret_cast<unsigned int *>(malloc(allocateNum * sizeof(*other.m_value.uiPtr)));
                std::memcpy(m_value.uiPtr, other.m_value.uiPtr, allocateNum * sizeof(*other.m_value.uiPtr));
                break;
            }
            case INJECTION_ULONG_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ulPtr = reinterpret_cast<unsigned long *>(malloc(allocateNum * sizeof(*other.m_value.ulPtr)));
                std::memcpy(m_value.ulPtr, other.m_value.ulPtr, allocateNum * sizeof(*other.m_value.ulPtr));
                break;
            }
            case INJECTION_ULONG_LONG_PTR:
            {
                unsigned allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ullPtr = reinterpret_cast<unsigned long long *>(malloc(allocateNum * sizeof(*other.m_value.ullPtr)));
                std::memcpy(m_value.ullPtr, other.m_value.ullPtr, allocateNum * sizeof(*other.m_value.ullPtr));
                break;
            }
            default:
                break; // NOT Reached
        }
    }

public:
    InjectionArgument()
        : m_type(InjectionArgCount)
    {
        Clear();
    }

    InjectionArgument(const injectNvmlVal_t &value)
        : m_type(value.type)
        , m_value(value.value)
    {}

    /**
     * SetValueFrom - Sets this injection argument based other's value
     * @param other - the InjectionArgument whose value we flexibly copy if possible.
     *
     * @return 0 if we could set from other's value, 1 if incompatible
     **/
    nvmlReturn_t SetValueFrom(const InjectionArgument &other);

    injectionArgType_t GetType() const
    {
        return m_type;
    }

    simpleValue_t GetSimpleValue() const
    {
        return m_value;
    }

    void Clear()
    {
        memset(&m_value, 0, sizeof(m_value));
    }

    int Compare(const InjectionArgument &other) const;

    bool operator<(const InjectionArgument &other) const
    {
        return this->Compare(other) == -1;
    }

    bool operator==(const InjectionArgument &other) const
    {
        return this->Compare(other) == 0;
    }

    bool IsEmpty() const
    {
        return m_type == InjectionArgCount;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(char c)
        : m_type(INJECTION_CHAR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.c = c;
    }
    const char &AsChar() const
    {
        return m_value.c;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(char *str, bool inHeap = false)
        : m_type(INJECTION_CHAR_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.str = str;
    }
    char *AsStr() const
    {
        return m_value.str;
    }

    InjectionArgument(char *str, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CHAR_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.str = str;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(const char *const_str, bool inHeap = false)
        : m_type(INJECTION_CONST_CHAR_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.const_str = const_str;
    }
    const char *AsConstStr() const
    {
        return m_value.const_str;
    }

    InjectionArgument(const char *const_str, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONST_CHAR_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.const_str = const_str;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(const nvmlGpuInstancePlacement_t *cnPtr, bool inHeap = false)
        : m_type(INJECTION_CONST_NVMLGPUINSTANCEPLACEMENT_T_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.cnPtr = cnPtr;
    }
    const nvmlGpuInstancePlacement_t *AsConstNvmlGpuInstancePlacement_tPtr() const
    {
        return m_value.cnPtr;
    }

    InjectionArgument(const nvmlGpuInstancePlacement_t *cnPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONST_NVMLGPUINSTANCEPLACEMENT_T_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.cnPtr = cnPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(int i)
        : m_type(INJECTION_INT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.i = i;
    }
    const int &AsInt() const
    {
        return m_value.i;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(int *iPtr, bool inHeap = false)
        : m_type(INJECTION_INT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.iPtr = iPtr;
    }
    int *AsIntPtr() const
    {
        return m_value.iPtr;
    }

    InjectionArgument(int *iPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_INT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.iPtr = iPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlAccountingStats_t accountingStats)
        : m_type(INJECTION_ACCOUNTINGSTATS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.accountingStats = accountingStats;
    }
    const nvmlAccountingStats_t &AsAccountingStats() const
    {
        return m_value.accountingStats;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlAccountingStats_t *accountingStatsPtr, bool inHeap = false)
        : m_type(INJECTION_ACCOUNTINGSTATS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.accountingStatsPtr = accountingStatsPtr;
    }
    nvmlAccountingStats_t *AsAccountingStatsPtr() const
    {
        return m_value.accountingStatsPtr;
    }

    InjectionArgument(nvmlAccountingStats_t *accountingStatsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ACCOUNTINGSTATS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.accountingStatsPtr = accountingStatsPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBAR1Memory_t bar1Memory)
        : m_type(INJECTION_BAR1MEMORY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bar1Memory = bar1Memory;
    }
    const nvmlBAR1Memory_t &AsBAR1Memory() const
    {
        return m_value.bar1Memory;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBAR1Memory_t *bar1MemoryPtr, bool inHeap = false)
        : m_type(INJECTION_BAR1MEMORY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bar1MemoryPtr = bar1MemoryPtr;
    }
    nvmlBAR1Memory_t *AsBAR1MemoryPtr() const
    {
        return m_value.bar1MemoryPtr;
    }

    InjectionArgument(nvmlBAR1Memory_t *bar1MemoryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BAR1MEMORY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bar1MemoryPtr = bar1MemoryPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBrandType_t brandType)
        : m_type(INJECTION_BRANDTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.brandType = brandType;
    }
    const nvmlBrandType_t &AsBrandType() const
    {
        return m_value.brandType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBrandType_t *brandTypePtr, bool inHeap = false)
        : m_type(INJECTION_BRANDTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.brandTypePtr = brandTypePtr;
    }
    nvmlBrandType_t *AsBrandTypePtr() const
    {
        return m_value.brandTypePtr;
    }

    InjectionArgument(nvmlBrandType_t *brandTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BRANDTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.brandTypePtr = brandTypePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBridgeChipHierarchy_t bridgeChipHierarchy)
        : m_type(INJECTION_BRIDGECHIPHIERARCHY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bridgeChipHierarchy = bridgeChipHierarchy;
    }
    const nvmlBridgeChipHierarchy_t &AsBridgeChipHierarchy() const
    {
        return m_value.bridgeChipHierarchy;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBridgeChipHierarchy_t *bridgeChipHierarchyPtr, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPHIERARCHY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bridgeChipHierarchyPtr = bridgeChipHierarchyPtr;
    }
    nvmlBridgeChipHierarchy_t *AsBridgeChipHierarchyPtr() const
    {
        return m_value.bridgeChipHierarchyPtr;
    }

    InjectionArgument(nvmlBridgeChipHierarchy_t *bridgeChipHierarchyPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPHIERARCHY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bridgeChipHierarchyPtr = bridgeChipHierarchyPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClockId_t clockId)
        : m_type(INJECTION_CLOCKID)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.clockId = clockId;
    }
    const nvmlClockId_t &AsClockId() const
    {
        return m_value.clockId;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClockType_t clockType)
        : m_type(INJECTION_CLOCKTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.clockType = clockType;
    }
    const nvmlClockType_t &AsClockType() const
    {
        return m_value.clockType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceInfo_t computeInstanceInfo)
        : m_type(INJECTION_COMPUTEINSTANCEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceInfo = computeInstanceInfo;
    }
    const nvmlComputeInstanceInfo_t &AsComputeInstanceInfo() const
    {
        return m_value.computeInstanceInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceInfo_t *computeInstanceInfoPtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceInfoPtr = computeInstanceInfoPtr;
    }
    nvmlComputeInstanceInfo_t *AsComputeInstanceInfoPtr() const
    {
        return m_value.computeInstanceInfoPtr;
    }

    InjectionArgument(nvmlComputeInstanceInfo_t *computeInstanceInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceInfoPtr = computeInstanceInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceProfileInfo_t computeInstanceProfileInfo)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfo = computeInstanceProfileInfo;
    }
    const nvmlComputeInstanceProfileInfo_t &AsComputeInstanceProfileInfo() const
    {
        return m_value.computeInstanceProfileInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceProfileInfo_t *computeInstanceProfileInfoPtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfoPtr = computeInstanceProfileInfoPtr;
    }
    nvmlComputeInstanceProfileInfo_t *AsComputeInstanceProfileInfoPtr() const
    {
        return m_value.computeInstanceProfileInfoPtr;
    }

    InjectionArgument(nvmlComputeInstanceProfileInfo_t *computeInstanceProfileInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfoPtr = computeInstanceProfileInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceProfileInfo_v2_t computeInstanceProfileInfo_v2)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfo_v2 = computeInstanceProfileInfo_v2;
    }
    const nvmlComputeInstanceProfileInfo_v2_t &AsComputeInstanceProfileInfo_v2() const
    {
        return m_value.computeInstanceProfileInfo_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceProfileInfo_v2_t *computeInstanceProfileInfo_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfo_v2Ptr = computeInstanceProfileInfo_v2Ptr;
    }
    nvmlComputeInstanceProfileInfo_v2_t *AsComputeInstanceProfileInfo_v2Ptr() const
    {
        return m_value.computeInstanceProfileInfo_v2Ptr;
    }

    InjectionArgument(nvmlComputeInstanceProfileInfo_v2_t *computeInstanceProfileInfo_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfo_v2Ptr = computeInstanceProfileInfo_v2Ptr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstance_t computeInstance)
        : m_type(INJECTION_COMPUTEINSTANCE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstance = computeInstance;
    }
    const nvmlComputeInstance_t &AsComputeInstance() const
    {
        return m_value.computeInstance;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstance_t *computeInstancePtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstancePtr = computeInstancePtr;
    }
    nvmlComputeInstance_t *AsComputeInstancePtr() const
    {
        return m_value.computeInstancePtr;
    }

    InjectionArgument(nvmlComputeInstance_t *computeInstancePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstancePtr = computeInstancePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeMode_t computeMode)
        : m_type(INJECTION_COMPUTEMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeMode = computeMode;
    }
    const nvmlComputeMode_t &AsComputeMode() const
    {
        return m_value.computeMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeMode_t *computeModePtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeModePtr = computeModePtr;
    }
    nvmlComputeMode_t *AsComputeModePtr() const
    {
        return m_value.computeModePtr;
    }

    InjectionArgument(nvmlComputeMode_t *computeModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeModePtr = computeModePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeSystemState_t confComputeSystemState)
        : m_type(INJECTION_CONFCOMPUTESYSTEMSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.confComputeSystemState = confComputeSystemState;
    }
    const nvmlConfComputeSystemState_t &AsConfComputeSystemState() const
    {
        return m_value.confComputeSystemState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeSystemState_t *confComputeSystemStatePtr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESYSTEMSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.confComputeSystemStatePtr = confComputeSystemStatePtr;
    }
    nvmlConfComputeSystemState_t *AsConfComputeSystemStatePtr() const
    {
        return m_value.confComputeSystemStatePtr;
    }

    InjectionArgument(nvmlConfComputeSystemState_t *confComputeSystemStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESYSTEMSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.confComputeSystemStatePtr = confComputeSystemStatePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDetachGpuState_t detachGpuState)
        : m_type(INJECTION_DETACHGPUSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.detachGpuState = detachGpuState;
    }
    const nvmlDetachGpuState_t &AsDetachGpuState() const
    {
        return m_value.detachGpuState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDeviceAttributes_t deviceAttributes)
        : m_type(INJECTION_DEVICEATTRIBUTES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.deviceAttributes = deviceAttributes;
    }
    const nvmlDeviceAttributes_t &AsDeviceAttributes() const
    {
        return m_value.deviceAttributes;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDeviceAttributes_t *deviceAttributesPtr, bool inHeap = false)
        : m_type(INJECTION_DEVICEATTRIBUTES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.deviceAttributesPtr = deviceAttributesPtr;
    }
    nvmlDeviceAttributes_t *AsDeviceAttributesPtr() const
    {
        return m_value.deviceAttributesPtr;
    }

    InjectionArgument(nvmlDeviceAttributes_t *deviceAttributesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICEATTRIBUTES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.deviceAttributesPtr = deviceAttributesPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDevice_t device)
        : m_type(INJECTION_DEVICE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.device = device;
    }
    const nvmlDevice_t &AsDevice() const
    {
        return m_value.device;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDevice_t *devicePtr, bool inHeap = false)
        : m_type(INJECTION_DEVICE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.devicePtr = devicePtr;
    }
    nvmlDevice_t *AsDevicePtr() const
    {
        return m_value.devicePtr;
    }

    InjectionArgument(nvmlDevice_t *devicePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.devicePtr = devicePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDriverModel_t driverModel)
        : m_type(INJECTION_DRIVERMODEL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.driverModel = driverModel;
    }
    const nvmlDriverModel_t &AsDriverModel() const
    {
        return m_value.driverModel;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDriverModel_t *driverModelPtr, bool inHeap = false)
        : m_type(INJECTION_DRIVERMODEL_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.driverModelPtr = driverModelPtr;
    }
    nvmlDriverModel_t *AsDriverModelPtr() const
    {
        return m_value.driverModelPtr;
    }

    InjectionArgument(nvmlDriverModel_t *driverModelPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DRIVERMODEL_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.driverModelPtr = driverModelPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEccCounterType_t eccCounterType)
        : m_type(INJECTION_ECCCOUNTERTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eccCounterType = eccCounterType;
    }
    const nvmlEccCounterType_t &AsEccCounterType() const
    {
        return m_value.eccCounterType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEccErrorCounts_t eccErrorCounts)
        : m_type(INJECTION_ECCERRORCOUNTS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eccErrorCounts = eccErrorCounts;
    }
    const nvmlEccErrorCounts_t &AsEccErrorCounts() const
    {
        return m_value.eccErrorCounts;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEccErrorCounts_t *eccErrorCountsPtr, bool inHeap = false)
        : m_type(INJECTION_ECCERRORCOUNTS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eccErrorCountsPtr = eccErrorCountsPtr;
    }
    nvmlEccErrorCounts_t *AsEccErrorCountsPtr() const
    {
        return m_value.eccErrorCountsPtr;
    }

    InjectionArgument(nvmlEccErrorCounts_t *eccErrorCountsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ECCERRORCOUNTS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eccErrorCountsPtr = eccErrorCountsPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEnableState_t enableState)
        : m_type(INJECTION_ENABLESTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.enableState = enableState;
    }
    const nvmlEnableState_t &AsEnableState() const
    {
        return m_value.enableState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEnableState_t *enableStatePtr, bool inHeap = false)
        : m_type(INJECTION_ENABLESTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.enableStatePtr = enableStatePtr;
    }
    nvmlEnableState_t *AsEnableStatePtr() const
    {
        return m_value.enableStatePtr;
    }

    InjectionArgument(nvmlEnableState_t *enableStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ENABLESTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.enableStatePtr = enableStatePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEncoderSessionInfo_t encoderSessionInfo)
        : m_type(INJECTION_ENCODERSESSIONINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.encoderSessionInfo = encoderSessionInfo;
    }
    const nvmlEncoderSessionInfo_t &AsEncoderSessionInfo() const
    {
        return m_value.encoderSessionInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEncoderSessionInfo_t *encoderSessionInfoPtr, bool inHeap = false)
        : m_type(INJECTION_ENCODERSESSIONINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.encoderSessionInfoPtr = encoderSessionInfoPtr;
    }
    nvmlEncoderSessionInfo_t *AsEncoderSessionInfoPtr() const
    {
        return m_value.encoderSessionInfoPtr;
    }

    InjectionArgument(nvmlEncoderSessionInfo_t *encoderSessionInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ENCODERSESSIONINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.encoderSessionInfoPtr = encoderSessionInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEncoderType_t encoderType)
        : m_type(INJECTION_ENCODERTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.encoderType = encoderType;
    }
    const nvmlEncoderType_t &AsEncoderType() const
    {
        return m_value.encoderType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEventData_t eventData)
        : m_type(INJECTION_EVENTDATA)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventData = eventData;
    }
    const nvmlEventData_t &AsEventData() const
    {
        return m_value.eventData;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEventData_t *eventDataPtr, bool inHeap = false)
        : m_type(INJECTION_EVENTDATA_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventDataPtr = eventDataPtr;
    }
    nvmlEventData_t *AsEventDataPtr() const
    {
        return m_value.eventDataPtr;
    }

    InjectionArgument(nvmlEventData_t *eventDataPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_EVENTDATA_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventDataPtr = eventDataPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEventSet_t eventSet)
        : m_type(INJECTION_EVENTSET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventSet = eventSet;
    }
    const nvmlEventSet_t &AsEventSet() const
    {
        return m_value.eventSet;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEventSet_t *eventSetPtr, bool inHeap = false)
        : m_type(INJECTION_EVENTSET_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventSetPtr = eventSetPtr;
    }
    nvmlEventSet_t *AsEventSetPtr() const
    {
        return m_value.eventSetPtr;
    }

    InjectionArgument(nvmlEventSet_t *eventSetPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_EVENTSET_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventSetPtr = eventSetPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlExcludedDeviceInfo_t excludedDeviceInfo)
        : m_type(INJECTION_EXCLUDEDDEVICEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.excludedDeviceInfo = excludedDeviceInfo;
    }
    const nvmlExcludedDeviceInfo_t &AsExcludedDeviceInfo() const
    {
        return m_value.excludedDeviceInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlExcludedDeviceInfo_t *excludedDeviceInfoPtr, bool inHeap = false)
        : m_type(INJECTION_EXCLUDEDDEVICEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.excludedDeviceInfoPtr = excludedDeviceInfoPtr;
    }
    nvmlExcludedDeviceInfo_t *AsExcludedDeviceInfoPtr() const
    {
        return m_value.excludedDeviceInfoPtr;
    }

    InjectionArgument(nvmlExcludedDeviceInfo_t *excludedDeviceInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_EXCLUDEDDEVICEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.excludedDeviceInfoPtr = excludedDeviceInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFBCSessionInfo_t fBCSessionInfo)
        : m_type(INJECTION_FBCSESSIONINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCSessionInfo = fBCSessionInfo;
    }
    const nvmlFBCSessionInfo_t &AsFBCSessionInfo() const
    {
        return m_value.fBCSessionInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFBCSessionInfo_t *fBCSessionInfoPtr, bool inHeap = false)
        : m_type(INJECTION_FBCSESSIONINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCSessionInfoPtr = fBCSessionInfoPtr;
    }
    nvmlFBCSessionInfo_t *AsFBCSessionInfoPtr() const
    {
        return m_value.fBCSessionInfoPtr;
    }

    InjectionArgument(nvmlFBCSessionInfo_t *fBCSessionInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FBCSESSIONINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCSessionInfoPtr = fBCSessionInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFBCStats_t fBCStats)
        : m_type(INJECTION_FBCSTATS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCStats = fBCStats;
    }
    const nvmlFBCStats_t &AsFBCStats() const
    {
        return m_value.fBCStats;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFBCStats_t *fBCStatsPtr, bool inHeap = false)
        : m_type(INJECTION_FBCSTATS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCStatsPtr = fBCStatsPtr;
    }
    nvmlFBCStats_t *AsFBCStatsPtr() const
    {
        return m_value.fBCStatsPtr;
    }

    InjectionArgument(nvmlFBCStats_t *fBCStatsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FBCSTATS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCStatsPtr = fBCStatsPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFieldValue_t fieldValue)
        : m_type(INJECTION_FIELDVALUE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fieldValue = fieldValue;
    }
    const nvmlFieldValue_t &AsFieldValue() const
    {
        return m_value.fieldValue;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFieldValue_t *fieldValuePtr, bool inHeap = false)
        : m_type(INJECTION_FIELDVALUE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fieldValuePtr = fieldValuePtr;
    }
    nvmlFieldValue_t *AsFieldValuePtr() const
    {
        return m_value.fieldValuePtr;
    }

    InjectionArgument(nvmlFieldValue_t *fieldValuePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FIELDVALUE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fieldValuePtr = fieldValuePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmMetricsGet_t gpmMetricsGet)
        : m_type(INJECTION_GPMMETRICSGET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmMetricsGet = gpmMetricsGet;
    }
    const nvmlGpmMetricsGet_t &AsGpmMetricsGet() const
    {
        return m_value.gpmMetricsGet;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmMetricsGet_t *gpmMetricsGetPtr, bool inHeap = false)
        : m_type(INJECTION_GPMMETRICSGET_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmMetricsGetPtr = gpmMetricsGetPtr;
    }
    nvmlGpmMetricsGet_t *AsGpmMetricsGetPtr() const
    {
        return m_value.gpmMetricsGetPtr;
    }

    InjectionArgument(nvmlGpmMetricsGet_t *gpmMetricsGetPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMMETRICSGET_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmMetricsGetPtr = gpmMetricsGetPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmSample_t gpmSample)
        : m_type(INJECTION_GPMSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSample = gpmSample;
    }
    const nvmlGpmSample_t &AsGpmSample() const
    {
        return m_value.gpmSample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmSample_t *gpmSamplePtr, bool inHeap = false)
        : m_type(INJECTION_GPMSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSamplePtr = gpmSamplePtr;
    }
    nvmlGpmSample_t *AsGpmSamplePtr() const
    {
        return m_value.gpmSamplePtr;
    }

    InjectionArgument(nvmlGpmSample_t *gpmSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSamplePtr = gpmSamplePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmSupport_t gpmSupport)
        : m_type(INJECTION_GPMSUPPORT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSupport = gpmSupport;
    }
    const nvmlGpmSupport_t &AsGpmSupport() const
    {
        return m_value.gpmSupport;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmSupport_t *gpmSupportPtr, bool inHeap = false)
        : m_type(INJECTION_GPMSUPPORT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSupportPtr = gpmSupportPtr;
    }
    nvmlGpmSupport_t *AsGpmSupportPtr() const
    {
        return m_value.gpmSupportPtr;
    }

    InjectionArgument(nvmlGpmSupport_t *gpmSupportPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMSUPPORT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSupportPtr = gpmSupportPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuDynamicPstatesInfo_t gpuDynamicPstatesInfo)
        : m_type(INJECTION_GPUDYNAMICPSTATESINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuDynamicPstatesInfo = gpuDynamicPstatesInfo;
    }
    const nvmlGpuDynamicPstatesInfo_t &AsGpuDynamicPstatesInfo() const
    {
        return m_value.gpuDynamicPstatesInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuDynamicPstatesInfo_t *gpuDynamicPstatesInfoPtr, bool inHeap = false)
        : m_type(INJECTION_GPUDYNAMICPSTATESINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuDynamicPstatesInfoPtr = gpuDynamicPstatesInfoPtr;
    }
    nvmlGpuDynamicPstatesInfo_t *AsGpuDynamicPstatesInfoPtr() const
    {
        return m_value.gpuDynamicPstatesInfoPtr;
    }

    InjectionArgument(nvmlGpuDynamicPstatesInfo_t *gpuDynamicPstatesInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUDYNAMICPSTATESINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuDynamicPstatesInfoPtr = gpuDynamicPstatesInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceInfo_t gpuInstanceInfo)
        : m_type(INJECTION_GPUINSTANCEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceInfo = gpuInstanceInfo;
    }
    const nvmlGpuInstanceInfo_t &AsGpuInstanceInfo() const
    {
        return m_value.gpuInstanceInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceInfo_t *gpuInstanceInfoPtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceInfoPtr = gpuInstanceInfoPtr;
    }
    nvmlGpuInstanceInfo_t *AsGpuInstanceInfoPtr() const
    {
        return m_value.gpuInstanceInfoPtr;
    }

    InjectionArgument(nvmlGpuInstanceInfo_t *gpuInstanceInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceInfoPtr = gpuInstanceInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstancePlacement_t gpuInstancePlacement)
        : m_type(INJECTION_GPUINSTANCEPLACEMENT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstancePlacement = gpuInstancePlacement;
    }
    const nvmlGpuInstancePlacement_t &AsGpuInstancePlacement() const
    {
        return m_value.gpuInstancePlacement;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstancePlacement_t *gpuInstancePlacementPtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPLACEMENT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstancePlacementPtr = gpuInstancePlacementPtr;
    }
    nvmlGpuInstancePlacement_t *AsGpuInstancePlacementPtr() const
    {
        return m_value.gpuInstancePlacementPtr;
    }

    InjectionArgument(nvmlGpuInstancePlacement_t *gpuInstancePlacementPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPLACEMENT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstancePlacementPtr = gpuInstancePlacementPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceProfileInfo_t gpuInstanceProfileInfo)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfo = gpuInstanceProfileInfo;
    }
    const nvmlGpuInstanceProfileInfo_t &AsGpuInstanceProfileInfo() const
    {
        return m_value.gpuInstanceProfileInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceProfileInfo_t *gpuInstanceProfileInfoPtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfoPtr = gpuInstanceProfileInfoPtr;
    }
    nvmlGpuInstanceProfileInfo_t *AsGpuInstanceProfileInfoPtr() const
    {
        return m_value.gpuInstanceProfileInfoPtr;
    }

    InjectionArgument(nvmlGpuInstanceProfileInfo_t *gpuInstanceProfileInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfoPtr = gpuInstanceProfileInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceProfileInfo_v2_t gpuInstanceProfileInfo_v2)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfo_v2 = gpuInstanceProfileInfo_v2;
    }
    const nvmlGpuInstanceProfileInfo_v2_t &AsGpuInstanceProfileInfo_v2() const
    {
        return m_value.gpuInstanceProfileInfo_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceProfileInfo_v2_t *gpuInstanceProfileInfo_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfo_v2Ptr = gpuInstanceProfileInfo_v2Ptr;
    }
    nvmlGpuInstanceProfileInfo_v2_t *AsGpuInstanceProfileInfo_v2Ptr() const
    {
        return m_value.gpuInstanceProfileInfo_v2Ptr;
    }

    InjectionArgument(nvmlGpuInstanceProfileInfo_v2_t *gpuInstanceProfileInfo_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfo_v2Ptr = gpuInstanceProfileInfo_v2Ptr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstance_t gpuInstance)
        : m_type(INJECTION_GPUINSTANCE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstance = gpuInstance;
    }
    const nvmlGpuInstance_t &AsGpuInstance() const
    {
        return m_value.gpuInstance;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstance_t *gpuInstancePtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstancePtr = gpuInstancePtr;
    }
    nvmlGpuInstance_t *AsGpuInstancePtr() const
    {
        return m_value.gpuInstancePtr;
    }

    InjectionArgument(nvmlGpuInstance_t *gpuInstancePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstancePtr = gpuInstancePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuOperationMode_t gpuOperationMode)
        : m_type(INJECTION_GPUOPERATIONMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuOperationMode = gpuOperationMode;
    }
    const nvmlGpuOperationMode_t &AsGpuOperationMode() const
    {
        return m_value.gpuOperationMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuOperationMode_t *gpuOperationModePtr, bool inHeap = false)
        : m_type(INJECTION_GPUOPERATIONMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuOperationModePtr = gpuOperationModePtr;
    }
    nvmlGpuOperationMode_t *AsGpuOperationModePtr() const
    {
        return m_value.gpuOperationModePtr;
    }

    InjectionArgument(nvmlGpuOperationMode_t *gpuOperationModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUOPERATIONMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuOperationModePtr = gpuOperationModePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuP2PCapsIndex_t gpuP2PCapsIndex)
        : m_type(INJECTION_GPUP2PCAPSINDEX)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuP2PCapsIndex = gpuP2PCapsIndex;
    }
    const nvmlGpuP2PCapsIndex_t &AsGpuP2PCapsIndex() const
    {
        return m_value.gpuP2PCapsIndex;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuP2PStatus_t gpuP2PStatus)
        : m_type(INJECTION_GPUP2PSTATUS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuP2PStatus = gpuP2PStatus;
    }
    const nvmlGpuP2PStatus_t &AsGpuP2PStatus() const
    {
        return m_value.gpuP2PStatus;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuP2PStatus_t *gpuP2PStatusPtr, bool inHeap = false)
        : m_type(INJECTION_GPUP2PSTATUS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuP2PStatusPtr = gpuP2PStatusPtr;
    }
    nvmlGpuP2PStatus_t *AsGpuP2PStatusPtr() const
    {
        return m_value.gpuP2PStatusPtr;
    }

    InjectionArgument(nvmlGpuP2PStatus_t *gpuP2PStatusPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUP2PSTATUS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuP2PStatusPtr = gpuP2PStatusPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuThermalSettings_t gpuThermalSettings)
        : m_type(INJECTION_GPUTHERMALSETTINGS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuThermalSettings = gpuThermalSettings;
    }
    const nvmlGpuThermalSettings_t &AsGpuThermalSettings() const
    {
        return m_value.gpuThermalSettings;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuThermalSettings_t *gpuThermalSettingsPtr, bool inHeap = false)
        : m_type(INJECTION_GPUTHERMALSETTINGS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuThermalSettingsPtr = gpuThermalSettingsPtr;
    }
    nvmlGpuThermalSettings_t *AsGpuThermalSettingsPtr() const
    {
        return m_value.gpuThermalSettingsPtr;
    }

    InjectionArgument(nvmlGpuThermalSettings_t *gpuThermalSettingsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUTHERMALSETTINGS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuThermalSettingsPtr = gpuThermalSettingsPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuTopologyLevel_t gpuTopologyLevel)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuTopologyLevel = gpuTopologyLevel;
    }
    const nvmlGpuTopologyLevel_t &AsGpuTopologyLevel() const
    {
        return m_value.gpuTopologyLevel;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuTopologyLevel_t *gpuTopologyLevelPtr, bool inHeap = false)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuTopologyLevelPtr = gpuTopologyLevelPtr;
    }
    nvmlGpuTopologyLevel_t *AsGpuTopologyLevelPtr() const
    {
        return m_value.gpuTopologyLevelPtr;
    }

    InjectionArgument(nvmlGpuTopologyLevel_t *gpuTopologyLevelPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuTopologyLevelPtr = gpuTopologyLevelPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuVirtualizationMode_t gpuVirtualizationMode)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuVirtualizationMode = gpuVirtualizationMode;
    }
    const nvmlGpuVirtualizationMode_t &AsGpuVirtualizationMode() const
    {
        return m_value.gpuVirtualizationMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuVirtualizationMode_t *gpuVirtualizationModePtr, bool inHeap = false)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuVirtualizationModePtr = gpuVirtualizationModePtr;
    }
    nvmlGpuVirtualizationMode_t *AsGpuVirtualizationModePtr() const
    {
        return m_value.gpuVirtualizationModePtr;
    }

    InjectionArgument(nvmlGpuVirtualizationMode_t *gpuVirtualizationModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuVirtualizationModePtr = gpuVirtualizationModePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGridLicensableFeatures_t gridLicensableFeatures)
        : m_type(INJECTION_GRIDLICENSABLEFEATURES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gridLicensableFeatures = gridLicensableFeatures;
    }
    const nvmlGridLicensableFeatures_t &AsGridLicensableFeatures() const
    {
        return m_value.gridLicensableFeatures;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGridLicensableFeatures_t *gridLicensableFeaturesPtr, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSABLEFEATURES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gridLicensableFeaturesPtr = gridLicensableFeaturesPtr;
    }
    nvmlGridLicensableFeatures_t *AsGridLicensableFeaturesPtr() const
    {
        return m_value.gridLicensableFeaturesPtr;
    }

    InjectionArgument(nvmlGridLicensableFeatures_t *gridLicensableFeaturesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSABLEFEATURES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gridLicensableFeaturesPtr = gridLicensableFeaturesPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlHostVgpuMode_t hostVgpuMode)
        : m_type(INJECTION_HOSTVGPUMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hostVgpuMode = hostVgpuMode;
    }
    const nvmlHostVgpuMode_t &AsHostVgpuMode() const
    {
        return m_value.hostVgpuMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlHostVgpuMode_t *hostVgpuModePtr, bool inHeap = false)
        : m_type(INJECTION_HOSTVGPUMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hostVgpuModePtr = hostVgpuModePtr;
    }
    nvmlHostVgpuMode_t *AsHostVgpuModePtr() const
    {
        return m_value.hostVgpuModePtr;
    }

    InjectionArgument(nvmlHostVgpuMode_t *hostVgpuModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_HOSTVGPUMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hostVgpuModePtr = hostVgpuModePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlHwbcEntry_t hwbcEntry)
        : m_type(INJECTION_HWBCENTRY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hwbcEntry = hwbcEntry;
    }
    const nvmlHwbcEntry_t &AsHwbcEntry() const
    {
        return m_value.hwbcEntry;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlHwbcEntry_t *hwbcEntryPtr, bool inHeap = false)
        : m_type(INJECTION_HWBCENTRY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hwbcEntryPtr = hwbcEntryPtr;
    }
    nvmlHwbcEntry_t *AsHwbcEntryPtr() const
    {
        return m_value.hwbcEntryPtr;
    }

    InjectionArgument(nvmlHwbcEntry_t *hwbcEntryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_HWBCENTRY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hwbcEntryPtr = hwbcEntryPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlInforomObject_t inforomObject)
        : m_type(INJECTION_INFOROMOBJECT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.inforomObject = inforomObject;
    }
    const nvmlInforomObject_t &AsInforomObject() const
    {
        return m_value.inforomObject;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlIntNvLinkDeviceType_t intNvLinkDeviceType)
        : m_type(INJECTION_INTNVLINKDEVICETYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.intNvLinkDeviceType = intNvLinkDeviceType;
    }
    const nvmlIntNvLinkDeviceType_t &AsIntNvLinkDeviceType() const
    {
        return m_value.intNvLinkDeviceType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlIntNvLinkDeviceType_t *intNvLinkDeviceTypePtr, bool inHeap = false)
        : m_type(INJECTION_INTNVLINKDEVICETYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.intNvLinkDeviceTypePtr = intNvLinkDeviceTypePtr;
    }
    nvmlIntNvLinkDeviceType_t *AsIntNvLinkDeviceTypePtr() const
    {
        return m_value.intNvLinkDeviceTypePtr;
    }

    InjectionArgument(nvmlIntNvLinkDeviceType_t *intNvLinkDeviceTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_INTNVLINKDEVICETYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.intNvLinkDeviceTypePtr = intNvLinkDeviceTypePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlLedColor_t ledColor)
        : m_type(INJECTION_LEDCOLOR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ledColor = ledColor;
    }
    const nvmlLedColor_t &AsLedColor() const
    {
        return m_value.ledColor;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlLedState_t ledState)
        : m_type(INJECTION_LEDSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ledState = ledState;
    }
    const nvmlLedState_t &AsLedState() const
    {
        return m_value.ledState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlLedState_t *ledStatePtr, bool inHeap = false)
        : m_type(INJECTION_LEDSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ledStatePtr = ledStatePtr;
    }
    nvmlLedState_t *AsLedStatePtr() const
    {
        return m_value.ledStatePtr;
    }

    InjectionArgument(nvmlLedState_t *ledStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_LEDSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ledStatePtr = ledStatePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemoryErrorType_t memoryErrorType)
        : m_type(INJECTION_MEMORYERRORTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memoryErrorType = memoryErrorType;
    }
    const nvmlMemoryErrorType_t &AsMemoryErrorType() const
    {
        return m_value.memoryErrorType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemoryLocation_t memoryLocation)
        : m_type(INJECTION_MEMORYLOCATION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memoryLocation = memoryLocation;
    }
    const nvmlMemoryLocation_t &AsMemoryLocation() const
    {
        return m_value.memoryLocation;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemory_t memory)
        : m_type(INJECTION_MEMORY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memory = memory;
    }
    const nvmlMemory_t &AsMemory() const
    {
        return m_value.memory;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemory_t *memoryPtr, bool inHeap = false)
        : m_type(INJECTION_MEMORY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memoryPtr = memoryPtr;
    }
    nvmlMemory_t *AsMemoryPtr() const
    {
        return m_value.memoryPtr;
    }

    InjectionArgument(nvmlMemory_t *memoryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_MEMORY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memoryPtr = memoryPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemory_v2_t memory_v2)
        : m_type(INJECTION_MEMORY_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memory_v2 = memory_v2;
    }
    const nvmlMemory_v2_t &AsMemory_v2() const
    {
        return m_value.memory_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemory_v2_t *memory_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_MEMORY_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memory_v2Ptr = memory_v2Ptr;
    }
    nvmlMemory_v2_t *AsMemory_v2Ptr() const
    {
        return m_value.memory_v2Ptr;
    }

    InjectionArgument(nvmlMemory_v2_t *memory_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_MEMORY_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memory_v2Ptr = memory_v2Ptr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkCapability_t nvLinkCapability)
        : m_type(INJECTION_NVLINKCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkCapability = nvLinkCapability;
    }
    const nvmlNvLinkCapability_t &AsNvLinkCapability() const
    {
        return m_value.nvLinkCapability;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkErrorCounter_t nvLinkErrorCounter)
        : m_type(INJECTION_NVLINKERRORCOUNTER)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkErrorCounter = nvLinkErrorCounter;
    }
    const nvmlNvLinkErrorCounter_t &AsNvLinkErrorCounter() const
    {
        return m_value.nvLinkErrorCounter;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkUtilizationControl_t nvLinkUtilizationControl)
        : m_type(INJECTION_NVLINKUTILIZATIONCONTROL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkUtilizationControl = nvLinkUtilizationControl;
    }
    const nvmlNvLinkUtilizationControl_t &AsNvLinkUtilizationControl() const
    {
        return m_value.nvLinkUtilizationControl;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkUtilizationControl_t *nvLinkUtilizationControlPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCONTROL_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkUtilizationControlPtr = nvLinkUtilizationControlPtr;
    }
    nvmlNvLinkUtilizationControl_t *AsNvLinkUtilizationControlPtr() const
    {
        return m_value.nvLinkUtilizationControlPtr;
    }

    InjectionArgument(nvmlNvLinkUtilizationControl_t *nvLinkUtilizationControlPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCONTROL_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkUtilizationControlPtr = nvLinkUtilizationControlPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPSUInfo_t pSUInfo)
        : m_type(INJECTION_PSUINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pSUInfo = pSUInfo;
    }
    const nvmlPSUInfo_t &AsPSUInfo() const
    {
        return m_value.pSUInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPSUInfo_t *pSUInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PSUINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pSUInfoPtr = pSUInfoPtr;
    }
    nvmlPSUInfo_t *AsPSUInfoPtr() const
    {
        return m_value.pSUInfoPtr;
    }

    InjectionArgument(nvmlPSUInfo_t *pSUInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PSUINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pSUInfoPtr = pSUInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPageRetirementCause_t pageRetirementCause)
        : m_type(INJECTION_PAGERETIREMENTCAUSE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pageRetirementCause = pageRetirementCause;
    }
    const nvmlPageRetirementCause_t &AsPageRetirementCause() const
    {
        return m_value.pageRetirementCause;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPciInfo_t pciInfo)
        : m_type(INJECTION_PCIINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pciInfo = pciInfo;
    }
    const nvmlPciInfo_t &AsPciInfo() const
    {
        return m_value.pciInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPciInfo_t *pciInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PCIINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pciInfoPtr = pciInfoPtr;
    }
    nvmlPciInfo_t *AsPciInfoPtr() const
    {
        return m_value.pciInfoPtr;
    }

    InjectionArgument(nvmlPciInfo_t *pciInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PCIINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pciInfoPtr = pciInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPcieLinkState_t pcieLinkState)
        : m_type(INJECTION_PCIELINKSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pcieLinkState = pcieLinkState;
    }
    const nvmlPcieLinkState_t &AsPcieLinkState() const
    {
        return m_value.pcieLinkState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPcieUtilCounter_t pcieUtilCounter)
        : m_type(INJECTION_PCIEUTILCOUNTER)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pcieUtilCounter = pcieUtilCounter;
    }
    const nvmlPcieUtilCounter_t &AsPcieUtilCounter() const
    {
        return m_value.pcieUtilCounter;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPerfPolicyType_t perfPolicyType)
        : m_type(INJECTION_PERFPOLICYTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.perfPolicyType = perfPolicyType;
    }
    const nvmlPerfPolicyType_t &AsPerfPolicyType() const
    {
        return m_value.perfPolicyType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_t processInfo)
        : m_type(INJECTION_PROCESSINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo = processInfo;
    }
    const nvmlProcessInfo_t &AsProcessInfo() const
    {
        return m_value.processInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_t *processInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfoPtr = processInfoPtr;
    }
    nvmlProcessInfo_t *AsProcessInfoPtr() const
    {
        return m_value.processInfoPtr;
    }

    InjectionArgument(nvmlProcessInfo_t *processInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfoPtr = processInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_v1_t processInfo_v1)
        : m_type(INJECTION_PROCESSINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v1 = processInfo_v1;
    }
    const nvmlProcessInfo_v1_t &AsProcessInfo_v1() const
    {
        return m_value.processInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_v1_t *processInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v1Ptr = processInfo_v1Ptr;
    }
    nvmlProcessInfo_v1_t *AsProcessInfo_v1Ptr() const
    {
        return m_value.processInfo_v1Ptr;
    }

    InjectionArgument(nvmlProcessInfo_v1_t *processInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v1Ptr = processInfo_v1Ptr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_v2_t processInfo_v2)
        : m_type(INJECTION_PROCESSINFO_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v2 = processInfo_v2;
    }
    const nvmlProcessInfo_v2_t &AsProcessInfo_v2() const
    {
        return m_value.processInfo_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_v2_t *processInfo_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v2Ptr = processInfo_v2Ptr;
    }
    nvmlProcessInfo_v2_t *AsProcessInfo_v2Ptr() const
    {
        return m_value.processInfo_v2Ptr;
    }

    InjectionArgument(nvmlProcessInfo_v2_t *processInfo_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v2Ptr = processInfo_v2Ptr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessUtilizationSample_t processUtilizationSample)
        : m_type(INJECTION_PROCESSUTILIZATIONSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processUtilizationSample = processUtilizationSample;
    }
    const nvmlProcessUtilizationSample_t &AsProcessUtilizationSample() const
    {
        return m_value.processUtilizationSample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessUtilizationSample_t *processUtilizationSamplePtr, bool inHeap = false)
        : m_type(INJECTION_PROCESSUTILIZATIONSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processUtilizationSamplePtr = processUtilizationSamplePtr;
    }
    nvmlProcessUtilizationSample_t *AsProcessUtilizationSamplePtr() const
    {
        return m_value.processUtilizationSamplePtr;
    }

    InjectionArgument(nvmlProcessUtilizationSample_t *processUtilizationSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSUTILIZATIONSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processUtilizationSamplePtr = processUtilizationSamplePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPstates_t pstates)
        : m_type(INJECTION_PSTATES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pstates = pstates;
    }
    const nvmlPstates_t &AsPstates() const
    {
        return m_value.pstates;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPstates_t *pstatesPtr, bool inHeap = false)
        : m_type(INJECTION_PSTATES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pstatesPtr = pstatesPtr;
    }
    nvmlPstates_t *AsPstatesPtr() const
    {
        return m_value.pstatesPtr;
    }

    InjectionArgument(nvmlPstates_t *pstatesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PSTATES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pstatesPtr = pstatesPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlRestrictedAPI_t restrictedAPI)
        : m_type(INJECTION_RESTRICTEDAPI)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.restrictedAPI = restrictedAPI;
    }
    const nvmlRestrictedAPI_t &AsRestrictedAPI() const
    {
        return m_value.restrictedAPI;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlReturn_t nvmlReturn)
        : m_type(INJECTION_RETURN)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvmlReturn = nvmlReturn;
    }
    const nvmlReturn_t &AsNvmlReturn() const
    {
        return m_value.nvmlReturn;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlReturn_t *nvmlReturnPtr, bool inHeap = false)
        : m_type(INJECTION_RETURN_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvmlReturnPtr = nvmlReturnPtr;
    }
    nvmlReturn_t *AsNvmlReturnPtr() const
    {
        return m_value.nvmlReturnPtr;
    }

    InjectionArgument(nvmlReturn_t *nvmlReturnPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_RETURN_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvmlReturnPtr = nvmlReturnPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlRowRemapperHistogramValues_t rowRemapperHistogramValues)
        : m_type(INJECTION_ROWREMAPPERHISTOGRAMVALUES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.rowRemapperHistogramValues = rowRemapperHistogramValues;
    }
    const nvmlRowRemapperHistogramValues_t &AsRowRemapperHistogramValues() const
    {
        return m_value.rowRemapperHistogramValues;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlRowRemapperHistogramValues_t *rowRemapperHistogramValuesPtr, bool inHeap = false)
        : m_type(INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.rowRemapperHistogramValuesPtr = rowRemapperHistogramValuesPtr;
    }
    nvmlRowRemapperHistogramValues_t *AsRowRemapperHistogramValuesPtr() const
    {
        return m_value.rowRemapperHistogramValuesPtr;
    }

    InjectionArgument(nvmlRowRemapperHistogramValues_t *rowRemapperHistogramValuesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.rowRemapperHistogramValuesPtr = rowRemapperHistogramValuesPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlSample_t sample)
        : m_type(INJECTION_SAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.sample = sample;
    }
    const nvmlSample_t &AsSample() const
    {
        return m_value.sample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlSample_t *samplePtr, bool inHeap = false)
        : m_type(INJECTION_SAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.samplePtr = samplePtr;
    }
    nvmlSample_t *AsSamplePtr() const
    {
        return m_value.samplePtr;
    }

    InjectionArgument(nvmlSample_t *samplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_SAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.samplePtr = samplePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlSamplingType_t samplingType)
        : m_type(INJECTION_SAMPLINGTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.samplingType = samplingType;
    }
    const nvmlSamplingType_t &AsSamplingType() const
    {
        return m_value.samplingType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlTemperatureSensors_t temperatureSensors)
        : m_type(INJECTION_TEMPERATURESENSORS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.temperatureSensors = temperatureSensors;
    }
    const nvmlTemperatureSensors_t &AsTemperatureSensors() const
    {
        return m_value.temperatureSensors;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlTemperatureThresholds_t temperatureThresholds)
        : m_type(INJECTION_TEMPERATURETHRESHOLDS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.temperatureThresholds = temperatureThresholds;
    }
    const nvmlTemperatureThresholds_t &AsTemperatureThresholds() const
    {
        return m_value.temperatureThresholds;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnitFanSpeeds_t unitFanSpeeds)
        : m_type(INJECTION_UNITFANSPEEDS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitFanSpeeds = unitFanSpeeds;
    }
    const nvmlUnitFanSpeeds_t &AsUnitFanSpeeds() const
    {
        return m_value.unitFanSpeeds;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnitFanSpeeds_t *unitFanSpeedsPtr, bool inHeap = false)
        : m_type(INJECTION_UNITFANSPEEDS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitFanSpeedsPtr = unitFanSpeedsPtr;
    }
    nvmlUnitFanSpeeds_t *AsUnitFanSpeedsPtr() const
    {
        return m_value.unitFanSpeedsPtr;
    }

    InjectionArgument(nvmlUnitFanSpeeds_t *unitFanSpeedsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UNITFANSPEEDS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitFanSpeedsPtr = unitFanSpeedsPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnitInfo_t unitInfo)
        : m_type(INJECTION_UNITINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitInfo = unitInfo;
    }
    const nvmlUnitInfo_t &AsUnitInfo() const
    {
        return m_value.unitInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnitInfo_t *unitInfoPtr, bool inHeap = false)
        : m_type(INJECTION_UNITINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitInfoPtr = unitInfoPtr;
    }
    nvmlUnitInfo_t *AsUnitInfoPtr() const
    {
        return m_value.unitInfoPtr;
    }

    InjectionArgument(nvmlUnitInfo_t *unitInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UNITINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitInfoPtr = unitInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnit_t unit)
        : m_type(INJECTION_UNIT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unit = unit;
    }
    const nvmlUnit_t &AsUnit() const
    {
        return m_value.unit;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnit_t *unitPtr, bool inHeap = false)
        : m_type(INJECTION_UNIT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitPtr = unitPtr;
    }
    nvmlUnit_t *AsUnitPtr() const
    {
        return m_value.unitPtr;
    }

    InjectionArgument(nvmlUnit_t *unitPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UNIT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitPtr = unitPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUtilization_t utilization)
        : m_type(INJECTION_UTILIZATION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.utilization = utilization;
    }
    const nvmlUtilization_t &AsUtilization() const
    {
        return m_value.utilization;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUtilization_t *utilizationPtr, bool inHeap = false)
        : m_type(INJECTION_UTILIZATION_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.utilizationPtr = utilizationPtr;
    }
    nvmlUtilization_t *AsUtilizationPtr() const
    {
        return m_value.utilizationPtr;
    }

    InjectionArgument(nvmlUtilization_t *utilizationPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UTILIZATION_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.utilizationPtr = utilizationPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlValueType_t valueType)
        : m_type(INJECTION_VALUETYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.valueType = valueType;
    }
    const nvmlValueType_t &AsValueType() const
    {
        return m_value.valueType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlValueType_t *valueTypePtr, bool inHeap = false)
        : m_type(INJECTION_VALUETYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.valueTypePtr = valueTypePtr;
    }
    nvmlValueType_t *AsValueTypePtr() const
    {
        return m_value.valueTypePtr;
    }

    InjectionArgument(nvmlValueType_t *valueTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VALUETYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.valueTypePtr = valueTypePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuCapability_t vgpuCapability)
        : m_type(INJECTION_VGPUCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuCapability = vgpuCapability;
    }
    const nvmlVgpuCapability_t &AsVgpuCapability() const
    {
        return m_value.vgpuCapability;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuInstanceUtilizationSample_t vgpuInstanceUtilizationSample)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuInstanceUtilizationSample = vgpuInstanceUtilizationSample;
    }
    const nvmlVgpuInstanceUtilizationSample_t &AsVgpuInstanceUtilizationSample() const
    {
        return m_value.vgpuInstanceUtilizationSample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuInstanceUtilizationSample_t *vgpuInstanceUtilizationSamplePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuInstanceUtilizationSamplePtr = vgpuInstanceUtilizationSamplePtr;
    }
    nvmlVgpuInstanceUtilizationSample_t *AsVgpuInstanceUtilizationSamplePtr() const
    {
        return m_value.vgpuInstanceUtilizationSamplePtr;
    }

    InjectionArgument(nvmlVgpuInstanceUtilizationSample_t *vgpuInstanceUtilizationSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuInstanceUtilizationSamplePtr = vgpuInstanceUtilizationSamplePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuLicenseInfo_t vgpuLicenseInfo)
        : m_type(INJECTION_VGPULICENSEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuLicenseInfo = vgpuLicenseInfo;
    }
    const nvmlVgpuLicenseInfo_t &AsVgpuLicenseInfo() const
    {
        return m_value.vgpuLicenseInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuLicenseInfo_t *vgpuLicenseInfoPtr, bool inHeap = false)
        : m_type(INJECTION_VGPULICENSEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuLicenseInfoPtr = vgpuLicenseInfoPtr;
    }
    nvmlVgpuLicenseInfo_t *AsVgpuLicenseInfoPtr() const
    {
        return m_value.vgpuLicenseInfoPtr;
    }

    InjectionArgument(nvmlVgpuLicenseInfo_t *vgpuLicenseInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPULICENSEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuLicenseInfoPtr = vgpuLicenseInfoPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuMetadata_t vgpuMetadata)
        : m_type(INJECTION_VGPUMETADATA)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuMetadata = vgpuMetadata;
    }
    const nvmlVgpuMetadata_t &AsVgpuMetadata() const
    {
        return m_value.vgpuMetadata;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuMetadata_t *vgpuMetadataPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUMETADATA_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuMetadataPtr = vgpuMetadataPtr;
    }
    nvmlVgpuMetadata_t *AsVgpuMetadataPtr() const
    {
        return m_value.vgpuMetadataPtr;
    }

    InjectionArgument(nvmlVgpuMetadata_t *vgpuMetadataPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUMETADATA_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuMetadataPtr = vgpuMetadataPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPgpuCompatibility_t vgpuPgpuCompatibility)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuCompatibility = vgpuPgpuCompatibility;
    }
    const nvmlVgpuPgpuCompatibility_t &AsVgpuPgpuCompatibility() const
    {
        return m_value.vgpuPgpuCompatibility;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPgpuCompatibility_t *vgpuPgpuCompatibilityPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuCompatibilityPtr = vgpuPgpuCompatibilityPtr;
    }
    nvmlVgpuPgpuCompatibility_t *AsVgpuPgpuCompatibilityPtr() const
    {
        return m_value.vgpuPgpuCompatibilityPtr;
    }

    InjectionArgument(nvmlVgpuPgpuCompatibility_t *vgpuPgpuCompatibilityPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuCompatibilityPtr = vgpuPgpuCompatibilityPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPgpuMetadata_t vgpuPgpuMetadata)
        : m_type(INJECTION_VGPUPGPUMETADATA)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuMetadata = vgpuPgpuMetadata;
    }
    const nvmlVgpuPgpuMetadata_t &AsVgpuPgpuMetadata() const
    {
        return m_value.vgpuPgpuMetadata;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPgpuMetadata_t *vgpuPgpuMetadataPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUMETADATA_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuMetadataPtr = vgpuPgpuMetadataPtr;
    }
    nvmlVgpuPgpuMetadata_t *AsVgpuPgpuMetadataPtr() const
    {
        return m_value.vgpuPgpuMetadataPtr;
    }

    InjectionArgument(nvmlVgpuPgpuMetadata_t *vgpuPgpuMetadataPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUMETADATA_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuMetadataPtr = vgpuPgpuMetadataPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuProcessUtilizationSample_t vgpuProcessUtilizationSample)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuProcessUtilizationSample = vgpuProcessUtilizationSample;
    }
    const nvmlVgpuProcessUtilizationSample_t &AsVgpuProcessUtilizationSample() const
    {
        return m_value.vgpuProcessUtilizationSample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuProcessUtilizationSample_t *vgpuProcessUtilizationSamplePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuProcessUtilizationSamplePtr = vgpuProcessUtilizationSamplePtr;
    }
    nvmlVgpuProcessUtilizationSample_t *AsVgpuProcessUtilizationSamplePtr() const
    {
        return m_value.vgpuProcessUtilizationSamplePtr;
    }

    InjectionArgument(nvmlVgpuProcessUtilizationSample_t *vgpuProcessUtilizationSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuProcessUtilizationSamplePtr = vgpuProcessUtilizationSamplePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuVersion_t vgpuVersion)
        : m_type(INJECTION_VGPUVERSION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVersion = vgpuVersion;
    }
    const nvmlVgpuVersion_t &AsVgpuVersion() const
    {
        return m_value.vgpuVersion;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuVersion_t *vgpuVersionPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUVERSION_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVersionPtr = vgpuVersionPtr;
    }
    nvmlVgpuVersion_t *AsVgpuVersionPtr() const
    {
        return m_value.vgpuVersionPtr;
    }

    InjectionArgument(nvmlVgpuVersion_t *vgpuVersionPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUVERSION_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVersionPtr = vgpuVersionPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuVmIdType_t vgpuVmIdType)
        : m_type(INJECTION_VGPUVMIDTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVmIdType = vgpuVmIdType;
    }
    const nvmlVgpuVmIdType_t &AsVgpuVmIdType() const
    {
        return m_value.vgpuVmIdType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuVmIdType_t *vgpuVmIdTypePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUVMIDTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVmIdTypePtr = vgpuVmIdTypePtr;
    }
    nvmlVgpuVmIdType_t *AsVgpuVmIdTypePtr() const
    {
        return m_value.vgpuVmIdTypePtr;
    }

    InjectionArgument(nvmlVgpuVmIdType_t *vgpuVmIdTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUVMIDTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVmIdTypePtr = vgpuVmIdTypePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlViolationTime_t violationTime)
        : m_type(INJECTION_VIOLATIONTIME)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.violationTime = violationTime;
    }
    const nvmlViolationTime_t &AsViolationTime() const
    {
        return m_value.violationTime;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlViolationTime_t *violationTimePtr, bool inHeap = false)
        : m_type(INJECTION_VIOLATIONTIME_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.violationTimePtr = violationTimePtr;
    }
    nvmlViolationTime_t *AsViolationTimePtr() const
    {
        return m_value.violationTimePtr;
    }

    InjectionArgument(nvmlViolationTime_t *violationTimePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VIOLATIONTIME_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.violationTimePtr = violationTimePtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned int ui)
        : m_type(INJECTION_UINT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ui = ui;
    }
    const unsigned int &AsUInt() const
    {
        return m_value.ui;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned int *uiPtr, bool inHeap = false)
        : m_type(INJECTION_UINT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.uiPtr = uiPtr;
    }
    unsigned int *AsUIntPtr() const
    {
        return m_value.uiPtr;
    }

    InjectionArgument(unsigned int *uiPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UINT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.uiPtr = uiPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned long ul)
        : m_type(INJECTION_ULONG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ul = ul;
    }
    const unsigned long &AsULong() const
    {
        return m_value.ul;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned long *ulPtr, bool inHeap = false)
        : m_type(INJECTION_ULONG_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ulPtr = ulPtr;
    }
    unsigned long *AsULongPtr() const
    {
        return m_value.ulPtr;
    }

    InjectionArgument(unsigned long *ulPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ULONG_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ulPtr = ulPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned long long ull)
        : m_type(INJECTION_ULONG_LONG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ull = ull;
    }
    const unsigned long long &AsULongLong() const
    {
        return m_value.ull;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned long long *ullPtr, bool inHeap = false)
        : m_type(INJECTION_ULONG_LONG_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ullPtr = ullPtr;
    }
    unsigned long long *AsULongLongPtr() const
    {
        return m_value.ullPtr;
    }

    InjectionArgument(unsigned long long *ullPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ULONG_LONG_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ullPtr = ullPtr;
    }

    // The following snippet is generated from write_injection_argument_copy_constructor
    InjectionArgument &operator=(const InjectionArgument &other)
    {
        DeepCopy(other);
        return *this;
    }

    // The following snippet is generated from write_injection_argument_copy_constructor
    InjectionArgument(const InjectionArgument &other)
    {
        DeepCopy(other);
    }

    ~InjectionArgument();

    InjectionArgument(const std::string &val)
        : m_type(INJECTION_STRING)
        , m_str(val)
    {
        memset(&m_value, 0, sizeof(m_value));
    }
    std::string AsString() const
    {
        switch (m_type)
        {
            case INJECTION_STRING:
            {
                return m_str;
            }
                break;
            case INJECTION_CHAR_PTR:
            {
                if (m_value.str != nullptr)
                {
                    return std::string(m_value.str);
                }
                break;
            }
            case INJECTION_CONST_CHAR_PTR:
            {
                if (m_value.const_str != nullptr)
                {
                    return std::string(m_value.const_str);
                }
                break;
            }
            default:
                break;
        }
        return "";
    }
};