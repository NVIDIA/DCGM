/*
 * Copyright (c) 2024, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*
 * NOTE: This code is auto-generated by generate_nvml_stubs.py
 * DO NOT EDIT MANUALLY
 */


// clang-format off
#pragma once

#include <cstring>
#include <nvml.h>
#include <string>

#include "nvml_injection_structs.h"

// The following snippet is generated from write_injection_argument_header
class InjectionArgument
{
private:
    injectionArgType_t m_type;
    simpleValue_t m_value;
    std::string m_str;

    bool m_isArray = false;

    unsigned m_arrLen = 0;

    bool m_inHeap = false;

    // The following snippet is generated from write_injection_argument_deep_copy_function
    // Some type of holding member live in heap. Do deep copy so that our destructor can work well.
    void DeepCopy(const InjectionArgument &other)
    {
        m_type = other.m_type;
        m_value = other.m_value;
        m_str = other.m_str;
        m_isArray = other.m_isArray;
        m_arrLen = other.m_arrLen;
        m_inHeap = other.m_inHeap;
        if (!m_inHeap)
        {
            return;
        }
        switch (m_type)
        {
            case INJECTION_CHAR_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.Str = static_cast<char *>(malloc(allocateNum * sizeof(*other.m_value.Str)));
                if (m_value.Str != nullptr)
                {
                    std::memcpy(m_value.Str, other.m_value.Str, allocateNum * sizeof(*other.m_value.Str));
                }
                break;
            }
            case INJECTION_DOUBLE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DoublePtr = static_cast<double *>(malloc(allocateNum * sizeof(*other.m_value.DoublePtr)));
                if (m_value.DoublePtr != nullptr)
                {
                    std::memcpy(m_value.DoublePtr, other.m_value.DoublePtr, allocateNum * sizeof(*other.m_value.DoublePtr));
                }
                break;
            }
            case INJECTION_INT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.IntPtr = static_cast<int *>(malloc(allocateNum * sizeof(*other.m_value.IntPtr)));
                if (m_value.IntPtr != nullptr)
                {
                    std::memcpy(m_value.IntPtr, other.m_value.IntPtr, allocateNum * sizeof(*other.m_value.IntPtr));
                }
                break;
            }
            case INJECTION_LONG_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.LongPtr = static_cast<long *>(malloc(allocateNum * sizeof(*other.m_value.LongPtr)));
                if (m_value.LongPtr != nullptr)
                {
                    std::memcpy(m_value.LongPtr, other.m_value.LongPtr, allocateNum * sizeof(*other.m_value.LongPtr));
                }
                break;
            }
            case INJECTION_LONG_LONG_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.LongLongPtr = static_cast<long long *>(malloc(allocateNum * sizeof(*other.m_value.LongLongPtr)));
                if (m_value.LongLongPtr != nullptr)
                {
                    std::memcpy(m_value.LongLongPtr, other.m_value.LongLongPtr, allocateNum * sizeof(*other.m_value.LongLongPtr));
                }
                break;
            }
            case INJECTION_ACCOUNTINGSTATS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.AccountingStatsPtr = static_cast<nvmlAccountingStats_t *>(malloc(allocateNum * sizeof(*other.m_value.AccountingStatsPtr)));
                if (m_value.AccountingStatsPtr != nullptr)
                {
                    std::memcpy(m_value.AccountingStatsPtr, other.m_value.AccountingStatsPtr, allocateNum * sizeof(*other.m_value.AccountingStatsPtr));
                }
                break;
            }
            case INJECTION_AFFINITYSCOPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.AffinityScopePtr = static_cast<nvmlAffinityScope_t *>(malloc(allocateNum * sizeof(*other.m_value.AffinityScopePtr)));
                if (m_value.AffinityScopePtr != nullptr)
                {
                    std::memcpy(m_value.AffinityScopePtr, other.m_value.AffinityScopePtr, allocateNum * sizeof(*other.m_value.AffinityScopePtr));
                }
                break;
            }
            case INJECTION_BAR1MEMORY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.BAR1MemoryPtr = static_cast<nvmlBAR1Memory_t *>(malloc(allocateNum * sizeof(*other.m_value.BAR1MemoryPtr)));
                if (m_value.BAR1MemoryPtr != nullptr)
                {
                    std::memcpy(m_value.BAR1MemoryPtr, other.m_value.BAR1MemoryPtr, allocateNum * sizeof(*other.m_value.BAR1MemoryPtr));
                }
                break;
            }
            case INJECTION_BRANDTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.BrandTypePtr = static_cast<nvmlBrandType_t *>(malloc(allocateNum * sizeof(*other.m_value.BrandTypePtr)));
                if (m_value.BrandTypePtr != nullptr)
                {
                    std::memcpy(m_value.BrandTypePtr, other.m_value.BrandTypePtr, allocateNum * sizeof(*other.m_value.BrandTypePtr));
                }
                break;
            }
            case INJECTION_BRIDGECHIPHIERARCHY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.BridgeChipHierarchyPtr = static_cast<nvmlBridgeChipHierarchy_t *>(malloc(allocateNum * sizeof(*other.m_value.BridgeChipHierarchyPtr)));
                if (m_value.BridgeChipHierarchyPtr != nullptr)
                {
                    std::memcpy(m_value.BridgeChipHierarchyPtr, other.m_value.BridgeChipHierarchyPtr, allocateNum * sizeof(*other.m_value.BridgeChipHierarchyPtr));
                }
                break;
            }
            case INJECTION_BRIDGECHIPINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.BridgeChipInfoPtr = static_cast<nvmlBridgeChipInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.BridgeChipInfoPtr)));
                if (m_value.BridgeChipInfoPtr != nullptr)
                {
                    std::memcpy(m_value.BridgeChipInfoPtr, other.m_value.BridgeChipInfoPtr, allocateNum * sizeof(*other.m_value.BridgeChipInfoPtr));
                }
                break;
            }
            case INJECTION_BRIDGECHIPTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.BridgeChipTypePtr = static_cast<nvmlBridgeChipType_t *>(malloc(allocateNum * sizeof(*other.m_value.BridgeChipTypePtr)));
                if (m_value.BridgeChipTypePtr != nullptr)
                {
                    std::memcpy(m_value.BridgeChipTypePtr, other.m_value.BridgeChipTypePtr, allocateNum * sizeof(*other.m_value.BridgeChipTypePtr));
                }
                break;
            }
            case INJECTION_BUSTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.BusTypePtr = static_cast<nvmlBusType_t *>(malloc(allocateNum * sizeof(*other.m_value.BusTypePtr)));
                if (m_value.BusTypePtr != nullptr)
                {
                    std::memcpy(m_value.BusTypePtr, other.m_value.BusTypePtr, allocateNum * sizeof(*other.m_value.BusTypePtr));
                }
                break;
            }
            case INJECTION_C2CMODEINFO_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.C2cModeInfo_v1Ptr = static_cast<nvmlC2cModeInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.C2cModeInfo_v1Ptr)));
                if (m_value.C2cModeInfo_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.C2cModeInfo_v1Ptr, other.m_value.C2cModeInfo_v1Ptr, allocateNum * sizeof(*other.m_value.C2cModeInfo_v1Ptr));
                }
                break;
            }
            case INJECTION_CLKMONFAULTINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ClkMonFaultInfoPtr = static_cast<nvmlClkMonFaultInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.ClkMonFaultInfoPtr)));
                if (m_value.ClkMonFaultInfoPtr != nullptr)
                {
                    std::memcpy(m_value.ClkMonFaultInfoPtr, other.m_value.ClkMonFaultInfoPtr, allocateNum * sizeof(*other.m_value.ClkMonFaultInfoPtr));
                }
                break;
            }
            case INJECTION_CLKMONSTATUS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ClkMonStatusPtr = static_cast<nvmlClkMonStatus_t *>(malloc(allocateNum * sizeof(*other.m_value.ClkMonStatusPtr)));
                if (m_value.ClkMonStatusPtr != nullptr)
                {
                    std::memcpy(m_value.ClkMonStatusPtr, other.m_value.ClkMonStatusPtr, allocateNum * sizeof(*other.m_value.ClkMonStatusPtr));
                }
                break;
            }
            case INJECTION_CLOCKID_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ClockIdPtr = static_cast<nvmlClockId_t *>(malloc(allocateNum * sizeof(*other.m_value.ClockIdPtr)));
                if (m_value.ClockIdPtr != nullptr)
                {
                    std::memcpy(m_value.ClockIdPtr, other.m_value.ClockIdPtr, allocateNum * sizeof(*other.m_value.ClockIdPtr));
                }
                break;
            }
            case INJECTION_CLOCKLIMITID_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ClockLimitIdPtr = static_cast<nvmlClockLimitId_t *>(malloc(allocateNum * sizeof(*other.m_value.ClockLimitIdPtr)));
                if (m_value.ClockLimitIdPtr != nullptr)
                {
                    std::memcpy(m_value.ClockLimitIdPtr, other.m_value.ClockLimitIdPtr, allocateNum * sizeof(*other.m_value.ClockLimitIdPtr));
                }
                break;
            }
            case INJECTION_CLOCKOFFSET_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ClockOffsetPtr = static_cast<nvmlClockOffset_t *>(malloc(allocateNum * sizeof(*other.m_value.ClockOffsetPtr)));
                if (m_value.ClockOffsetPtr != nullptr)
                {
                    std::memcpy(m_value.ClockOffsetPtr, other.m_value.ClockOffsetPtr, allocateNum * sizeof(*other.m_value.ClockOffsetPtr));
                }
                break;
            }
            case INJECTION_CLOCKTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ClockTypePtr = static_cast<nvmlClockType_t *>(malloc(allocateNum * sizeof(*other.m_value.ClockTypePtr)));
                if (m_value.ClockTypePtr != nullptr)
                {
                    std::memcpy(m_value.ClockTypePtr, other.m_value.ClockTypePtr, allocateNum * sizeof(*other.m_value.ClockTypePtr));
                }
                break;
            }
            case INJECTION_COMPUTEINSTANCEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ComputeInstanceInfoPtr = static_cast<nvmlComputeInstanceInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.ComputeInstanceInfoPtr)));
                if (m_value.ComputeInstanceInfoPtr != nullptr)
                {
                    std::memcpy(m_value.ComputeInstanceInfoPtr, other.m_value.ComputeInstanceInfoPtr, allocateNum * sizeof(*other.m_value.ComputeInstanceInfoPtr));
                }
                break;
            }
            case INJECTION_COMPUTEINSTANCEPLACEMENT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ComputeInstancePlacementPtr = static_cast<nvmlComputeInstancePlacement_t *>(malloc(allocateNum * sizeof(*other.m_value.ComputeInstancePlacementPtr)));
                if (m_value.ComputeInstancePlacementPtr != nullptr)
                {
                    std::memcpy(m_value.ComputeInstancePlacementPtr, other.m_value.ComputeInstancePlacementPtr, allocateNum * sizeof(*other.m_value.ComputeInstancePlacementPtr));
                }
                break;
            }
            case INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ComputeInstanceProfileInfoPtr = static_cast<nvmlComputeInstanceProfileInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.ComputeInstanceProfileInfoPtr)));
                if (m_value.ComputeInstanceProfileInfoPtr != nullptr)
                {
                    std::memcpy(m_value.ComputeInstanceProfileInfoPtr, other.m_value.ComputeInstanceProfileInfoPtr, allocateNum * sizeof(*other.m_value.ComputeInstanceProfileInfoPtr));
                }
                break;
            }
            case INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ComputeInstanceProfileInfo_v2Ptr = static_cast<nvmlComputeInstanceProfileInfo_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.ComputeInstanceProfileInfo_v2Ptr)));
                if (m_value.ComputeInstanceProfileInfo_v2Ptr != nullptr)
                {
                    std::memcpy(m_value.ComputeInstanceProfileInfo_v2Ptr, other.m_value.ComputeInstanceProfileInfo_v2Ptr, allocateNum * sizeof(*other.m_value.ComputeInstanceProfileInfo_v2Ptr));
                }
                break;
            }
            case INJECTION_COMPUTEINSTANCEPROFILEINFO_V3_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ComputeInstanceProfileInfo_v3Ptr = static_cast<nvmlComputeInstanceProfileInfo_v3_t *>(malloc(allocateNum * sizeof(*other.m_value.ComputeInstanceProfileInfo_v3Ptr)));
                if (m_value.ComputeInstanceProfileInfo_v3Ptr != nullptr)
                {
                    std::memcpy(m_value.ComputeInstanceProfileInfo_v3Ptr, other.m_value.ComputeInstanceProfileInfo_v3Ptr, allocateNum * sizeof(*other.m_value.ComputeInstanceProfileInfo_v3Ptr));
                }
                break;
            }
            case INJECTION_COMPUTEINSTANCE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ComputeInstancePtr = static_cast<nvmlComputeInstance_t *>(malloc(allocateNum * sizeof(*other.m_value.ComputeInstancePtr)));
                if (m_value.ComputeInstancePtr != nullptr)
                {
                    std::memcpy(m_value.ComputeInstancePtr, other.m_value.ComputeInstancePtr, allocateNum * sizeof(*other.m_value.ComputeInstancePtr));
                }
                break;
            }
            case INJECTION_COMPUTEMODE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ComputeModePtr = static_cast<nvmlComputeMode_t *>(malloc(allocateNum * sizeof(*other.m_value.ComputeModePtr)));
                if (m_value.ComputeModePtr != nullptr)
                {
                    std::memcpy(m_value.ComputeModePtr, other.m_value.ComputeModePtr, allocateNum * sizeof(*other.m_value.ComputeModePtr));
                }
                break;
            }
            case INJECTION_CONFCOMPUTEGETKEYROTATIONTHRESHOLDINFO_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr = static_cast<nvmlConfComputeGetKeyRotationThresholdInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr)));
                if (m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr, other.m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr, allocateNum * sizeof(*other.m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr));
                }
                break;
            }
            case INJECTION_CONFCOMPUTEGPUATTESTATIONREPORT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ConfComputeGpuAttestationReportPtr = static_cast<nvmlConfComputeGpuAttestationReport_t *>(malloc(allocateNum * sizeof(*other.m_value.ConfComputeGpuAttestationReportPtr)));
                if (m_value.ConfComputeGpuAttestationReportPtr != nullptr)
                {
                    std::memcpy(m_value.ConfComputeGpuAttestationReportPtr, other.m_value.ConfComputeGpuAttestationReportPtr, allocateNum * sizeof(*other.m_value.ConfComputeGpuAttestationReportPtr));
                }
                break;
            }
            case INJECTION_CONFCOMPUTEGPUCERTIFICATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ConfComputeGpuCertificatePtr = static_cast<nvmlConfComputeGpuCertificate_t *>(malloc(allocateNum * sizeof(*other.m_value.ConfComputeGpuCertificatePtr)));
                if (m_value.ConfComputeGpuCertificatePtr != nullptr)
                {
                    std::memcpy(m_value.ConfComputeGpuCertificatePtr, other.m_value.ConfComputeGpuCertificatePtr, allocateNum * sizeof(*other.m_value.ConfComputeGpuCertificatePtr));
                }
                break;
            }
            case INJECTION_CONFCOMPUTEMEMSIZEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ConfComputeMemSizeInfoPtr = static_cast<nvmlConfComputeMemSizeInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.ConfComputeMemSizeInfoPtr)));
                if (m_value.ConfComputeMemSizeInfoPtr != nullptr)
                {
                    std::memcpy(m_value.ConfComputeMemSizeInfoPtr, other.m_value.ConfComputeMemSizeInfoPtr, allocateNum * sizeof(*other.m_value.ConfComputeMemSizeInfoPtr));
                }
                break;
            }
            case INJECTION_CONFCOMPUTESETKEYROTATIONTHRESHOLDINFO_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr = static_cast<nvmlConfComputeSetKeyRotationThresholdInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr)));
                if (m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr, other.m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr, allocateNum * sizeof(*other.m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr));
                }
                break;
            }
            case INJECTION_CONFCOMPUTESYSTEMCAPS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ConfComputeSystemCapsPtr = static_cast<nvmlConfComputeSystemCaps_t *>(malloc(allocateNum * sizeof(*other.m_value.ConfComputeSystemCapsPtr)));
                if (m_value.ConfComputeSystemCapsPtr != nullptr)
                {
                    std::memcpy(m_value.ConfComputeSystemCapsPtr, other.m_value.ConfComputeSystemCapsPtr, allocateNum * sizeof(*other.m_value.ConfComputeSystemCapsPtr));
                }
                break;
            }
            case INJECTION_CONFCOMPUTESYSTEMSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ConfComputeSystemStatePtr = static_cast<nvmlConfComputeSystemState_t *>(malloc(allocateNum * sizeof(*other.m_value.ConfComputeSystemStatePtr)));
                if (m_value.ConfComputeSystemStatePtr != nullptr)
                {
                    std::memcpy(m_value.ConfComputeSystemStatePtr, other.m_value.ConfComputeSystemStatePtr, allocateNum * sizeof(*other.m_value.ConfComputeSystemStatePtr));
                }
                break;
            }
            case INJECTION_COOLERCONTROL_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.CoolerControlPtr = static_cast<nvmlCoolerControl_t *>(malloc(allocateNum * sizeof(*other.m_value.CoolerControlPtr)));
                if (m_value.CoolerControlPtr != nullptr)
                {
                    std::memcpy(m_value.CoolerControlPtr, other.m_value.CoolerControlPtr, allocateNum * sizeof(*other.m_value.CoolerControlPtr));
                }
                break;
            }
            case INJECTION_COOLERINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.CoolerInfoPtr = static_cast<nvmlCoolerInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.CoolerInfoPtr)));
                if (m_value.CoolerInfoPtr != nullptr)
                {
                    std::memcpy(m_value.CoolerInfoPtr, other.m_value.CoolerInfoPtr, allocateNum * sizeof(*other.m_value.CoolerInfoPtr));
                }
                break;
            }
            case INJECTION_COOLERTARGET_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.CoolerTargetPtr = static_cast<nvmlCoolerTarget_t *>(malloc(allocateNum * sizeof(*other.m_value.CoolerTargetPtr)));
                if (m_value.CoolerTargetPtr != nullptr)
                {
                    std::memcpy(m_value.CoolerTargetPtr, other.m_value.CoolerTargetPtr, allocateNum * sizeof(*other.m_value.CoolerTargetPtr));
                }
                break;
            }
            case INJECTION_DETACHGPUSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DetachGpuStatePtr = static_cast<nvmlDetachGpuState_t *>(malloc(allocateNum * sizeof(*other.m_value.DetachGpuStatePtr)));
                if (m_value.DetachGpuStatePtr != nullptr)
                {
                    std::memcpy(m_value.DetachGpuStatePtr, other.m_value.DetachGpuStatePtr, allocateNum * sizeof(*other.m_value.DetachGpuStatePtr));
                }
                break;
            }
            case INJECTION_DEVICEARCHITECTURE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DeviceArchitecturePtr = static_cast<nvmlDeviceArchitecture_t *>(malloc(allocateNum * sizeof(*other.m_value.DeviceArchitecturePtr)));
                if (m_value.DeviceArchitecturePtr != nullptr)
                {
                    std::memcpy(m_value.DeviceArchitecturePtr, other.m_value.DeviceArchitecturePtr, allocateNum * sizeof(*other.m_value.DeviceArchitecturePtr));
                }
                break;
            }
            case INJECTION_DEVICEATTRIBUTES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DeviceAttributesPtr = static_cast<nvmlDeviceAttributes_t *>(malloc(allocateNum * sizeof(*other.m_value.DeviceAttributesPtr)));
                if (m_value.DeviceAttributesPtr != nullptr)
                {
                    std::memcpy(m_value.DeviceAttributesPtr, other.m_value.DeviceAttributesPtr, allocateNum * sizeof(*other.m_value.DeviceAttributesPtr));
                }
                break;
            }
            case INJECTION_DEVICECAPABILITIES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DeviceCapabilitiesPtr = static_cast<nvmlDeviceCapabilities_t *>(malloc(allocateNum * sizeof(*other.m_value.DeviceCapabilitiesPtr)));
                if (m_value.DeviceCapabilitiesPtr != nullptr)
                {
                    std::memcpy(m_value.DeviceCapabilitiesPtr, other.m_value.DeviceCapabilitiesPtr, allocateNum * sizeof(*other.m_value.DeviceCapabilitiesPtr));
                }
                break;
            }
            case INJECTION_DEVICECURRENTCLOCKFREQS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DeviceCurrentClockFreqsPtr = static_cast<nvmlDeviceCurrentClockFreqs_t *>(malloc(allocateNum * sizeof(*other.m_value.DeviceCurrentClockFreqsPtr)));
                if (m_value.DeviceCurrentClockFreqsPtr != nullptr)
                {
                    std::memcpy(m_value.DeviceCurrentClockFreqsPtr, other.m_value.DeviceCurrentClockFreqsPtr, allocateNum * sizeof(*other.m_value.DeviceCurrentClockFreqsPtr));
                }
                break;
            }
            case INJECTION_DEVICEGPURECOVERYACTION_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DeviceGpuRecoveryActionPtr = static_cast<nvmlDeviceGpuRecoveryAction_t *>(malloc(allocateNum * sizeof(*other.m_value.DeviceGpuRecoveryActionPtr)));
                if (m_value.DeviceGpuRecoveryActionPtr != nullptr)
                {
                    std::memcpy(m_value.DeviceGpuRecoveryActionPtr, other.m_value.DeviceGpuRecoveryActionPtr, allocateNum * sizeof(*other.m_value.DeviceGpuRecoveryActionPtr));
                }
                break;
            }
            case INJECTION_DEVICEPERFMODES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DevicePerfModesPtr = static_cast<nvmlDevicePerfModes_t *>(malloc(allocateNum * sizeof(*other.m_value.DevicePerfModesPtr)));
                if (m_value.DevicePerfModesPtr != nullptr)
                {
                    std::memcpy(m_value.DevicePerfModesPtr, other.m_value.DevicePerfModesPtr, allocateNum * sizeof(*other.m_value.DevicePerfModesPtr));
                }
                break;
            }
            case INJECTION_DEVICEVGPUCAPABILITY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DeviceVgpuCapabilityPtr = static_cast<nvmlDeviceVgpuCapability_t *>(malloc(allocateNum * sizeof(*other.m_value.DeviceVgpuCapabilityPtr)));
                if (m_value.DeviceVgpuCapabilityPtr != nullptr)
                {
                    std::memcpy(m_value.DeviceVgpuCapabilityPtr, other.m_value.DeviceVgpuCapabilityPtr, allocateNum * sizeof(*other.m_value.DeviceVgpuCapabilityPtr));
                }
                break;
            }
            case INJECTION_DEVICE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DevicePtr = static_cast<nvmlDevice_t *>(malloc(allocateNum * sizeof(*other.m_value.DevicePtr)));
                if (m_value.DevicePtr != nullptr)
                {
                    std::memcpy(m_value.DevicePtr, other.m_value.DevicePtr, allocateNum * sizeof(*other.m_value.DevicePtr));
                }
                break;
            }
            case INJECTION_DRIVERMODEL_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.DriverModelPtr = static_cast<nvmlDriverModel_t *>(malloc(allocateNum * sizeof(*other.m_value.DriverModelPtr)));
                if (m_value.DriverModelPtr != nullptr)
                {
                    std::memcpy(m_value.DriverModelPtr, other.m_value.DriverModelPtr, allocateNum * sizeof(*other.m_value.DriverModelPtr));
                }
                break;
            }
            case INJECTION_ECCCOUNTERTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EccCounterTypePtr = static_cast<nvmlEccCounterType_t *>(malloc(allocateNum * sizeof(*other.m_value.EccCounterTypePtr)));
                if (m_value.EccCounterTypePtr != nullptr)
                {
                    std::memcpy(m_value.EccCounterTypePtr, other.m_value.EccCounterTypePtr, allocateNum * sizeof(*other.m_value.EccCounterTypePtr));
                }
                break;
            }
            case INJECTION_ECCERRORCOUNTS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EccErrorCountsPtr = static_cast<nvmlEccErrorCounts_t *>(malloc(allocateNum * sizeof(*other.m_value.EccErrorCountsPtr)));
                if (m_value.EccErrorCountsPtr != nullptr)
                {
                    std::memcpy(m_value.EccErrorCountsPtr, other.m_value.EccErrorCountsPtr, allocateNum * sizeof(*other.m_value.EccErrorCountsPtr));
                }
                break;
            }
            case INJECTION_ECCSRAMERRORSTATUS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EccSramErrorStatusPtr = static_cast<nvmlEccSramErrorStatus_t *>(malloc(allocateNum * sizeof(*other.m_value.EccSramErrorStatusPtr)));
                if (m_value.EccSramErrorStatusPtr != nullptr)
                {
                    std::memcpy(m_value.EccSramErrorStatusPtr, other.m_value.EccSramErrorStatusPtr, allocateNum * sizeof(*other.m_value.EccSramErrorStatusPtr));
                }
                break;
            }
            case INJECTION_ENABLESTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EnableStatePtr = static_cast<nvmlEnableState_t *>(malloc(allocateNum * sizeof(*other.m_value.EnableStatePtr)));
                if (m_value.EnableStatePtr != nullptr)
                {
                    std::memcpy(m_value.EnableStatePtr, other.m_value.EnableStatePtr, allocateNum * sizeof(*other.m_value.EnableStatePtr));
                }
                break;
            }
            case INJECTION_ENCODERSESSIONINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EncoderSessionInfoPtr = static_cast<nvmlEncoderSessionInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.EncoderSessionInfoPtr)));
                if (m_value.EncoderSessionInfoPtr != nullptr)
                {
                    std::memcpy(m_value.EncoderSessionInfoPtr, other.m_value.EncoderSessionInfoPtr, allocateNum * sizeof(*other.m_value.EncoderSessionInfoPtr));
                }
                break;
            }
            case INJECTION_ENCODERTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EncoderTypePtr = static_cast<nvmlEncoderType_t *>(malloc(allocateNum * sizeof(*other.m_value.EncoderTypePtr)));
                if (m_value.EncoderTypePtr != nullptr)
                {
                    std::memcpy(m_value.EncoderTypePtr, other.m_value.EncoderTypePtr, allocateNum * sizeof(*other.m_value.EncoderTypePtr));
                }
                break;
            }
            case INJECTION_EVENTDATA_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EventDataPtr = static_cast<nvmlEventData_t *>(malloc(allocateNum * sizeof(*other.m_value.EventDataPtr)));
                if (m_value.EventDataPtr != nullptr)
                {
                    std::memcpy(m_value.EventDataPtr, other.m_value.EventDataPtr, allocateNum * sizeof(*other.m_value.EventDataPtr));
                }
                break;
            }
            case INJECTION_EVENTSET_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.EventSetPtr = static_cast<nvmlEventSet_t *>(malloc(allocateNum * sizeof(*other.m_value.EventSetPtr)));
                if (m_value.EventSetPtr != nullptr)
                {
                    std::memcpy(m_value.EventSetPtr, other.m_value.EventSetPtr, allocateNum * sizeof(*other.m_value.EventSetPtr));
                }
                break;
            }
            case INJECTION_EXCLUDEDDEVICEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ExcludedDeviceInfoPtr = static_cast<nvmlExcludedDeviceInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.ExcludedDeviceInfoPtr)));
                if (m_value.ExcludedDeviceInfoPtr != nullptr)
                {
                    std::memcpy(m_value.ExcludedDeviceInfoPtr, other.m_value.ExcludedDeviceInfoPtr, allocateNum * sizeof(*other.m_value.ExcludedDeviceInfoPtr));
                }
                break;
            }
            case INJECTION_FBCSESSIONINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.FBCSessionInfoPtr = static_cast<nvmlFBCSessionInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.FBCSessionInfoPtr)));
                if (m_value.FBCSessionInfoPtr != nullptr)
                {
                    std::memcpy(m_value.FBCSessionInfoPtr, other.m_value.FBCSessionInfoPtr, allocateNum * sizeof(*other.m_value.FBCSessionInfoPtr));
                }
                break;
            }
            case INJECTION_FBCSESSIONTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.FBCSessionTypePtr = static_cast<nvmlFBCSessionType_t *>(malloc(allocateNum * sizeof(*other.m_value.FBCSessionTypePtr)));
                if (m_value.FBCSessionTypePtr != nullptr)
                {
                    std::memcpy(m_value.FBCSessionTypePtr, other.m_value.FBCSessionTypePtr, allocateNum * sizeof(*other.m_value.FBCSessionTypePtr));
                }
                break;
            }
            case INJECTION_FBCSTATS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.FBCStatsPtr = static_cast<nvmlFBCStats_t *>(malloc(allocateNum * sizeof(*other.m_value.FBCStatsPtr)));
                if (m_value.FBCStatsPtr != nullptr)
                {
                    std::memcpy(m_value.FBCStatsPtr, other.m_value.FBCStatsPtr, allocateNum * sizeof(*other.m_value.FBCStatsPtr));
                }
                break;
            }
            case INJECTION_FANCONTROLPOLICY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.FanControlPolicyPtr = static_cast<nvmlFanControlPolicy_t *>(malloc(allocateNum * sizeof(*other.m_value.FanControlPolicyPtr)));
                if (m_value.FanControlPolicyPtr != nullptr)
                {
                    std::memcpy(m_value.FanControlPolicyPtr, other.m_value.FanControlPolicyPtr, allocateNum * sizeof(*other.m_value.FanControlPolicyPtr));
                }
                break;
            }
            case INJECTION_FANSPEEDINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.FanSpeedInfoPtr = static_cast<nvmlFanSpeedInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.FanSpeedInfoPtr)));
                if (m_value.FanSpeedInfoPtr != nullptr)
                {
                    std::memcpy(m_value.FanSpeedInfoPtr, other.m_value.FanSpeedInfoPtr, allocateNum * sizeof(*other.m_value.FanSpeedInfoPtr));
                }
                break;
            }
            case INJECTION_FANSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.FanStatePtr = static_cast<nvmlFanState_t *>(malloc(allocateNum * sizeof(*other.m_value.FanStatePtr)));
                if (m_value.FanStatePtr != nullptr)
                {
                    std::memcpy(m_value.FanStatePtr, other.m_value.FanStatePtr, allocateNum * sizeof(*other.m_value.FanStatePtr));
                }
                break;
            }
            case INJECTION_FIELDVALUE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.FieldValuePtr = static_cast<nvmlFieldValue_t *>(malloc(allocateNum * sizeof(*other.m_value.FieldValuePtr)));
                if (m_value.FieldValuePtr != nullptr)
                {
                    std::memcpy(m_value.FieldValuePtr, other.m_value.FieldValuePtr, allocateNum * sizeof(*other.m_value.FieldValuePtr));
                }
                break;
            }
            case INJECTION_GPMMETRICID_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpmMetricIdPtr = static_cast<nvmlGpmMetricId_t *>(malloc(allocateNum * sizeof(*other.m_value.GpmMetricIdPtr)));
                if (m_value.GpmMetricIdPtr != nullptr)
                {
                    std::memcpy(m_value.GpmMetricIdPtr, other.m_value.GpmMetricIdPtr, allocateNum * sizeof(*other.m_value.GpmMetricIdPtr));
                }
                break;
            }
            case INJECTION_GPMMETRIC_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpmMetricPtr = static_cast<nvmlGpmMetric_t *>(malloc(allocateNum * sizeof(*other.m_value.GpmMetricPtr)));
                if (m_value.GpmMetricPtr != nullptr)
                {
                    std::memcpy(m_value.GpmMetricPtr, other.m_value.GpmMetricPtr, allocateNum * sizeof(*other.m_value.GpmMetricPtr));
                }
                break;
            }
            case INJECTION_GPMMETRICSGET_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpmMetricsGetPtr = static_cast<nvmlGpmMetricsGet_t *>(malloc(allocateNum * sizeof(*other.m_value.GpmMetricsGetPtr)));
                if (m_value.GpmMetricsGetPtr != nullptr)
                {
                    std::memcpy(m_value.GpmMetricsGetPtr, other.m_value.GpmMetricsGetPtr, allocateNum * sizeof(*other.m_value.GpmMetricsGetPtr));
                }
                break;
            }
            case INJECTION_GPMSAMPLE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpmSamplePtr = static_cast<nvmlGpmSample_t *>(malloc(allocateNum * sizeof(*other.m_value.GpmSamplePtr)));
                if (m_value.GpmSamplePtr != nullptr)
                {
                    std::memcpy(m_value.GpmSamplePtr, other.m_value.GpmSamplePtr, allocateNum * sizeof(*other.m_value.GpmSamplePtr));
                }
                break;
            }
            case INJECTION_GPMSUPPORT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpmSupportPtr = static_cast<nvmlGpmSupport_t *>(malloc(allocateNum * sizeof(*other.m_value.GpmSupportPtr)));
                if (m_value.GpmSupportPtr != nullptr)
                {
                    std::memcpy(m_value.GpmSupportPtr, other.m_value.GpmSupportPtr, allocateNum * sizeof(*other.m_value.GpmSupportPtr));
                }
                break;
            }
            case INJECTION_GPUDYNAMICPSTATESINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuDynamicPstatesInfoPtr = static_cast<nvmlGpuDynamicPstatesInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuDynamicPstatesInfoPtr)));
                if (m_value.GpuDynamicPstatesInfoPtr != nullptr)
                {
                    std::memcpy(m_value.GpuDynamicPstatesInfoPtr, other.m_value.GpuDynamicPstatesInfoPtr, allocateNum * sizeof(*other.m_value.GpuDynamicPstatesInfoPtr));
                }
                break;
            }
            case INJECTION_GPUFABRICINFOV_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuFabricInfoVPtr = static_cast<nvmlGpuFabricInfoV_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuFabricInfoVPtr)));
                if (m_value.GpuFabricInfoVPtr != nullptr)
                {
                    std::memcpy(m_value.GpuFabricInfoVPtr, other.m_value.GpuFabricInfoVPtr, allocateNum * sizeof(*other.m_value.GpuFabricInfoVPtr));
                }
                break;
            }
            case INJECTION_GPUFABRICINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuFabricInfoPtr = static_cast<nvmlGpuFabricInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuFabricInfoPtr)));
                if (m_value.GpuFabricInfoPtr != nullptr)
                {
                    std::memcpy(m_value.GpuFabricInfoPtr, other.m_value.GpuFabricInfoPtr, allocateNum * sizeof(*other.m_value.GpuFabricInfoPtr));
                }
                break;
            }
            case INJECTION_GPUFABRICSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuFabricStatePtr = static_cast<nvmlGpuFabricState_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuFabricStatePtr)));
                if (m_value.GpuFabricStatePtr != nullptr)
                {
                    std::memcpy(m_value.GpuFabricStatePtr, other.m_value.GpuFabricStatePtr, allocateNum * sizeof(*other.m_value.GpuFabricStatePtr));
                }
                break;
            }
            case INJECTION_GPUINSTANCEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuInstanceInfoPtr = static_cast<nvmlGpuInstanceInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuInstanceInfoPtr)));
                if (m_value.GpuInstanceInfoPtr != nullptr)
                {
                    std::memcpy(m_value.GpuInstanceInfoPtr, other.m_value.GpuInstanceInfoPtr, allocateNum * sizeof(*other.m_value.GpuInstanceInfoPtr));
                }
                break;
            }
            case INJECTION_GPUINSTANCEPLACEMENT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuInstancePlacementPtr = static_cast<nvmlGpuInstancePlacement_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuInstancePlacementPtr)));
                if (m_value.GpuInstancePlacementPtr != nullptr)
                {
                    std::memcpy(m_value.GpuInstancePlacementPtr, other.m_value.GpuInstancePlacementPtr, allocateNum * sizeof(*other.m_value.GpuInstancePlacementPtr));
                }
                break;
            }
            case INJECTION_GPUINSTANCEPROFILEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuInstanceProfileInfoPtr = static_cast<nvmlGpuInstanceProfileInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuInstanceProfileInfoPtr)));
                if (m_value.GpuInstanceProfileInfoPtr != nullptr)
                {
                    std::memcpy(m_value.GpuInstanceProfileInfoPtr, other.m_value.GpuInstanceProfileInfoPtr, allocateNum * sizeof(*other.m_value.GpuInstanceProfileInfoPtr));
                }
                break;
            }
            case INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuInstanceProfileInfo_v2Ptr = static_cast<nvmlGpuInstanceProfileInfo_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuInstanceProfileInfo_v2Ptr)));
                if (m_value.GpuInstanceProfileInfo_v2Ptr != nullptr)
                {
                    std::memcpy(m_value.GpuInstanceProfileInfo_v2Ptr, other.m_value.GpuInstanceProfileInfo_v2Ptr, allocateNum * sizeof(*other.m_value.GpuInstanceProfileInfo_v2Ptr));
                }
                break;
            }
            case INJECTION_GPUINSTANCEPROFILEINFO_V3_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuInstanceProfileInfo_v3Ptr = static_cast<nvmlGpuInstanceProfileInfo_v3_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuInstanceProfileInfo_v3Ptr)));
                if (m_value.GpuInstanceProfileInfo_v3Ptr != nullptr)
                {
                    std::memcpy(m_value.GpuInstanceProfileInfo_v3Ptr, other.m_value.GpuInstanceProfileInfo_v3Ptr, allocateNum * sizeof(*other.m_value.GpuInstanceProfileInfo_v3Ptr));
                }
                break;
            }
            case INJECTION_GPUINSTANCE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuInstancePtr = static_cast<nvmlGpuInstance_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuInstancePtr)));
                if (m_value.GpuInstancePtr != nullptr)
                {
                    std::memcpy(m_value.GpuInstancePtr, other.m_value.GpuInstancePtr, allocateNum * sizeof(*other.m_value.GpuInstancePtr));
                }
                break;
            }
            case INJECTION_GPUOPERATIONMODE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuOperationModePtr = static_cast<nvmlGpuOperationMode_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuOperationModePtr)));
                if (m_value.GpuOperationModePtr != nullptr)
                {
                    std::memcpy(m_value.GpuOperationModePtr, other.m_value.GpuOperationModePtr, allocateNum * sizeof(*other.m_value.GpuOperationModePtr));
                }
                break;
            }
            case INJECTION_GPUP2PCAPSINDEX_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuP2PCapsIndexPtr = static_cast<nvmlGpuP2PCapsIndex_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuP2PCapsIndexPtr)));
                if (m_value.GpuP2PCapsIndexPtr != nullptr)
                {
                    std::memcpy(m_value.GpuP2PCapsIndexPtr, other.m_value.GpuP2PCapsIndexPtr, allocateNum * sizeof(*other.m_value.GpuP2PCapsIndexPtr));
                }
                break;
            }
            case INJECTION_GPUP2PSTATUS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuP2PStatusPtr = static_cast<nvmlGpuP2PStatus_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuP2PStatusPtr)));
                if (m_value.GpuP2PStatusPtr != nullptr)
                {
                    std::memcpy(m_value.GpuP2PStatusPtr, other.m_value.GpuP2PStatusPtr, allocateNum * sizeof(*other.m_value.GpuP2PStatusPtr));
                }
                break;
            }
            case INJECTION_GPUTHERMALSETTINGS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuThermalSettingsPtr = static_cast<nvmlGpuThermalSettings_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuThermalSettingsPtr)));
                if (m_value.GpuThermalSettingsPtr != nullptr)
                {
                    std::memcpy(m_value.GpuThermalSettingsPtr, other.m_value.GpuThermalSettingsPtr, allocateNum * sizeof(*other.m_value.GpuThermalSettingsPtr));
                }
                break;
            }
            case INJECTION_GPUTOPOLOGYLEVEL_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuTopologyLevelPtr = static_cast<nvmlGpuTopologyLevel_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuTopologyLevelPtr)));
                if (m_value.GpuTopologyLevelPtr != nullptr)
                {
                    std::memcpy(m_value.GpuTopologyLevelPtr, other.m_value.GpuTopologyLevelPtr, allocateNum * sizeof(*other.m_value.GpuTopologyLevelPtr));
                }
                break;
            }
            case INJECTION_GPUUTILIZATIONDOMAINID_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuUtilizationDomainIdPtr = static_cast<nvmlGpuUtilizationDomainId_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuUtilizationDomainIdPtr)));
                if (m_value.GpuUtilizationDomainIdPtr != nullptr)
                {
                    std::memcpy(m_value.GpuUtilizationDomainIdPtr, other.m_value.GpuUtilizationDomainIdPtr, allocateNum * sizeof(*other.m_value.GpuUtilizationDomainIdPtr));
                }
                break;
            }
            case INJECTION_GPUVIRTUALIZATIONMODE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GpuVirtualizationModePtr = static_cast<nvmlGpuVirtualizationMode_t *>(malloc(allocateNum * sizeof(*other.m_value.GpuVirtualizationModePtr)));
                if (m_value.GpuVirtualizationModePtr != nullptr)
                {
                    std::memcpy(m_value.GpuVirtualizationModePtr, other.m_value.GpuVirtualizationModePtr, allocateNum * sizeof(*other.m_value.GpuVirtualizationModePtr));
                }
                break;
            }
            case INJECTION_GRIDLICENSABLEFEATURE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GridLicensableFeaturePtr = static_cast<nvmlGridLicensableFeature_t *>(malloc(allocateNum * sizeof(*other.m_value.GridLicensableFeaturePtr)));
                if (m_value.GridLicensableFeaturePtr != nullptr)
                {
                    std::memcpy(m_value.GridLicensableFeaturePtr, other.m_value.GridLicensableFeaturePtr, allocateNum * sizeof(*other.m_value.GridLicensableFeaturePtr));
                }
                break;
            }
            case INJECTION_GRIDLICENSABLEFEATURES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GridLicensableFeaturesPtr = static_cast<nvmlGridLicensableFeatures_t *>(malloc(allocateNum * sizeof(*other.m_value.GridLicensableFeaturesPtr)));
                if (m_value.GridLicensableFeaturesPtr != nullptr)
                {
                    std::memcpy(m_value.GridLicensableFeaturesPtr, other.m_value.GridLicensableFeaturesPtr, allocateNum * sizeof(*other.m_value.GridLicensableFeaturesPtr));
                }
                break;
            }
            case INJECTION_GRIDLICENSEEXPIRY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GridLicenseExpiryPtr = static_cast<nvmlGridLicenseExpiry_t *>(malloc(allocateNum * sizeof(*other.m_value.GridLicenseExpiryPtr)));
                if (m_value.GridLicenseExpiryPtr != nullptr)
                {
                    std::memcpy(m_value.GridLicenseExpiryPtr, other.m_value.GridLicenseExpiryPtr, allocateNum * sizeof(*other.m_value.GridLicenseExpiryPtr));
                }
                break;
            }
            case INJECTION_GRIDLICENSEFEATURECODE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.GridLicenseFeatureCodePtr = static_cast<nvmlGridLicenseFeatureCode_t *>(malloc(allocateNum * sizeof(*other.m_value.GridLicenseFeatureCodePtr)));
                if (m_value.GridLicenseFeatureCodePtr != nullptr)
                {
                    std::memcpy(m_value.GridLicenseFeatureCodePtr, other.m_value.GridLicenseFeatureCodePtr, allocateNum * sizeof(*other.m_value.GridLicenseFeatureCodePtr));
                }
                break;
            }
            case INJECTION_HOSTVGPUMODE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.HostVgpuModePtr = static_cast<nvmlHostVgpuMode_t *>(malloc(allocateNum * sizeof(*other.m_value.HostVgpuModePtr)));
                if (m_value.HostVgpuModePtr != nullptr)
                {
                    std::memcpy(m_value.HostVgpuModePtr, other.m_value.HostVgpuModePtr, allocateNum * sizeof(*other.m_value.HostVgpuModePtr));
                }
                break;
            }
            case INJECTION_HWBCENTRY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.HwbcEntryPtr = static_cast<nvmlHwbcEntry_t *>(malloc(allocateNum * sizeof(*other.m_value.HwbcEntryPtr)));
                if (m_value.HwbcEntryPtr != nullptr)
                {
                    std::memcpy(m_value.HwbcEntryPtr, other.m_value.HwbcEntryPtr, allocateNum * sizeof(*other.m_value.HwbcEntryPtr));
                }
                break;
            }
            case INJECTION_INFOROMOBJECT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.InforomObjectPtr = static_cast<nvmlInforomObject_t *>(malloc(allocateNum * sizeof(*other.m_value.InforomObjectPtr)));
                if (m_value.InforomObjectPtr != nullptr)
                {
                    std::memcpy(m_value.InforomObjectPtr, other.m_value.InforomObjectPtr, allocateNum * sizeof(*other.m_value.InforomObjectPtr));
                }
                break;
            }
            case INJECTION_INTNVLINKDEVICETYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.IntNvLinkDeviceTypePtr = static_cast<nvmlIntNvLinkDeviceType_t *>(malloc(allocateNum * sizeof(*other.m_value.IntNvLinkDeviceTypePtr)));
                if (m_value.IntNvLinkDeviceTypePtr != nullptr)
                {
                    std::memcpy(m_value.IntNvLinkDeviceTypePtr, other.m_value.IntNvLinkDeviceTypePtr, allocateNum * sizeof(*other.m_value.IntNvLinkDeviceTypePtr));
                }
                break;
            }
            case INJECTION_LEDCOLOR_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.LedColorPtr = static_cast<nvmlLedColor_t *>(malloc(allocateNum * sizeof(*other.m_value.LedColorPtr)));
                if (m_value.LedColorPtr != nullptr)
                {
                    std::memcpy(m_value.LedColorPtr, other.m_value.LedColorPtr, allocateNum * sizeof(*other.m_value.LedColorPtr));
                }
                break;
            }
            case INJECTION_LEDSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.LedStatePtr = static_cast<nvmlLedState_t *>(malloc(allocateNum * sizeof(*other.m_value.LedStatePtr)));
                if (m_value.LedStatePtr != nullptr)
                {
                    std::memcpy(m_value.LedStatePtr, other.m_value.LedStatePtr, allocateNum * sizeof(*other.m_value.LedStatePtr));
                }
                break;
            }
            case INJECTION_MASK255_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.Mask255Ptr = static_cast<nvmlMask255_t *>(malloc(allocateNum * sizeof(*other.m_value.Mask255Ptr)));
                if (m_value.Mask255Ptr != nullptr)
                {
                    std::memcpy(m_value.Mask255Ptr, other.m_value.Mask255Ptr, allocateNum * sizeof(*other.m_value.Mask255Ptr));
                }
                break;
            }
            case INJECTION_MEMORYERRORTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.MemoryErrorTypePtr = static_cast<nvmlMemoryErrorType_t *>(malloc(allocateNum * sizeof(*other.m_value.MemoryErrorTypePtr)));
                if (m_value.MemoryErrorTypePtr != nullptr)
                {
                    std::memcpy(m_value.MemoryErrorTypePtr, other.m_value.MemoryErrorTypePtr, allocateNum * sizeof(*other.m_value.MemoryErrorTypePtr));
                }
                break;
            }
            case INJECTION_MEMORYLOCATION_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.MemoryLocationPtr = static_cast<nvmlMemoryLocation_t *>(malloc(allocateNum * sizeof(*other.m_value.MemoryLocationPtr)));
                if (m_value.MemoryLocationPtr != nullptr)
                {
                    std::memcpy(m_value.MemoryLocationPtr, other.m_value.MemoryLocationPtr, allocateNum * sizeof(*other.m_value.MemoryLocationPtr));
                }
                break;
            }
            case INJECTION_MEMORY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.MemoryPtr = static_cast<nvmlMemory_t *>(malloc(allocateNum * sizeof(*other.m_value.MemoryPtr)));
                if (m_value.MemoryPtr != nullptr)
                {
                    std::memcpy(m_value.MemoryPtr, other.m_value.MemoryPtr, allocateNum * sizeof(*other.m_value.MemoryPtr));
                }
                break;
            }
            case INJECTION_MEMORY_V2_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.Memory_v2Ptr = static_cast<nvmlMemory_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.Memory_v2Ptr)));
                if (m_value.Memory_v2Ptr != nullptr)
                {
                    std::memcpy(m_value.Memory_v2Ptr, other.m_value.Memory_v2Ptr, allocateNum * sizeof(*other.m_value.Memory_v2Ptr));
                }
                break;
            }
            case INJECTION_NVLINKCAPABILITY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.NvLinkCapabilityPtr = static_cast<nvmlNvLinkCapability_t *>(malloc(allocateNum * sizeof(*other.m_value.NvLinkCapabilityPtr)));
                if (m_value.NvLinkCapabilityPtr != nullptr)
                {
                    std::memcpy(m_value.NvLinkCapabilityPtr, other.m_value.NvLinkCapabilityPtr, allocateNum * sizeof(*other.m_value.NvLinkCapabilityPtr));
                }
                break;
            }
            case INJECTION_NVLINKERRORCOUNTER_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.NvLinkErrorCounterPtr = static_cast<nvmlNvLinkErrorCounter_t *>(malloc(allocateNum * sizeof(*other.m_value.NvLinkErrorCounterPtr)));
                if (m_value.NvLinkErrorCounterPtr != nullptr)
                {
                    std::memcpy(m_value.NvLinkErrorCounterPtr, other.m_value.NvLinkErrorCounterPtr, allocateNum * sizeof(*other.m_value.NvLinkErrorCounterPtr));
                }
                break;
            }
            case INJECTION_NVLINKPOWERTHRES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.NvLinkPowerThresPtr = static_cast<nvmlNvLinkPowerThres_t *>(malloc(allocateNum * sizeof(*other.m_value.NvLinkPowerThresPtr)));
                if (m_value.NvLinkPowerThresPtr != nullptr)
                {
                    std::memcpy(m_value.NvLinkPowerThresPtr, other.m_value.NvLinkPowerThresPtr, allocateNum * sizeof(*other.m_value.NvLinkPowerThresPtr));
                }
                break;
            }
            case INJECTION_NVLINKUTILIZATIONCONTROL_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.NvLinkUtilizationControlPtr = static_cast<nvmlNvLinkUtilizationControl_t *>(malloc(allocateNum * sizeof(*other.m_value.NvLinkUtilizationControlPtr)));
                if (m_value.NvLinkUtilizationControlPtr != nullptr)
                {
                    std::memcpy(m_value.NvLinkUtilizationControlPtr, other.m_value.NvLinkUtilizationControlPtr, allocateNum * sizeof(*other.m_value.NvLinkUtilizationControlPtr));
                }
                break;
            }
            case INJECTION_NVLINKUTILIZATIONCOUNTPKTTYPES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.NvLinkUtilizationCountPktTypesPtr = static_cast<nvmlNvLinkUtilizationCountPktTypes_t *>(malloc(allocateNum * sizeof(*other.m_value.NvLinkUtilizationCountPktTypesPtr)));
                if (m_value.NvLinkUtilizationCountPktTypesPtr != nullptr)
                {
                    std::memcpy(m_value.NvLinkUtilizationCountPktTypesPtr, other.m_value.NvLinkUtilizationCountPktTypesPtr, allocateNum * sizeof(*other.m_value.NvLinkUtilizationCountPktTypesPtr));
                }
                break;
            }
            case INJECTION_NVLINKUTILIZATIONCOUNTUNITS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.NvLinkUtilizationCountUnitsPtr = static_cast<nvmlNvLinkUtilizationCountUnits_t *>(malloc(allocateNum * sizeof(*other.m_value.NvLinkUtilizationCountUnitsPtr)));
                if (m_value.NvLinkUtilizationCountUnitsPtr != nullptr)
                {
                    std::memcpy(m_value.NvLinkUtilizationCountUnitsPtr, other.m_value.NvLinkUtilizationCountUnitsPtr, allocateNum * sizeof(*other.m_value.NvLinkUtilizationCountUnitsPtr));
                }
                break;
            }
            case INJECTION_NVLINKVERSION_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.NvlinkVersionPtr = static_cast<nvmlNvlinkVersion_t *>(malloc(allocateNum * sizeof(*other.m_value.NvlinkVersionPtr)));
                if (m_value.NvlinkVersionPtr != nullptr)
                {
                    std::memcpy(m_value.NvlinkVersionPtr, other.m_value.NvlinkVersionPtr, allocateNum * sizeof(*other.m_value.NvlinkVersionPtr));
                }
                break;
            }
            case INJECTION_PSUINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PSUInfoPtr = static_cast<nvmlPSUInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.PSUInfoPtr)));
                if (m_value.PSUInfoPtr != nullptr)
                {
                    std::memcpy(m_value.PSUInfoPtr, other.m_value.PSUInfoPtr, allocateNum * sizeof(*other.m_value.PSUInfoPtr));
                }
                break;
            }
            case INJECTION_PAGERETIREMENTCAUSE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PageRetirementCausePtr = static_cast<nvmlPageRetirementCause_t *>(malloc(allocateNum * sizeof(*other.m_value.PageRetirementCausePtr)));
                if (m_value.PageRetirementCausePtr != nullptr)
                {
                    std::memcpy(m_value.PageRetirementCausePtr, other.m_value.PageRetirementCausePtr, allocateNum * sizeof(*other.m_value.PageRetirementCausePtr));
                }
                break;
            }
            case INJECTION_PCIINFOEXT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PciInfoExtPtr = static_cast<nvmlPciInfoExt_t *>(malloc(allocateNum * sizeof(*other.m_value.PciInfoExtPtr)));
                if (m_value.PciInfoExtPtr != nullptr)
                {
                    std::memcpy(m_value.PciInfoExtPtr, other.m_value.PciInfoExtPtr, allocateNum * sizeof(*other.m_value.PciInfoExtPtr));
                }
                break;
            }
            case INJECTION_PCIINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PciInfoPtr = static_cast<nvmlPciInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.PciInfoPtr)));
                if (m_value.PciInfoPtr != nullptr)
                {
                    std::memcpy(m_value.PciInfoPtr, other.m_value.PciInfoPtr, allocateNum * sizeof(*other.m_value.PciInfoPtr));
                }
                break;
            }
            case INJECTION_PCIELINKSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PcieLinkStatePtr = static_cast<nvmlPcieLinkState_t *>(malloc(allocateNum * sizeof(*other.m_value.PcieLinkStatePtr)));
                if (m_value.PcieLinkStatePtr != nullptr)
                {
                    std::memcpy(m_value.PcieLinkStatePtr, other.m_value.PcieLinkStatePtr, allocateNum * sizeof(*other.m_value.PcieLinkStatePtr));
                }
                break;
            }
            case INJECTION_PCIEUTILCOUNTER_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PcieUtilCounterPtr = static_cast<nvmlPcieUtilCounter_t *>(malloc(allocateNum * sizeof(*other.m_value.PcieUtilCounterPtr)));
                if (m_value.PcieUtilCounterPtr != nullptr)
                {
                    std::memcpy(m_value.PcieUtilCounterPtr, other.m_value.PcieUtilCounterPtr, allocateNum * sizeof(*other.m_value.PcieUtilCounterPtr));
                }
                break;
            }
            case INJECTION_PERFPOLICYTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PerfPolicyTypePtr = static_cast<nvmlPerfPolicyType_t *>(malloc(allocateNum * sizeof(*other.m_value.PerfPolicyTypePtr)));
                if (m_value.PerfPolicyTypePtr != nullptr)
                {
                    std::memcpy(m_value.PerfPolicyTypePtr, other.m_value.PerfPolicyTypePtr, allocateNum * sizeof(*other.m_value.PerfPolicyTypePtr));
                }
                break;
            }
            case INJECTION_PLATFORMINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PlatformInfoPtr = static_cast<nvmlPlatformInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.PlatformInfoPtr)));
                if (m_value.PlatformInfoPtr != nullptr)
                {
                    std::memcpy(m_value.PlatformInfoPtr, other.m_value.PlatformInfoPtr, allocateNum * sizeof(*other.m_value.PlatformInfoPtr));
                }
                break;
            }
            case INJECTION_POWERPROFILETYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PowerProfileTypePtr = static_cast<nvmlPowerProfileType_t *>(malloc(allocateNum * sizeof(*other.m_value.PowerProfileTypePtr)));
                if (m_value.PowerProfileTypePtr != nullptr)
                {
                    std::memcpy(m_value.PowerProfileTypePtr, other.m_value.PowerProfileTypePtr, allocateNum * sizeof(*other.m_value.PowerProfileTypePtr));
                }
                break;
            }
            case INJECTION_POWERSCOPETYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PowerScopeTypePtr = static_cast<nvmlPowerScopeType_t *>(malloc(allocateNum * sizeof(*other.m_value.PowerScopeTypePtr)));
                if (m_value.PowerScopeTypePtr != nullptr)
                {
                    std::memcpy(m_value.PowerScopeTypePtr, other.m_value.PowerScopeTypePtr, allocateNum * sizeof(*other.m_value.PowerScopeTypePtr));
                }
                break;
            }
            case INJECTION_POWERSOURCE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PowerSourcePtr = static_cast<nvmlPowerSource_t *>(malloc(allocateNum * sizeof(*other.m_value.PowerSourcePtr)));
                if (m_value.PowerSourcePtr != nullptr)
                {
                    std::memcpy(m_value.PowerSourcePtr, other.m_value.PowerSourcePtr, allocateNum * sizeof(*other.m_value.PowerSourcePtr));
                }
                break;
            }
            case INJECTION_POWERVALUE_V2_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PowerValue_v2Ptr = static_cast<nvmlPowerValue_v2_t *>(malloc(allocateNum * sizeof(*other.m_value.PowerValue_v2Ptr)));
                if (m_value.PowerValue_v2Ptr != nullptr)
                {
                    std::memcpy(m_value.PowerValue_v2Ptr, other.m_value.PowerValue_v2Ptr, allocateNum * sizeof(*other.m_value.PowerValue_v2Ptr));
                }
                break;
            }
            case INJECTION_PROCESSDETAILLIST_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ProcessDetailListPtr = static_cast<nvmlProcessDetailList_t *>(malloc(allocateNum * sizeof(*other.m_value.ProcessDetailListPtr)));
                if (m_value.ProcessDetailListPtr != nullptr)
                {
                    std::memcpy(m_value.ProcessDetailListPtr, other.m_value.ProcessDetailListPtr, allocateNum * sizeof(*other.m_value.ProcessDetailListPtr));
                }
                break;
            }
            case INJECTION_PROCESSDETAIL_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ProcessDetail_v1Ptr = static_cast<nvmlProcessDetail_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.ProcessDetail_v1Ptr)));
                if (m_value.ProcessDetail_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.ProcessDetail_v1Ptr, other.m_value.ProcessDetail_v1Ptr, allocateNum * sizeof(*other.m_value.ProcessDetail_v1Ptr));
                }
                break;
            }
            case INJECTION_PROCESSINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ProcessInfoPtr = static_cast<nvmlProcessInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.ProcessInfoPtr)));
                if (m_value.ProcessInfoPtr != nullptr)
                {
                    std::memcpy(m_value.ProcessInfoPtr, other.m_value.ProcessInfoPtr, allocateNum * sizeof(*other.m_value.ProcessInfoPtr));
                }
                break;
            }
            case INJECTION_PROCESSINFO_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ProcessInfo_v1Ptr = static_cast<nvmlProcessInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.ProcessInfo_v1Ptr)));
                if (m_value.ProcessInfo_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.ProcessInfo_v1Ptr, other.m_value.ProcessInfo_v1Ptr, allocateNum * sizeof(*other.m_value.ProcessInfo_v1Ptr));
                }
                break;
            }
            case INJECTION_PROCESSUTILIZATIONINFO_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ProcessUtilizationInfo_v1Ptr = static_cast<nvmlProcessUtilizationInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.ProcessUtilizationInfo_v1Ptr)));
                if (m_value.ProcessUtilizationInfo_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.ProcessUtilizationInfo_v1Ptr, other.m_value.ProcessUtilizationInfo_v1Ptr, allocateNum * sizeof(*other.m_value.ProcessUtilizationInfo_v1Ptr));
                }
                break;
            }
            case INJECTION_PROCESSUTILIZATIONSAMPLE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ProcessUtilizationSamplePtr = static_cast<nvmlProcessUtilizationSample_t *>(malloc(allocateNum * sizeof(*other.m_value.ProcessUtilizationSamplePtr)));
                if (m_value.ProcessUtilizationSamplePtr != nullptr)
                {
                    std::memcpy(m_value.ProcessUtilizationSamplePtr, other.m_value.ProcessUtilizationSamplePtr, allocateNum * sizeof(*other.m_value.ProcessUtilizationSamplePtr));
                }
                break;
            }
            case INJECTION_PROCESSESUTILIZATIONINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ProcessesUtilizationInfoPtr = static_cast<nvmlProcessesUtilizationInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.ProcessesUtilizationInfoPtr)));
                if (m_value.ProcessesUtilizationInfoPtr != nullptr)
                {
                    std::memcpy(m_value.ProcessesUtilizationInfoPtr, other.m_value.ProcessesUtilizationInfoPtr, allocateNum * sizeof(*other.m_value.ProcessesUtilizationInfoPtr));
                }
                break;
            }
            case INJECTION_PSTATES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.PstatesPtr = static_cast<nvmlPstates_t *>(malloc(allocateNum * sizeof(*other.m_value.PstatesPtr)));
                if (m_value.PstatesPtr != nullptr)
                {
                    std::memcpy(m_value.PstatesPtr, other.m_value.PstatesPtr, allocateNum * sizeof(*other.m_value.PstatesPtr));
                }
                break;
            }
            case INJECTION_RESTRICTEDAPI_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.RestrictedAPIPtr = static_cast<nvmlRestrictedAPI_t *>(malloc(allocateNum * sizeof(*other.m_value.RestrictedAPIPtr)));
                if (m_value.RestrictedAPIPtr != nullptr)
                {
                    std::memcpy(m_value.RestrictedAPIPtr, other.m_value.RestrictedAPIPtr, allocateNum * sizeof(*other.m_value.RestrictedAPIPtr));
                }
                break;
            }
            case INJECTION_RETURN_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ReturnPtr = static_cast<nvmlReturn_t *>(malloc(allocateNum * sizeof(*other.m_value.ReturnPtr)));
                if (m_value.ReturnPtr != nullptr)
                {
                    std::memcpy(m_value.ReturnPtr, other.m_value.ReturnPtr, allocateNum * sizeof(*other.m_value.ReturnPtr));
                }
                break;
            }
            case INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.RowRemapperHistogramValuesPtr = static_cast<nvmlRowRemapperHistogramValues_t *>(malloc(allocateNum * sizeof(*other.m_value.RowRemapperHistogramValuesPtr)));
                if (m_value.RowRemapperHistogramValuesPtr != nullptr)
                {
                    std::memcpy(m_value.RowRemapperHistogramValuesPtr, other.m_value.RowRemapperHistogramValuesPtr, allocateNum * sizeof(*other.m_value.RowRemapperHistogramValuesPtr));
                }
                break;
            }
            case INJECTION_SAMPLE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.SamplePtr = static_cast<nvmlSample_t *>(malloc(allocateNum * sizeof(*other.m_value.SamplePtr)));
                if (m_value.SamplePtr != nullptr)
                {
                    std::memcpy(m_value.SamplePtr, other.m_value.SamplePtr, allocateNum * sizeof(*other.m_value.SamplePtr));
                }
                break;
            }
            case INJECTION_SAMPLINGTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.SamplingTypePtr = static_cast<nvmlSamplingType_t *>(malloc(allocateNum * sizeof(*other.m_value.SamplingTypePtr)));
                if (m_value.SamplingTypePtr != nullptr)
                {
                    std::memcpy(m_value.SamplingTypePtr, other.m_value.SamplingTypePtr, allocateNum * sizeof(*other.m_value.SamplingTypePtr));
                }
                break;
            }
            case INJECTION_SYSTEMCONFCOMPUTESETTINGS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.SystemConfComputeSettingsPtr = static_cast<nvmlSystemConfComputeSettings_t *>(malloc(allocateNum * sizeof(*other.m_value.SystemConfComputeSettingsPtr)));
                if (m_value.SystemConfComputeSettingsPtr != nullptr)
                {
                    std::memcpy(m_value.SystemConfComputeSettingsPtr, other.m_value.SystemConfComputeSettingsPtr, allocateNum * sizeof(*other.m_value.SystemConfComputeSettingsPtr));
                }
                break;
            }
            case INJECTION_SYSTEMDRIVERBRANCHINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.SystemDriverBranchInfoPtr = static_cast<nvmlSystemDriverBranchInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.SystemDriverBranchInfoPtr)));
                if (m_value.SystemDriverBranchInfoPtr != nullptr)
                {
                    std::memcpy(m_value.SystemDriverBranchInfoPtr, other.m_value.SystemDriverBranchInfoPtr, allocateNum * sizeof(*other.m_value.SystemDriverBranchInfoPtr));
                }
                break;
            }
            case INJECTION_TEMPERATURESENSORS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.TemperatureSensorsPtr = static_cast<nvmlTemperatureSensors_t *>(malloc(allocateNum * sizeof(*other.m_value.TemperatureSensorsPtr)));
                if (m_value.TemperatureSensorsPtr != nullptr)
                {
                    std::memcpy(m_value.TemperatureSensorsPtr, other.m_value.TemperatureSensorsPtr, allocateNum * sizeof(*other.m_value.TemperatureSensorsPtr));
                }
                break;
            }
            case INJECTION_TEMPERATURETHRESHOLDS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.TemperatureThresholdsPtr = static_cast<nvmlTemperatureThresholds_t *>(malloc(allocateNum * sizeof(*other.m_value.TemperatureThresholdsPtr)));
                if (m_value.TemperatureThresholdsPtr != nullptr)
                {
                    std::memcpy(m_value.TemperatureThresholdsPtr, other.m_value.TemperatureThresholdsPtr, allocateNum * sizeof(*other.m_value.TemperatureThresholdsPtr));
                }
                break;
            }
            case INJECTION_TEMPERATURE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.TemperaturePtr = static_cast<nvmlTemperature_t *>(malloc(allocateNum * sizeof(*other.m_value.TemperaturePtr)));
                if (m_value.TemperaturePtr != nullptr)
                {
                    std::memcpy(m_value.TemperaturePtr, other.m_value.TemperaturePtr, allocateNum * sizeof(*other.m_value.TemperaturePtr));
                }
                break;
            }
            case INJECTION_THERMALCONTROLLER_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ThermalControllerPtr = static_cast<nvmlThermalController_t *>(malloc(allocateNum * sizeof(*other.m_value.ThermalControllerPtr)));
                if (m_value.ThermalControllerPtr != nullptr)
                {
                    std::memcpy(m_value.ThermalControllerPtr, other.m_value.ThermalControllerPtr, allocateNum * sizeof(*other.m_value.ThermalControllerPtr));
                }
                break;
            }
            case INJECTION_THERMALTARGET_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ThermalTargetPtr = static_cast<nvmlThermalTarget_t *>(malloc(allocateNum * sizeof(*other.m_value.ThermalTargetPtr)));
                if (m_value.ThermalTargetPtr != nullptr)
                {
                    std::memcpy(m_value.ThermalTargetPtr, other.m_value.ThermalTargetPtr, allocateNum * sizeof(*other.m_value.ThermalTargetPtr));
                }
                break;
            }
            case INJECTION_UNITFANINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UnitFanInfoPtr = static_cast<nvmlUnitFanInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.UnitFanInfoPtr)));
                if (m_value.UnitFanInfoPtr != nullptr)
                {
                    std::memcpy(m_value.UnitFanInfoPtr, other.m_value.UnitFanInfoPtr, allocateNum * sizeof(*other.m_value.UnitFanInfoPtr));
                }
                break;
            }
            case INJECTION_UNITFANSPEEDS_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UnitFanSpeedsPtr = static_cast<nvmlUnitFanSpeeds_t *>(malloc(allocateNum * sizeof(*other.m_value.UnitFanSpeedsPtr)));
                if (m_value.UnitFanSpeedsPtr != nullptr)
                {
                    std::memcpy(m_value.UnitFanSpeedsPtr, other.m_value.UnitFanSpeedsPtr, allocateNum * sizeof(*other.m_value.UnitFanSpeedsPtr));
                }
                break;
            }
            case INJECTION_UNITINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UnitInfoPtr = static_cast<nvmlUnitInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.UnitInfoPtr)));
                if (m_value.UnitInfoPtr != nullptr)
                {
                    std::memcpy(m_value.UnitInfoPtr, other.m_value.UnitInfoPtr, allocateNum * sizeof(*other.m_value.UnitInfoPtr));
                }
                break;
            }
            case INJECTION_UNIT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UnitPtr = static_cast<nvmlUnit_t *>(malloc(allocateNum * sizeof(*other.m_value.UnitPtr)));
                if (m_value.UnitPtr != nullptr)
                {
                    std::memcpy(m_value.UnitPtr, other.m_value.UnitPtr, allocateNum * sizeof(*other.m_value.UnitPtr));
                }
                break;
            }
            case INJECTION_UTILIZATION_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UtilizationPtr = static_cast<nvmlUtilization_t *>(malloc(allocateNum * sizeof(*other.m_value.UtilizationPtr)));
                if (m_value.UtilizationPtr != nullptr)
                {
                    std::memcpy(m_value.UtilizationPtr, other.m_value.UtilizationPtr, allocateNum * sizeof(*other.m_value.UtilizationPtr));
                }
                break;
            }
            case INJECTION_VALUETYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ValueTypePtr = static_cast<nvmlValueType_t *>(malloc(allocateNum * sizeof(*other.m_value.ValueTypePtr)));
                if (m_value.ValueTypePtr != nullptr)
                {
                    std::memcpy(m_value.ValueTypePtr, other.m_value.ValueTypePtr, allocateNum * sizeof(*other.m_value.ValueTypePtr));
                }
                break;
            }
            case INJECTION_VGPUCAPABILITY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuCapabilityPtr = static_cast<nvmlVgpuCapability_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuCapabilityPtr)));
                if (m_value.VgpuCapabilityPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuCapabilityPtr, other.m_value.VgpuCapabilityPtr, allocateNum * sizeof(*other.m_value.VgpuCapabilityPtr));
                }
                break;
            }
            case INJECTION_VGPUDRIVERCAPABILITY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuDriverCapabilityPtr = static_cast<nvmlVgpuDriverCapability_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuDriverCapabilityPtr)));
                if (m_value.VgpuDriverCapabilityPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuDriverCapabilityPtr, other.m_value.VgpuDriverCapabilityPtr, allocateNum * sizeof(*other.m_value.VgpuDriverCapabilityPtr));
                }
                break;
            }
            case INJECTION_VGPUGUESTINFOSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuGuestInfoStatePtr = static_cast<nvmlVgpuGuestInfoState_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuGuestInfoStatePtr)));
                if (m_value.VgpuGuestInfoStatePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuGuestInfoStatePtr, other.m_value.VgpuGuestInfoStatePtr, allocateNum * sizeof(*other.m_value.VgpuGuestInfoStatePtr));
                }
                break;
            }
            case INJECTION_VGPUHETEROGENEOUSMODE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuHeterogeneousModePtr = static_cast<nvmlVgpuHeterogeneousMode_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuHeterogeneousModePtr)));
                if (m_value.VgpuHeterogeneousModePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuHeterogeneousModePtr, other.m_value.VgpuHeterogeneousModePtr, allocateNum * sizeof(*other.m_value.VgpuHeterogeneousModePtr));
                }
                break;
            }
            case INJECTION_VGPUINSTANCEUTILIZATIONINFO_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuInstanceUtilizationInfo_v1Ptr = static_cast<nvmlVgpuInstanceUtilizationInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuInstanceUtilizationInfo_v1Ptr)));
                if (m_value.VgpuInstanceUtilizationInfo_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.VgpuInstanceUtilizationInfo_v1Ptr, other.m_value.VgpuInstanceUtilizationInfo_v1Ptr, allocateNum * sizeof(*other.m_value.VgpuInstanceUtilizationInfo_v1Ptr));
                }
                break;
            }
            case INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuInstanceUtilizationSamplePtr = static_cast<nvmlVgpuInstanceUtilizationSample_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuInstanceUtilizationSamplePtr)));
                if (m_value.VgpuInstanceUtilizationSamplePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuInstanceUtilizationSamplePtr, other.m_value.VgpuInstanceUtilizationSamplePtr, allocateNum * sizeof(*other.m_value.VgpuInstanceUtilizationSamplePtr));
                }
                break;
            }
            case INJECTION_VGPUINSTANCE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuInstancePtr = static_cast<nvmlVgpuInstance_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuInstancePtr)));
                if (m_value.VgpuInstancePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuInstancePtr, other.m_value.VgpuInstancePtr, allocateNum * sizeof(*other.m_value.VgpuInstancePtr));
                }
                break;
            }
            case INJECTION_VGPUINSTANCESUTILIZATIONINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuInstancesUtilizationInfoPtr = static_cast<nvmlVgpuInstancesUtilizationInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuInstancesUtilizationInfoPtr)));
                if (m_value.VgpuInstancesUtilizationInfoPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuInstancesUtilizationInfoPtr, other.m_value.VgpuInstancesUtilizationInfoPtr, allocateNum * sizeof(*other.m_value.VgpuInstancesUtilizationInfoPtr));
                }
                break;
            }
            case INJECTION_VGPULICENSEEXPIRY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuLicenseExpiryPtr = static_cast<nvmlVgpuLicenseExpiry_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuLicenseExpiryPtr)));
                if (m_value.VgpuLicenseExpiryPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuLicenseExpiryPtr, other.m_value.VgpuLicenseExpiryPtr, allocateNum * sizeof(*other.m_value.VgpuLicenseExpiryPtr));
                }
                break;
            }
            case INJECTION_VGPULICENSEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuLicenseInfoPtr = static_cast<nvmlVgpuLicenseInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuLicenseInfoPtr)));
                if (m_value.VgpuLicenseInfoPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuLicenseInfoPtr, other.m_value.VgpuLicenseInfoPtr, allocateNum * sizeof(*other.m_value.VgpuLicenseInfoPtr));
                }
                break;
            }
            case INJECTION_VGPUMETADATA_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuMetadataPtr = static_cast<nvmlVgpuMetadata_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuMetadataPtr)));
                if (m_value.VgpuMetadataPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuMetadataPtr, other.m_value.VgpuMetadataPtr, allocateNum * sizeof(*other.m_value.VgpuMetadataPtr));
                }
                break;
            }
            case INJECTION_VGPUPGPUCOMPATIBILITYLIMITCODE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuPgpuCompatibilityLimitCodePtr = static_cast<nvmlVgpuPgpuCompatibilityLimitCode_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuPgpuCompatibilityLimitCodePtr)));
                if (m_value.VgpuPgpuCompatibilityLimitCodePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuPgpuCompatibilityLimitCodePtr, other.m_value.VgpuPgpuCompatibilityLimitCodePtr, allocateNum * sizeof(*other.m_value.VgpuPgpuCompatibilityLimitCodePtr));
                }
                break;
            }
            case INJECTION_VGPUPGPUCOMPATIBILITY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuPgpuCompatibilityPtr = static_cast<nvmlVgpuPgpuCompatibility_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuPgpuCompatibilityPtr)));
                if (m_value.VgpuPgpuCompatibilityPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuPgpuCompatibilityPtr, other.m_value.VgpuPgpuCompatibilityPtr, allocateNum * sizeof(*other.m_value.VgpuPgpuCompatibilityPtr));
                }
                break;
            }
            case INJECTION_VGPUPGPUMETADATA_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuPgpuMetadataPtr = static_cast<nvmlVgpuPgpuMetadata_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuPgpuMetadataPtr)));
                if (m_value.VgpuPgpuMetadataPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuPgpuMetadataPtr, other.m_value.VgpuPgpuMetadataPtr, allocateNum * sizeof(*other.m_value.VgpuPgpuMetadataPtr));
                }
                break;
            }
            case INJECTION_VGPUPLACEMENTID_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuPlacementIdPtr = static_cast<nvmlVgpuPlacementId_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuPlacementIdPtr)));
                if (m_value.VgpuPlacementIdPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuPlacementIdPtr, other.m_value.VgpuPlacementIdPtr, allocateNum * sizeof(*other.m_value.VgpuPlacementIdPtr));
                }
                break;
            }
            case INJECTION_VGPUPLACEMENTLIST_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuPlacementListPtr = static_cast<nvmlVgpuPlacementList_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuPlacementListPtr)));
                if (m_value.VgpuPlacementListPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuPlacementListPtr, other.m_value.VgpuPlacementListPtr, allocateNum * sizeof(*other.m_value.VgpuPlacementListPtr));
                }
                break;
            }
            case INJECTION_VGPUPLACEMENTLIST_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuPlacementList_v1Ptr = static_cast<nvmlVgpuPlacementList_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuPlacementList_v1Ptr)));
                if (m_value.VgpuPlacementList_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.VgpuPlacementList_v1Ptr, other.m_value.VgpuPlacementList_v1Ptr, allocateNum * sizeof(*other.m_value.VgpuPlacementList_v1Ptr));
                }
                break;
            }
            case INJECTION_VGPUPROCESSUTILIZATIONINFO_V1_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuProcessUtilizationInfo_v1Ptr = static_cast<nvmlVgpuProcessUtilizationInfo_v1_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuProcessUtilizationInfo_v1Ptr)));
                if (m_value.VgpuProcessUtilizationInfo_v1Ptr != nullptr)
                {
                    std::memcpy(m_value.VgpuProcessUtilizationInfo_v1Ptr, other.m_value.VgpuProcessUtilizationInfo_v1Ptr, allocateNum * sizeof(*other.m_value.VgpuProcessUtilizationInfo_v1Ptr));
                }
                break;
            }
            case INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuProcessUtilizationSamplePtr = static_cast<nvmlVgpuProcessUtilizationSample_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuProcessUtilizationSamplePtr)));
                if (m_value.VgpuProcessUtilizationSamplePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuProcessUtilizationSamplePtr, other.m_value.VgpuProcessUtilizationSamplePtr, allocateNum * sizeof(*other.m_value.VgpuProcessUtilizationSamplePtr));
                }
                break;
            }
            case INJECTION_VGPUPROCESSESUTILIZATIONINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuProcessesUtilizationInfoPtr = static_cast<nvmlVgpuProcessesUtilizationInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuProcessesUtilizationInfoPtr)));
                if (m_value.VgpuProcessesUtilizationInfoPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuProcessesUtilizationInfoPtr, other.m_value.VgpuProcessesUtilizationInfoPtr, allocateNum * sizeof(*other.m_value.VgpuProcessesUtilizationInfoPtr));
                }
                break;
            }
            case INJECTION_VGPUSCHEDULERCAPABILITIES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuSchedulerCapabilitiesPtr = static_cast<nvmlVgpuSchedulerCapabilities_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuSchedulerCapabilitiesPtr)));
                if (m_value.VgpuSchedulerCapabilitiesPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuSchedulerCapabilitiesPtr, other.m_value.VgpuSchedulerCapabilitiesPtr, allocateNum * sizeof(*other.m_value.VgpuSchedulerCapabilitiesPtr));
                }
                break;
            }
            case INJECTION_VGPUSCHEDULERGETSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuSchedulerGetStatePtr = static_cast<nvmlVgpuSchedulerGetState_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuSchedulerGetStatePtr)));
                if (m_value.VgpuSchedulerGetStatePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuSchedulerGetStatePtr, other.m_value.VgpuSchedulerGetStatePtr, allocateNum * sizeof(*other.m_value.VgpuSchedulerGetStatePtr));
                }
                break;
            }
            case INJECTION_VGPUSCHEDULERLOGENTRY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuSchedulerLogEntryPtr = static_cast<nvmlVgpuSchedulerLogEntry_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuSchedulerLogEntryPtr)));
                if (m_value.VgpuSchedulerLogEntryPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuSchedulerLogEntryPtr, other.m_value.VgpuSchedulerLogEntryPtr, allocateNum * sizeof(*other.m_value.VgpuSchedulerLogEntryPtr));
                }
                break;
            }
            case INJECTION_VGPUSCHEDULERLOG_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuSchedulerLogPtr = static_cast<nvmlVgpuSchedulerLog_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuSchedulerLogPtr)));
                if (m_value.VgpuSchedulerLogPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuSchedulerLogPtr, other.m_value.VgpuSchedulerLogPtr, allocateNum * sizeof(*other.m_value.VgpuSchedulerLogPtr));
                }
                break;
            }
            case INJECTION_VGPUSCHEDULERSETSTATE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuSchedulerSetStatePtr = static_cast<nvmlVgpuSchedulerSetState_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuSchedulerSetStatePtr)));
                if (m_value.VgpuSchedulerSetStatePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuSchedulerSetStatePtr, other.m_value.VgpuSchedulerSetStatePtr, allocateNum * sizeof(*other.m_value.VgpuSchedulerSetStatePtr));
                }
                break;
            }
            case INJECTION_VGPUTYPEBAR1INFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuTypeBar1InfoPtr = static_cast<nvmlVgpuTypeBar1Info_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuTypeBar1InfoPtr)));
                if (m_value.VgpuTypeBar1InfoPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuTypeBar1InfoPtr, other.m_value.VgpuTypeBar1InfoPtr, allocateNum * sizeof(*other.m_value.VgpuTypeBar1InfoPtr));
                }
                break;
            }
            case INJECTION_VGPUTYPEID_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuTypeIdPtr = static_cast<nvmlVgpuTypeId_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuTypeIdPtr)));
                if (m_value.VgpuTypeIdPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuTypeIdPtr, other.m_value.VgpuTypeIdPtr, allocateNum * sizeof(*other.m_value.VgpuTypeIdPtr));
                }
                break;
            }
            case INJECTION_VGPUVERSION_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuVersionPtr = static_cast<nvmlVgpuVersion_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuVersionPtr)));
                if (m_value.VgpuVersionPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuVersionPtr, other.m_value.VgpuVersionPtr, allocateNum * sizeof(*other.m_value.VgpuVersionPtr));
                }
                break;
            }
            case INJECTION_VGPUVMCOMPATIBILITY_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuVmCompatibilityPtr = static_cast<nvmlVgpuVmCompatibility_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuVmCompatibilityPtr)));
                if (m_value.VgpuVmCompatibilityPtr != nullptr)
                {
                    std::memcpy(m_value.VgpuVmCompatibilityPtr, other.m_value.VgpuVmCompatibilityPtr, allocateNum * sizeof(*other.m_value.VgpuVmCompatibilityPtr));
                }
                break;
            }
            case INJECTION_VGPUVMIDTYPE_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.VgpuVmIdTypePtr = static_cast<nvmlVgpuVmIdType_t *>(malloc(allocateNum * sizeof(*other.m_value.VgpuVmIdTypePtr)));
                if (m_value.VgpuVmIdTypePtr != nullptr)
                {
                    std::memcpy(m_value.VgpuVmIdTypePtr, other.m_value.VgpuVmIdTypePtr, allocateNum * sizeof(*other.m_value.VgpuVmIdTypePtr));
                }
                break;
            }
            case INJECTION_VIOLATIONTIME_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ViolationTimePtr = static_cast<nvmlViolationTime_t *>(malloc(allocateNum * sizeof(*other.m_value.ViolationTimePtr)));
                if (m_value.ViolationTimePtr != nullptr)
                {
                    std::memcpy(m_value.ViolationTimePtr, other.m_value.ViolationTimePtr, allocateNum * sizeof(*other.m_value.ViolationTimePtr));
                }
                break;
            }
            case INJECTION_WORKLOADPOWERPROFILECURRENTPROFILES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.WorkloadPowerProfileCurrentProfilesPtr = static_cast<nvmlWorkloadPowerProfileCurrentProfiles_t *>(malloc(allocateNum * sizeof(*other.m_value.WorkloadPowerProfileCurrentProfilesPtr)));
                if (m_value.WorkloadPowerProfileCurrentProfilesPtr != nullptr)
                {
                    std::memcpy(m_value.WorkloadPowerProfileCurrentProfilesPtr, other.m_value.WorkloadPowerProfileCurrentProfilesPtr, allocateNum * sizeof(*other.m_value.WorkloadPowerProfileCurrentProfilesPtr));
                }
                break;
            }
            case INJECTION_WORKLOADPOWERPROFILEINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.WorkloadPowerProfileInfoPtr = static_cast<nvmlWorkloadPowerProfileInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.WorkloadPowerProfileInfoPtr)));
                if (m_value.WorkloadPowerProfileInfoPtr != nullptr)
                {
                    std::memcpy(m_value.WorkloadPowerProfileInfoPtr, other.m_value.WorkloadPowerProfileInfoPtr, allocateNum * sizeof(*other.m_value.WorkloadPowerProfileInfoPtr));
                }
                break;
            }
            case INJECTION_WORKLOADPOWERPROFILEPROFILESINFO_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.WorkloadPowerProfileProfilesInfoPtr = static_cast<nvmlWorkloadPowerProfileProfilesInfo_t *>(malloc(allocateNum * sizeof(*other.m_value.WorkloadPowerProfileProfilesInfoPtr)));
                if (m_value.WorkloadPowerProfileProfilesInfoPtr != nullptr)
                {
                    std::memcpy(m_value.WorkloadPowerProfileProfilesInfoPtr, other.m_value.WorkloadPowerProfileProfilesInfoPtr, allocateNum * sizeof(*other.m_value.WorkloadPowerProfileProfilesInfoPtr));
                }
                break;
            }
            case INJECTION_WORKLOADPOWERPROFILEREQUESTEDPROFILES_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.WorkloadPowerProfileRequestedProfilesPtr = static_cast<nvmlWorkloadPowerProfileRequestedProfiles_t *>(malloc(allocateNum * sizeof(*other.m_value.WorkloadPowerProfileRequestedProfilesPtr)));
                if (m_value.WorkloadPowerProfileRequestedProfilesPtr != nullptr)
                {
                    std::memcpy(m_value.WorkloadPowerProfileRequestedProfilesPtr, other.m_value.WorkloadPowerProfileRequestedProfilesPtr, allocateNum * sizeof(*other.m_value.WorkloadPowerProfileRequestedProfilesPtr));
                }
                break;
            }
            case INJECTION_SHORT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ShortPtr = static_cast<short *>(malloc(allocateNum * sizeof(*other.m_value.ShortPtr)));
                if (m_value.ShortPtr != nullptr)
                {
                    std::memcpy(m_value.ShortPtr, other.m_value.ShortPtr, allocateNum * sizeof(*other.m_value.ShortPtr));
                }
                break;
            }
            case INJECTION_UCHAR_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UCharPtr = static_cast<unsigned char *>(malloc(allocateNum * sizeof(*other.m_value.UCharPtr)));
                if (m_value.UCharPtr != nullptr)
                {
                    std::memcpy(m_value.UCharPtr, other.m_value.UCharPtr, allocateNum * sizeof(*other.m_value.UCharPtr));
                }
                break;
            }
            case INJECTION_UINT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UIntPtr = static_cast<unsigned int *>(malloc(allocateNum * sizeof(*other.m_value.UIntPtr)));
                if (m_value.UIntPtr != nullptr)
                {
                    std::memcpy(m_value.UIntPtr, other.m_value.UIntPtr, allocateNum * sizeof(*other.m_value.UIntPtr));
                }
                break;
            }
            case INJECTION_ULONG_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ULongPtr = static_cast<unsigned long *>(malloc(allocateNum * sizeof(*other.m_value.ULongPtr)));
                if (m_value.ULongPtr != nullptr)
                {
                    std::memcpy(m_value.ULongPtr, other.m_value.ULongPtr, allocateNum * sizeof(*other.m_value.ULongPtr));
                }
                break;
            }
            case INJECTION_ULONG_LONG_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.ULongLongPtr = static_cast<unsigned long long *>(malloc(allocateNum * sizeof(*other.m_value.ULongLongPtr)));
                if (m_value.ULongLongPtr != nullptr)
                {
                    std::memcpy(m_value.ULongLongPtr, other.m_value.ULongLongPtr, allocateNum * sizeof(*other.m_value.ULongLongPtr));
                }
                break;
            }
            case INJECTION_USHORT_PTR:
            {
                unsigned int allocateNum = m_isArray ? m_arrLen : 1;
                m_value.UShortPtr = static_cast<unsigned short *>(malloc(allocateNum * sizeof(*other.m_value.UShortPtr)));
                if (m_value.UShortPtr != nullptr)
                {
                    std::memcpy(m_value.UShortPtr, other.m_value.UShortPtr, allocateNum * sizeof(*other.m_value.UShortPtr));
                }
                break;
            }
            default:
                break; // NOT Reached
        }
    }

public:
    InjectionArgument()
        : m_type(InjectionArgCount)
    {
        Clear();
    }

    InjectionArgument(const injectNvmlVal_t &value)
        : m_type(value.type)
        , m_value(value.value)
    {}

    /**
     * SetValueFrom - Sets this injection argument based other's value
     * @param other - the InjectionArgument whose value we flexibly copy if possible.
     *
     * @return 0 if we could set from other's value, 1 if incompatible
     **/
    nvmlReturn_t SetValueFrom(const InjectionArgument &other);

    injectionArgType_t GetType() const
    {
        return m_type;
    }

    simpleValue_t GetSimpleValue() const
    {
        return m_value;
    }

    void Clear()
    {
        memset(&m_value, 0, sizeof(m_value));
    }

    int Compare(const InjectionArgument &other) const;

    bool operator<(const InjectionArgument &other) const
    {
        return this->Compare(other) == -1;
    }

    bool operator==(const InjectionArgument &other) const
    {
        return this->Compare(other) == 0;
    }

    bool IsEmpty() const
    {
        return m_type == InjectionArgCount;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(char *Str, bool inHeap = false)
        : m_type(INJECTION_CHAR_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Str = Str;
    }
    InjectionArgument(char Char)
        : m_type(INJECTION_CHAR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Char = Char;
    }
    InjectionArgument(char *Str, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CHAR_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Str = Str;
    }

    char *AsStr() const
    {
        return m_value.Str;
    }

    char const &AsChar() const
    {
        return m_value.Char;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(double *DoublePtr, bool inHeap = false)
        : m_type(INJECTION_DOUBLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DoublePtr = DoublePtr;
    }
    InjectionArgument(double Double)
        : m_type(INJECTION_DOUBLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Double = Double;
    }
    InjectionArgument(double *DoublePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DOUBLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DoublePtr = DoublePtr;
    }

    double *AsDoublePtr() const
    {
        return m_value.DoublePtr;
    }

    double const &AsDouble() const
    {
        return m_value.Double;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(int *IntPtr, bool inHeap = false)
        : m_type(INJECTION_INT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.IntPtr = IntPtr;
    }
    InjectionArgument(int Int)
        : m_type(INJECTION_INT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Int = Int;
    }
    InjectionArgument(int *IntPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_INT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.IntPtr = IntPtr;
    }

    int *AsIntPtr() const
    {
        return m_value.IntPtr;
    }

    int const &AsInt() const
    {
        return m_value.Int;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(long *LongPtr, bool inHeap = false)
        : m_type(INJECTION_LONG_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LongPtr = LongPtr;
    }
    InjectionArgument(long Long)
        : m_type(INJECTION_LONG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Long = Long;
    }
    InjectionArgument(long *LongPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_LONG_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LongPtr = LongPtr;
    }

    long *AsLongPtr() const
    {
        return m_value.LongPtr;
    }

    long const &AsLong() const
    {
        return m_value.Long;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(long long *LongLongPtr, bool inHeap = false)
        : m_type(INJECTION_LONG_LONG_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LongLongPtr = LongLongPtr;
    }
    InjectionArgument(long long LongLong)
        : m_type(INJECTION_LONG_LONG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LongLong = LongLong;
    }
    InjectionArgument(long long *LongLongPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_LONG_LONG_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LongLongPtr = LongLongPtr;
    }

    long long *AsLongLongPtr() const
    {
        return m_value.LongLongPtr;
    }

    long long const &AsLongLong() const
    {
        return m_value.LongLong;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlAccountingStats_t *AccountingStatsPtr, bool inHeap = false)
        : m_type(INJECTION_ACCOUNTINGSTATS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.AccountingStatsPtr = AccountingStatsPtr;
    }
    InjectionArgument(nvmlAccountingStats_t AccountingStats)
        : m_type(INJECTION_ACCOUNTINGSTATS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.AccountingStats = AccountingStats;
    }
    InjectionArgument(nvmlAccountingStats_t *AccountingStatsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ACCOUNTINGSTATS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.AccountingStatsPtr = AccountingStatsPtr;
    }

    nvmlAccountingStats_t *AsAccountingStatsPtr() const
    {
        return m_value.AccountingStatsPtr;
    }

    nvmlAccountingStats_t const &AsAccountingStats() const
    {
        return m_value.AccountingStats;
    }

    nvmlAffinityScope_t *AsAffinityScopePtr() const
    {
        return static_cast<nvmlAffinityScope_t *>(m_value.UIntPtr);
    }

    nvmlAffinityScope_t AsAffinityScope() const
    {
        return static_cast<nvmlAffinityScope_t>(m_value.UInt);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBAR1Memory_t *BAR1MemoryPtr, bool inHeap = false)
        : m_type(INJECTION_BAR1MEMORY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BAR1MemoryPtr = BAR1MemoryPtr;
    }
    InjectionArgument(nvmlBAR1Memory_t BAR1Memory)
        : m_type(INJECTION_BAR1MEMORY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BAR1Memory = BAR1Memory;
    }
    InjectionArgument(nvmlBAR1Memory_t *BAR1MemoryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BAR1MEMORY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BAR1MemoryPtr = BAR1MemoryPtr;
    }

    nvmlBAR1Memory_t *AsBAR1MemoryPtr() const
    {
        return m_value.BAR1MemoryPtr;
    }

    nvmlBAR1Memory_t const &AsBAR1Memory() const
    {
        return m_value.BAR1Memory;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBrandType_t *BrandTypePtr, bool inHeap = false)
        : m_type(INJECTION_BRANDTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BrandTypePtr = BrandTypePtr;
    }
    InjectionArgument(nvmlBrandType_t BrandType)
        : m_type(INJECTION_BRANDTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BrandType = BrandType;
    }
    InjectionArgument(nvmlBrandType_t *BrandTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BRANDTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BrandTypePtr = BrandTypePtr;
    }

    nvmlBrandType_t *AsBrandTypePtr() const
    {
        return m_value.BrandTypePtr;
    }

    nvmlBrandType_t const &AsBrandType() const
    {
        return m_value.BrandType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBridgeChipHierarchy_t *BridgeChipHierarchyPtr, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPHIERARCHY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipHierarchyPtr = BridgeChipHierarchyPtr;
    }
    InjectionArgument(nvmlBridgeChipHierarchy_t BridgeChipHierarchy)
        : m_type(INJECTION_BRIDGECHIPHIERARCHY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipHierarchy = BridgeChipHierarchy;
    }
    InjectionArgument(nvmlBridgeChipHierarchy_t *BridgeChipHierarchyPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPHIERARCHY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipHierarchyPtr = BridgeChipHierarchyPtr;
    }

    nvmlBridgeChipHierarchy_t *AsBridgeChipHierarchyPtr() const
    {
        return m_value.BridgeChipHierarchyPtr;
    }

    nvmlBridgeChipHierarchy_t const &AsBridgeChipHierarchy() const
    {
        return m_value.BridgeChipHierarchy;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBridgeChipInfo_t *BridgeChipInfoPtr, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipInfoPtr = BridgeChipInfoPtr;
    }
    InjectionArgument(nvmlBridgeChipInfo_t BridgeChipInfo)
        : m_type(INJECTION_BRIDGECHIPINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipInfo = BridgeChipInfo;
    }
    InjectionArgument(nvmlBridgeChipInfo_t *BridgeChipInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipInfoPtr = BridgeChipInfoPtr;
    }

    nvmlBridgeChipInfo_t *AsBridgeChipInfoPtr() const
    {
        return m_value.BridgeChipInfoPtr;
    }

    nvmlBridgeChipInfo_t const &AsBridgeChipInfo() const
    {
        return m_value.BridgeChipInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlBridgeChipType_t *BridgeChipTypePtr, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipTypePtr = BridgeChipTypePtr;
    }
    InjectionArgument(nvmlBridgeChipType_t BridgeChipType)
        : m_type(INJECTION_BRIDGECHIPTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipType = BridgeChipType;
    }
    InjectionArgument(nvmlBridgeChipType_t *BridgeChipTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_BRIDGECHIPTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.BridgeChipTypePtr = BridgeChipTypePtr;
    }

    nvmlBridgeChipType_t *AsBridgeChipTypePtr() const
    {
        return m_value.BridgeChipTypePtr;
    }

    nvmlBridgeChipType_t const &AsBridgeChipType() const
    {
        return m_value.BridgeChipType;
    }

    nvmlBusType_t *AsBusTypePtr() const
    {
        return static_cast<nvmlBusType_t *>(m_value.UIntPtr);
    }

    nvmlBusType_t AsBusType() const
    {
        return static_cast<nvmlBusType_t>(m_value.UInt);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlC2cModeInfo_v1_t *C2cModeInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_C2CMODEINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.C2cModeInfo_v1Ptr = C2cModeInfo_v1Ptr;
    }
    InjectionArgument(nvmlC2cModeInfo_v1_t C2cModeInfo_v1)
        : m_type(INJECTION_C2CMODEINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.C2cModeInfo_v1 = C2cModeInfo_v1;
    }
    InjectionArgument(nvmlC2cModeInfo_v1_t *C2cModeInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_C2CMODEINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.C2cModeInfo_v1Ptr = C2cModeInfo_v1Ptr;
    }

    nvmlC2cModeInfo_v1_t *AsC2cModeInfo_v1Ptr() const
    {
        return m_value.C2cModeInfo_v1Ptr;
    }

    nvmlC2cModeInfo_v1_t const &AsC2cModeInfo_v1() const
    {
        return m_value.C2cModeInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClkMonFaultInfo_t *ClkMonFaultInfoPtr, bool inHeap = false)
        : m_type(INJECTION_CLKMONFAULTINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClkMonFaultInfoPtr = ClkMonFaultInfoPtr;
    }
    InjectionArgument(nvmlClkMonFaultInfo_t ClkMonFaultInfo)
        : m_type(INJECTION_CLKMONFAULTINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClkMonFaultInfo = ClkMonFaultInfo;
    }
    InjectionArgument(nvmlClkMonFaultInfo_t *ClkMonFaultInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CLKMONFAULTINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClkMonFaultInfoPtr = ClkMonFaultInfoPtr;
    }

    nvmlClkMonFaultInfo_t *AsClkMonFaultInfoPtr() const
    {
        return m_value.ClkMonFaultInfoPtr;
    }

    nvmlClkMonFaultInfo_t const &AsClkMonFaultInfo() const
    {
        return m_value.ClkMonFaultInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClkMonStatus_t *ClkMonStatusPtr, bool inHeap = false)
        : m_type(INJECTION_CLKMONSTATUS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClkMonStatusPtr = ClkMonStatusPtr;
    }
    InjectionArgument(nvmlClkMonStatus_t ClkMonStatus)
        : m_type(INJECTION_CLKMONSTATUS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClkMonStatus = ClkMonStatus;
    }
    InjectionArgument(nvmlClkMonStatus_t *ClkMonStatusPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CLKMONSTATUS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClkMonStatusPtr = ClkMonStatusPtr;
    }

    nvmlClkMonStatus_t *AsClkMonStatusPtr() const
    {
        return m_value.ClkMonStatusPtr;
    }

    nvmlClkMonStatus_t const &AsClkMonStatus() const
    {
        return m_value.ClkMonStatus;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClockId_t *ClockIdPtr, bool inHeap = false)
        : m_type(INJECTION_CLOCKID_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockIdPtr = ClockIdPtr;
    }
    InjectionArgument(nvmlClockId_t ClockId)
        : m_type(INJECTION_CLOCKID)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockId = ClockId;
    }
    InjectionArgument(nvmlClockId_t *ClockIdPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CLOCKID_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockIdPtr = ClockIdPtr;
    }

    nvmlClockId_t *AsClockIdPtr() const
    {
        return m_value.ClockIdPtr;
    }

    nvmlClockId_t const &AsClockId() const
    {
        return m_value.ClockId;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClockLimitId_t *ClockLimitIdPtr, bool inHeap = false)
        : m_type(INJECTION_CLOCKLIMITID_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockLimitIdPtr = ClockLimitIdPtr;
    }
    InjectionArgument(nvmlClockLimitId_t ClockLimitId)
        : m_type(INJECTION_CLOCKLIMITID)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockLimitId = ClockLimitId;
    }
    InjectionArgument(nvmlClockLimitId_t *ClockLimitIdPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CLOCKLIMITID_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockLimitIdPtr = ClockLimitIdPtr;
    }

    nvmlClockLimitId_t *AsClockLimitIdPtr() const
    {
        return m_value.ClockLimitIdPtr;
    }

    nvmlClockLimitId_t const &AsClockLimitId() const
    {
        return m_value.ClockLimitId;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClockOffset_t *ClockOffsetPtr, bool inHeap = false)
        : m_type(INJECTION_CLOCKOFFSET_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockOffsetPtr = ClockOffsetPtr;
    }
    InjectionArgument(nvmlClockOffset_t ClockOffset)
        : m_type(INJECTION_CLOCKOFFSET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockOffset = ClockOffset;
    }
    InjectionArgument(nvmlClockOffset_t *ClockOffsetPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CLOCKOFFSET_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockOffsetPtr = ClockOffsetPtr;
    }

    nvmlClockOffset_t *AsClockOffsetPtr() const
    {
        return m_value.ClockOffsetPtr;
    }

    nvmlClockOffset_t const &AsClockOffset() const
    {
        return m_value.ClockOffset;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlClockType_t *ClockTypePtr, bool inHeap = false)
        : m_type(INJECTION_CLOCKTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockTypePtr = ClockTypePtr;
    }
    InjectionArgument(nvmlClockType_t ClockType)
        : m_type(INJECTION_CLOCKTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockType = ClockType;
    }
    InjectionArgument(nvmlClockType_t *ClockTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CLOCKTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ClockTypePtr = ClockTypePtr;
    }

    nvmlClockType_t *AsClockTypePtr() const
    {
        return m_value.ClockTypePtr;
    }

    nvmlClockType_t const &AsClockType() const
    {
        return m_value.ClockType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceInfo_t *ComputeInstanceInfoPtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceInfoPtr = ComputeInstanceInfoPtr;
    }
    InjectionArgument(nvmlComputeInstanceInfo_t ComputeInstanceInfo)
        : m_type(INJECTION_COMPUTEINSTANCEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceInfo = ComputeInstanceInfo;
    }
    InjectionArgument(nvmlComputeInstanceInfo_t *ComputeInstanceInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceInfoPtr = ComputeInstanceInfoPtr;
    }

    nvmlComputeInstanceInfo_t *AsComputeInstanceInfoPtr() const
    {
        return m_value.ComputeInstanceInfoPtr;
    }

    nvmlComputeInstanceInfo_t const &AsComputeInstanceInfo() const
    {
        return m_value.ComputeInstanceInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstancePlacement_t *ComputeInstancePlacementPtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPLACEMENT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstancePlacementPtr = ComputeInstancePlacementPtr;
    }
    InjectionArgument(nvmlComputeInstancePlacement_t ComputeInstancePlacement)
        : m_type(INJECTION_COMPUTEINSTANCEPLACEMENT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstancePlacement = ComputeInstancePlacement;
    }
    InjectionArgument(nvmlComputeInstancePlacement_t *ComputeInstancePlacementPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPLACEMENT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstancePlacementPtr = ComputeInstancePlacementPtr;
    }

    nvmlComputeInstancePlacement_t *AsComputeInstancePlacementPtr() const
    {
        return m_value.ComputeInstancePlacementPtr;
    }

    nvmlComputeInstancePlacement_t const &AsComputeInstancePlacement() const
    {
        return m_value.ComputeInstancePlacement;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceProfileInfo_t *ComputeInstanceProfileInfoPtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfoPtr = ComputeInstanceProfileInfoPtr;
    }
    InjectionArgument(nvmlComputeInstanceProfileInfo_t ComputeInstanceProfileInfo)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfo = ComputeInstanceProfileInfo;
    }
    InjectionArgument(nvmlComputeInstanceProfileInfo_t *ComputeInstanceProfileInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfoPtr = ComputeInstanceProfileInfoPtr;
    }

    nvmlComputeInstanceProfileInfo_t *AsComputeInstanceProfileInfoPtr() const
    {
        return m_value.ComputeInstanceProfileInfoPtr;
    }

    nvmlComputeInstanceProfileInfo_t const &AsComputeInstanceProfileInfo() const
    {
        return m_value.ComputeInstanceProfileInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceProfileInfo_v2_t *ComputeInstanceProfileInfo_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfo_v2Ptr = ComputeInstanceProfileInfo_v2Ptr;
    }
    InjectionArgument(nvmlComputeInstanceProfileInfo_v2_t ComputeInstanceProfileInfo_v2)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfo_v2 = ComputeInstanceProfileInfo_v2;
    }
    InjectionArgument(nvmlComputeInstanceProfileInfo_v2_t *ComputeInstanceProfileInfo_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfo_v2Ptr = ComputeInstanceProfileInfo_v2Ptr;
    }

    nvmlComputeInstanceProfileInfo_v2_t *AsComputeInstanceProfileInfo_v2Ptr() const
    {
        return m_value.ComputeInstanceProfileInfo_v2Ptr;
    }

    nvmlComputeInstanceProfileInfo_v2_t const &AsComputeInstanceProfileInfo_v2() const
    {
        return m_value.ComputeInstanceProfileInfo_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstanceProfileInfo_v3_t *ComputeInstanceProfileInfo_v3Ptr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V3_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfo_v3Ptr = ComputeInstanceProfileInfo_v3Ptr;
    }
    InjectionArgument(nvmlComputeInstanceProfileInfo_v3_t ComputeInstanceProfileInfo_v3)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V3)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfo_v3 = ComputeInstanceProfileInfo_v3;
    }
    InjectionArgument(nvmlComputeInstanceProfileInfo_v3_t *ComputeInstanceProfileInfo_v3Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V3_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstanceProfileInfo_v3Ptr = ComputeInstanceProfileInfo_v3Ptr;
    }

    nvmlComputeInstanceProfileInfo_v3_t *AsComputeInstanceProfileInfo_v3Ptr() const
    {
        return m_value.ComputeInstanceProfileInfo_v3Ptr;
    }

    nvmlComputeInstanceProfileInfo_v3_t const &AsComputeInstanceProfileInfo_v3() const
    {
        return m_value.ComputeInstanceProfileInfo_v3;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeInstance_t *ComputeInstancePtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstancePtr = ComputeInstancePtr;
    }
    InjectionArgument(nvmlComputeInstance_t ComputeInstance)
        : m_type(INJECTION_COMPUTEINSTANCE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstance = ComputeInstance;
    }
    InjectionArgument(nvmlComputeInstance_t *ComputeInstancePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEINSTANCE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeInstancePtr = ComputeInstancePtr;
    }

    nvmlComputeInstance_t *AsComputeInstancePtr() const
    {
        return m_value.ComputeInstancePtr;
    }

    nvmlComputeInstance_t const &AsComputeInstance() const
    {
        return m_value.ComputeInstance;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlComputeMode_t *ComputeModePtr, bool inHeap = false)
        : m_type(INJECTION_COMPUTEMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeModePtr = ComputeModePtr;
    }
    InjectionArgument(nvmlComputeMode_t ComputeMode)
        : m_type(INJECTION_COMPUTEMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeMode = ComputeMode;
    }
    InjectionArgument(nvmlComputeMode_t *ComputeModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COMPUTEMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ComputeModePtr = ComputeModePtr;
    }

    nvmlComputeMode_t *AsComputeModePtr() const
    {
        return m_value.ComputeModePtr;
    }

    nvmlComputeMode_t const &AsComputeMode() const
    {
        return m_value.ComputeMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeGetKeyRotationThresholdInfo_v1_t *ConfComputeGetKeyRotationThresholdInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEGETKEYROTATIONTHRESHOLDINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr = ConfComputeGetKeyRotationThresholdInfo_v1Ptr;
    }
    InjectionArgument(nvmlConfComputeGetKeyRotationThresholdInfo_v1_t ConfComputeGetKeyRotationThresholdInfo_v1)
        : m_type(INJECTION_CONFCOMPUTEGETKEYROTATIONTHRESHOLDINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGetKeyRotationThresholdInfo_v1 = ConfComputeGetKeyRotationThresholdInfo_v1;
    }
    InjectionArgument(nvmlConfComputeGetKeyRotationThresholdInfo_v1_t *ConfComputeGetKeyRotationThresholdInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEGETKEYROTATIONTHRESHOLDINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr = ConfComputeGetKeyRotationThresholdInfo_v1Ptr;
    }

    nvmlConfComputeGetKeyRotationThresholdInfo_v1_t *AsConfComputeGetKeyRotationThresholdInfo_v1Ptr() const
    {
        return m_value.ConfComputeGetKeyRotationThresholdInfo_v1Ptr;
    }

    nvmlConfComputeGetKeyRotationThresholdInfo_v1_t const &AsConfComputeGetKeyRotationThresholdInfo_v1() const
    {
        return m_value.ConfComputeGetKeyRotationThresholdInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeGpuAttestationReport_t *ConfComputeGpuAttestationReportPtr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEGPUATTESTATIONREPORT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGpuAttestationReportPtr = ConfComputeGpuAttestationReportPtr;
    }
    InjectionArgument(nvmlConfComputeGpuAttestationReport_t ConfComputeGpuAttestationReport)
        : m_type(INJECTION_CONFCOMPUTEGPUATTESTATIONREPORT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGpuAttestationReport = ConfComputeGpuAttestationReport;
    }
    InjectionArgument(nvmlConfComputeGpuAttestationReport_t *ConfComputeGpuAttestationReportPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEGPUATTESTATIONREPORT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGpuAttestationReportPtr = ConfComputeGpuAttestationReportPtr;
    }

    nvmlConfComputeGpuAttestationReport_t *AsConfComputeGpuAttestationReportPtr() const
    {
        return m_value.ConfComputeGpuAttestationReportPtr;
    }

    nvmlConfComputeGpuAttestationReport_t const &AsConfComputeGpuAttestationReport() const
    {
        return m_value.ConfComputeGpuAttestationReport;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeGpuCertificate_t *ConfComputeGpuCertificatePtr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEGPUCERTIFICATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGpuCertificatePtr = ConfComputeGpuCertificatePtr;
    }
    InjectionArgument(nvmlConfComputeGpuCertificate_t ConfComputeGpuCertificate)
        : m_type(INJECTION_CONFCOMPUTEGPUCERTIFICATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGpuCertificate = ConfComputeGpuCertificate;
    }
    InjectionArgument(nvmlConfComputeGpuCertificate_t *ConfComputeGpuCertificatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEGPUCERTIFICATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeGpuCertificatePtr = ConfComputeGpuCertificatePtr;
    }

    nvmlConfComputeGpuCertificate_t *AsConfComputeGpuCertificatePtr() const
    {
        return m_value.ConfComputeGpuCertificatePtr;
    }

    nvmlConfComputeGpuCertificate_t const &AsConfComputeGpuCertificate() const
    {
        return m_value.ConfComputeGpuCertificate;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeMemSizeInfo_t *ConfComputeMemSizeInfoPtr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEMEMSIZEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeMemSizeInfoPtr = ConfComputeMemSizeInfoPtr;
    }
    InjectionArgument(nvmlConfComputeMemSizeInfo_t ConfComputeMemSizeInfo)
        : m_type(INJECTION_CONFCOMPUTEMEMSIZEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeMemSizeInfo = ConfComputeMemSizeInfo;
    }
    InjectionArgument(nvmlConfComputeMemSizeInfo_t *ConfComputeMemSizeInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTEMEMSIZEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeMemSizeInfoPtr = ConfComputeMemSizeInfoPtr;
    }

    nvmlConfComputeMemSizeInfo_t *AsConfComputeMemSizeInfoPtr() const
    {
        return m_value.ConfComputeMemSizeInfoPtr;
    }

    nvmlConfComputeMemSizeInfo_t const &AsConfComputeMemSizeInfo() const
    {
        return m_value.ConfComputeMemSizeInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeSetKeyRotationThresholdInfo_v1_t *ConfComputeSetKeyRotationThresholdInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESETKEYROTATIONTHRESHOLDINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr = ConfComputeSetKeyRotationThresholdInfo_v1Ptr;
    }
    InjectionArgument(nvmlConfComputeSetKeyRotationThresholdInfo_v1_t ConfComputeSetKeyRotationThresholdInfo_v1)
        : m_type(INJECTION_CONFCOMPUTESETKEYROTATIONTHRESHOLDINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSetKeyRotationThresholdInfo_v1 = ConfComputeSetKeyRotationThresholdInfo_v1;
    }
    InjectionArgument(nvmlConfComputeSetKeyRotationThresholdInfo_v1_t *ConfComputeSetKeyRotationThresholdInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESETKEYROTATIONTHRESHOLDINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr = ConfComputeSetKeyRotationThresholdInfo_v1Ptr;
    }

    nvmlConfComputeSetKeyRotationThresholdInfo_v1_t *AsConfComputeSetKeyRotationThresholdInfo_v1Ptr() const
    {
        return m_value.ConfComputeSetKeyRotationThresholdInfo_v1Ptr;
    }

    nvmlConfComputeSetKeyRotationThresholdInfo_v1_t const &AsConfComputeSetKeyRotationThresholdInfo_v1() const
    {
        return m_value.ConfComputeSetKeyRotationThresholdInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeSystemCaps_t *ConfComputeSystemCapsPtr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESYSTEMCAPS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSystemCapsPtr = ConfComputeSystemCapsPtr;
    }
    InjectionArgument(nvmlConfComputeSystemCaps_t ConfComputeSystemCaps)
        : m_type(INJECTION_CONFCOMPUTESYSTEMCAPS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSystemCaps = ConfComputeSystemCaps;
    }
    InjectionArgument(nvmlConfComputeSystemCaps_t *ConfComputeSystemCapsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESYSTEMCAPS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSystemCapsPtr = ConfComputeSystemCapsPtr;
    }

    nvmlConfComputeSystemCaps_t *AsConfComputeSystemCapsPtr() const
    {
        return m_value.ConfComputeSystemCapsPtr;
    }

    nvmlConfComputeSystemCaps_t const &AsConfComputeSystemCaps() const
    {
        return m_value.ConfComputeSystemCaps;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlConfComputeSystemState_t *ConfComputeSystemStatePtr, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESYSTEMSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSystemStatePtr = ConfComputeSystemStatePtr;
    }
    InjectionArgument(nvmlConfComputeSystemState_t ConfComputeSystemState)
        : m_type(INJECTION_CONFCOMPUTESYSTEMSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSystemState = ConfComputeSystemState;
    }
    InjectionArgument(nvmlConfComputeSystemState_t *ConfComputeSystemStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_CONFCOMPUTESYSTEMSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConfComputeSystemStatePtr = ConfComputeSystemStatePtr;
    }

    nvmlConfComputeSystemState_t *AsConfComputeSystemStatePtr() const
    {
        return m_value.ConfComputeSystemStatePtr;
    }

    nvmlConfComputeSystemState_t const &AsConfComputeSystemState() const
    {
        return m_value.ConfComputeSystemState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlCoolerControl_t *CoolerControlPtr, bool inHeap = false)
        : m_type(INJECTION_COOLERCONTROL_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerControlPtr = CoolerControlPtr;
    }
    InjectionArgument(nvmlCoolerControl_t CoolerControl)
        : m_type(INJECTION_COOLERCONTROL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerControl = CoolerControl;
    }
    InjectionArgument(nvmlCoolerControl_t *CoolerControlPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COOLERCONTROL_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerControlPtr = CoolerControlPtr;
    }

    nvmlCoolerControl_t *AsCoolerControlPtr() const
    {
        return m_value.CoolerControlPtr;
    }

    nvmlCoolerControl_t const &AsCoolerControl() const
    {
        return m_value.CoolerControl;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlCoolerInfo_t *CoolerInfoPtr, bool inHeap = false)
        : m_type(INJECTION_COOLERINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerInfoPtr = CoolerInfoPtr;
    }
    InjectionArgument(nvmlCoolerInfo_t CoolerInfo)
        : m_type(INJECTION_COOLERINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerInfo = CoolerInfo;
    }
    InjectionArgument(nvmlCoolerInfo_t *CoolerInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COOLERINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerInfoPtr = CoolerInfoPtr;
    }

    nvmlCoolerInfo_t *AsCoolerInfoPtr() const
    {
        return m_value.CoolerInfoPtr;
    }

    nvmlCoolerInfo_t const &AsCoolerInfo() const
    {
        return m_value.CoolerInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlCoolerTarget_t *CoolerTargetPtr, bool inHeap = false)
        : m_type(INJECTION_COOLERTARGET_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerTargetPtr = CoolerTargetPtr;
    }
    InjectionArgument(nvmlCoolerTarget_t CoolerTarget)
        : m_type(INJECTION_COOLERTARGET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerTarget = CoolerTarget;
    }
    InjectionArgument(nvmlCoolerTarget_t *CoolerTargetPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_COOLERTARGET_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.CoolerTargetPtr = CoolerTargetPtr;
    }

    nvmlCoolerTarget_t *AsCoolerTargetPtr() const
    {
        return m_value.CoolerTargetPtr;
    }

    nvmlCoolerTarget_t const &AsCoolerTarget() const
    {
        return m_value.CoolerTarget;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDetachGpuState_t *DetachGpuStatePtr, bool inHeap = false)
        : m_type(INJECTION_DETACHGPUSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DetachGpuStatePtr = DetachGpuStatePtr;
    }
    InjectionArgument(nvmlDetachGpuState_t DetachGpuState)
        : m_type(INJECTION_DETACHGPUSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DetachGpuState = DetachGpuState;
    }
    InjectionArgument(nvmlDetachGpuState_t *DetachGpuStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DETACHGPUSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DetachGpuStatePtr = DetachGpuStatePtr;
    }

    nvmlDetachGpuState_t *AsDetachGpuStatePtr() const
    {
        return m_value.DetachGpuStatePtr;
    }

    nvmlDetachGpuState_t const &AsDetachGpuState() const
    {
        return m_value.DetachGpuState;
    }

    nvmlDeviceArchitecture_t *AsDeviceArchitecturePtr() const
    {
        return static_cast<nvmlDeviceArchitecture_t *>(m_value.UIntPtr);
    }

    nvmlDeviceArchitecture_t AsDeviceArchitecture() const
    {
        return static_cast<nvmlDeviceArchitecture_t>(m_value.UInt);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDeviceAttributes_t *DeviceAttributesPtr, bool inHeap = false)
        : m_type(INJECTION_DEVICEATTRIBUTES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceAttributesPtr = DeviceAttributesPtr;
    }
    InjectionArgument(nvmlDeviceAttributes_t DeviceAttributes)
        : m_type(INJECTION_DEVICEATTRIBUTES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceAttributes = DeviceAttributes;
    }
    InjectionArgument(nvmlDeviceAttributes_t *DeviceAttributesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICEATTRIBUTES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceAttributesPtr = DeviceAttributesPtr;
    }

    nvmlDeviceAttributes_t *AsDeviceAttributesPtr() const
    {
        return m_value.DeviceAttributesPtr;
    }

    nvmlDeviceAttributes_t const &AsDeviceAttributes() const
    {
        return m_value.DeviceAttributes;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDeviceCapabilities_t *DeviceCapabilitiesPtr, bool inHeap = false)
        : m_type(INJECTION_DEVICECAPABILITIES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceCapabilitiesPtr = DeviceCapabilitiesPtr;
    }
    InjectionArgument(nvmlDeviceCapabilities_t DeviceCapabilities)
        : m_type(INJECTION_DEVICECAPABILITIES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceCapabilities = DeviceCapabilities;
    }
    InjectionArgument(nvmlDeviceCapabilities_t *DeviceCapabilitiesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICECAPABILITIES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceCapabilitiesPtr = DeviceCapabilitiesPtr;
    }

    nvmlDeviceCapabilities_t *AsDeviceCapabilitiesPtr() const
    {
        return m_value.DeviceCapabilitiesPtr;
    }

    nvmlDeviceCapabilities_t const &AsDeviceCapabilities() const
    {
        return m_value.DeviceCapabilities;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDeviceCurrentClockFreqs_t *DeviceCurrentClockFreqsPtr, bool inHeap = false)
        : m_type(INJECTION_DEVICECURRENTCLOCKFREQS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceCurrentClockFreqsPtr = DeviceCurrentClockFreqsPtr;
    }
    InjectionArgument(nvmlDeviceCurrentClockFreqs_t DeviceCurrentClockFreqs)
        : m_type(INJECTION_DEVICECURRENTCLOCKFREQS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceCurrentClockFreqs = DeviceCurrentClockFreqs;
    }
    InjectionArgument(nvmlDeviceCurrentClockFreqs_t *DeviceCurrentClockFreqsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICECURRENTCLOCKFREQS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceCurrentClockFreqsPtr = DeviceCurrentClockFreqsPtr;
    }

    nvmlDeviceCurrentClockFreqs_t *AsDeviceCurrentClockFreqsPtr() const
    {
        return m_value.DeviceCurrentClockFreqsPtr;
    }

    nvmlDeviceCurrentClockFreqs_t const &AsDeviceCurrentClockFreqs() const
    {
        return m_value.DeviceCurrentClockFreqs;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDeviceGpuRecoveryAction_t *DeviceGpuRecoveryActionPtr, bool inHeap = false)
        : m_type(INJECTION_DEVICEGPURECOVERYACTION_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceGpuRecoveryActionPtr = DeviceGpuRecoveryActionPtr;
    }
    InjectionArgument(nvmlDeviceGpuRecoveryAction_t DeviceGpuRecoveryAction)
        : m_type(INJECTION_DEVICEGPURECOVERYACTION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceGpuRecoveryAction = DeviceGpuRecoveryAction;
    }
    InjectionArgument(nvmlDeviceGpuRecoveryAction_t *DeviceGpuRecoveryActionPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICEGPURECOVERYACTION_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceGpuRecoveryActionPtr = DeviceGpuRecoveryActionPtr;
    }

    nvmlDeviceGpuRecoveryAction_t *AsDeviceGpuRecoveryActionPtr() const
    {
        return m_value.DeviceGpuRecoveryActionPtr;
    }

    nvmlDeviceGpuRecoveryAction_t const &AsDeviceGpuRecoveryAction() const
    {
        return m_value.DeviceGpuRecoveryAction;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDevicePerfModes_t *DevicePerfModesPtr, bool inHeap = false)
        : m_type(INJECTION_DEVICEPERFMODES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DevicePerfModesPtr = DevicePerfModesPtr;
    }
    InjectionArgument(nvmlDevicePerfModes_t DevicePerfModes)
        : m_type(INJECTION_DEVICEPERFMODES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DevicePerfModes = DevicePerfModes;
    }
    InjectionArgument(nvmlDevicePerfModes_t *DevicePerfModesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICEPERFMODES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DevicePerfModesPtr = DevicePerfModesPtr;
    }

    nvmlDevicePerfModes_t *AsDevicePerfModesPtr() const
    {
        return m_value.DevicePerfModesPtr;
    }

    nvmlDevicePerfModes_t const &AsDevicePerfModes() const
    {
        return m_value.DevicePerfModes;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDeviceVgpuCapability_t *DeviceVgpuCapabilityPtr, bool inHeap = false)
        : m_type(INJECTION_DEVICEVGPUCAPABILITY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceVgpuCapabilityPtr = DeviceVgpuCapabilityPtr;
    }
    InjectionArgument(nvmlDeviceVgpuCapability_t DeviceVgpuCapability)
        : m_type(INJECTION_DEVICEVGPUCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceVgpuCapability = DeviceVgpuCapability;
    }
    InjectionArgument(nvmlDeviceVgpuCapability_t *DeviceVgpuCapabilityPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICEVGPUCAPABILITY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DeviceVgpuCapabilityPtr = DeviceVgpuCapabilityPtr;
    }

    nvmlDeviceVgpuCapability_t *AsDeviceVgpuCapabilityPtr() const
    {
        return m_value.DeviceVgpuCapabilityPtr;
    }

    nvmlDeviceVgpuCapability_t const &AsDeviceVgpuCapability() const
    {
        return m_value.DeviceVgpuCapability;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDevice_t *DevicePtr, bool inHeap = false)
        : m_type(INJECTION_DEVICE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DevicePtr = DevicePtr;
    }
    InjectionArgument(nvmlDevice_t Device)
        : m_type(INJECTION_DEVICE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Device = Device;
    }
    InjectionArgument(nvmlDevice_t *DevicePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DEVICE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DevicePtr = DevicePtr;
    }

    nvmlDevice_t *AsDevicePtr() const
    {
        return m_value.DevicePtr;
    }

    nvmlDevice_t const &AsDevice() const
    {
        return m_value.Device;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlDriverModel_t *DriverModelPtr, bool inHeap = false)
        : m_type(INJECTION_DRIVERMODEL_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DriverModelPtr = DriverModelPtr;
    }
    InjectionArgument(nvmlDriverModel_t DriverModel)
        : m_type(INJECTION_DRIVERMODEL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DriverModel = DriverModel;
    }
    InjectionArgument(nvmlDriverModel_t *DriverModelPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_DRIVERMODEL_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.DriverModelPtr = DriverModelPtr;
    }

    nvmlDriverModel_t *AsDriverModelPtr() const
    {
        return m_value.DriverModelPtr;
    }

    nvmlDriverModel_t const &AsDriverModel() const
    {
        return m_value.DriverModel;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEccCounterType_t *EccCounterTypePtr, bool inHeap = false)
        : m_type(INJECTION_ECCCOUNTERTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccCounterTypePtr = EccCounterTypePtr;
    }
    InjectionArgument(nvmlEccCounterType_t EccCounterType)
        : m_type(INJECTION_ECCCOUNTERTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccCounterType = EccCounterType;
    }
    InjectionArgument(nvmlEccCounterType_t *EccCounterTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ECCCOUNTERTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccCounterTypePtr = EccCounterTypePtr;
    }

    nvmlEccCounterType_t *AsEccCounterTypePtr() const
    {
        return m_value.EccCounterTypePtr;
    }

    nvmlEccCounterType_t const &AsEccCounterType() const
    {
        return m_value.EccCounterType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEccErrorCounts_t *EccErrorCountsPtr, bool inHeap = false)
        : m_type(INJECTION_ECCERRORCOUNTS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccErrorCountsPtr = EccErrorCountsPtr;
    }
    InjectionArgument(nvmlEccErrorCounts_t EccErrorCounts)
        : m_type(INJECTION_ECCERRORCOUNTS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccErrorCounts = EccErrorCounts;
    }
    InjectionArgument(nvmlEccErrorCounts_t *EccErrorCountsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ECCERRORCOUNTS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccErrorCountsPtr = EccErrorCountsPtr;
    }

    nvmlEccErrorCounts_t *AsEccErrorCountsPtr() const
    {
        return m_value.EccErrorCountsPtr;
    }

    nvmlEccErrorCounts_t const &AsEccErrorCounts() const
    {
        return m_value.EccErrorCounts;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEccSramErrorStatus_t *EccSramErrorStatusPtr, bool inHeap = false)
        : m_type(INJECTION_ECCSRAMERRORSTATUS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccSramErrorStatusPtr = EccSramErrorStatusPtr;
    }
    InjectionArgument(nvmlEccSramErrorStatus_t EccSramErrorStatus)
        : m_type(INJECTION_ECCSRAMERRORSTATUS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccSramErrorStatus = EccSramErrorStatus;
    }
    InjectionArgument(nvmlEccSramErrorStatus_t *EccSramErrorStatusPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ECCSRAMERRORSTATUS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EccSramErrorStatusPtr = EccSramErrorStatusPtr;
    }

    nvmlEccSramErrorStatus_t *AsEccSramErrorStatusPtr() const
    {
        return m_value.EccSramErrorStatusPtr;
    }

    nvmlEccSramErrorStatus_t const &AsEccSramErrorStatus() const
    {
        return m_value.EccSramErrorStatus;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEnableState_t *EnableStatePtr, bool inHeap = false)
        : m_type(INJECTION_ENABLESTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EnableStatePtr = EnableStatePtr;
    }
    InjectionArgument(nvmlEnableState_t EnableState)
        : m_type(INJECTION_ENABLESTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EnableState = EnableState;
    }
    InjectionArgument(nvmlEnableState_t *EnableStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ENABLESTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EnableStatePtr = EnableStatePtr;
    }

    nvmlEnableState_t *AsEnableStatePtr() const
    {
        return m_value.EnableStatePtr;
    }

    nvmlEnableState_t const &AsEnableState() const
    {
        return m_value.EnableState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEncoderSessionInfo_t *EncoderSessionInfoPtr, bool inHeap = false)
        : m_type(INJECTION_ENCODERSESSIONINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EncoderSessionInfoPtr = EncoderSessionInfoPtr;
    }
    InjectionArgument(nvmlEncoderSessionInfo_t EncoderSessionInfo)
        : m_type(INJECTION_ENCODERSESSIONINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EncoderSessionInfo = EncoderSessionInfo;
    }
    InjectionArgument(nvmlEncoderSessionInfo_t *EncoderSessionInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ENCODERSESSIONINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EncoderSessionInfoPtr = EncoderSessionInfoPtr;
    }

    nvmlEncoderSessionInfo_t *AsEncoderSessionInfoPtr() const
    {
        return m_value.EncoderSessionInfoPtr;
    }

    nvmlEncoderSessionInfo_t const &AsEncoderSessionInfo() const
    {
        return m_value.EncoderSessionInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEncoderType_t *EncoderTypePtr, bool inHeap = false)
        : m_type(INJECTION_ENCODERTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EncoderTypePtr = EncoderTypePtr;
    }
    InjectionArgument(nvmlEncoderType_t EncoderType)
        : m_type(INJECTION_ENCODERTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EncoderType = EncoderType;
    }
    InjectionArgument(nvmlEncoderType_t *EncoderTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ENCODERTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EncoderTypePtr = EncoderTypePtr;
    }

    nvmlEncoderType_t *AsEncoderTypePtr() const
    {
        return m_value.EncoderTypePtr;
    }

    nvmlEncoderType_t const &AsEncoderType() const
    {
        return m_value.EncoderType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEventData_t *EventDataPtr, bool inHeap = false)
        : m_type(INJECTION_EVENTDATA_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EventDataPtr = EventDataPtr;
    }
    InjectionArgument(nvmlEventData_t EventData)
        : m_type(INJECTION_EVENTDATA)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EventData = EventData;
    }
    InjectionArgument(nvmlEventData_t *EventDataPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_EVENTDATA_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EventDataPtr = EventDataPtr;
    }

    nvmlEventData_t *AsEventDataPtr() const
    {
        return m_value.EventDataPtr;
    }

    nvmlEventData_t const &AsEventData() const
    {
        return m_value.EventData;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlEventSet_t *EventSetPtr, bool inHeap = false)
        : m_type(INJECTION_EVENTSET_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EventSetPtr = EventSetPtr;
    }
    InjectionArgument(nvmlEventSet_t EventSet)
        : m_type(INJECTION_EVENTSET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EventSet = EventSet;
    }
    InjectionArgument(nvmlEventSet_t *EventSetPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_EVENTSET_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.EventSetPtr = EventSetPtr;
    }

    nvmlEventSet_t *AsEventSetPtr() const
    {
        return m_value.EventSetPtr;
    }

    nvmlEventSet_t const &AsEventSet() const
    {
        return m_value.EventSet;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlExcludedDeviceInfo_t *ExcludedDeviceInfoPtr, bool inHeap = false)
        : m_type(INJECTION_EXCLUDEDDEVICEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ExcludedDeviceInfoPtr = ExcludedDeviceInfoPtr;
    }
    InjectionArgument(nvmlExcludedDeviceInfo_t ExcludedDeviceInfo)
        : m_type(INJECTION_EXCLUDEDDEVICEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ExcludedDeviceInfo = ExcludedDeviceInfo;
    }
    InjectionArgument(nvmlExcludedDeviceInfo_t *ExcludedDeviceInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_EXCLUDEDDEVICEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ExcludedDeviceInfoPtr = ExcludedDeviceInfoPtr;
    }

    nvmlExcludedDeviceInfo_t *AsExcludedDeviceInfoPtr() const
    {
        return m_value.ExcludedDeviceInfoPtr;
    }

    nvmlExcludedDeviceInfo_t const &AsExcludedDeviceInfo() const
    {
        return m_value.ExcludedDeviceInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFBCSessionInfo_t *FBCSessionInfoPtr, bool inHeap = false)
        : m_type(INJECTION_FBCSESSIONINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCSessionInfoPtr = FBCSessionInfoPtr;
    }
    InjectionArgument(nvmlFBCSessionInfo_t FBCSessionInfo)
        : m_type(INJECTION_FBCSESSIONINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCSessionInfo = FBCSessionInfo;
    }
    InjectionArgument(nvmlFBCSessionInfo_t *FBCSessionInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FBCSESSIONINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCSessionInfoPtr = FBCSessionInfoPtr;
    }

    nvmlFBCSessionInfo_t *AsFBCSessionInfoPtr() const
    {
        return m_value.FBCSessionInfoPtr;
    }

    nvmlFBCSessionInfo_t const &AsFBCSessionInfo() const
    {
        return m_value.FBCSessionInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFBCSessionType_t *FBCSessionTypePtr, bool inHeap = false)
        : m_type(INJECTION_FBCSESSIONTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCSessionTypePtr = FBCSessionTypePtr;
    }
    InjectionArgument(nvmlFBCSessionType_t FBCSessionType)
        : m_type(INJECTION_FBCSESSIONTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCSessionType = FBCSessionType;
    }
    InjectionArgument(nvmlFBCSessionType_t *FBCSessionTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FBCSESSIONTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCSessionTypePtr = FBCSessionTypePtr;
    }

    nvmlFBCSessionType_t *AsFBCSessionTypePtr() const
    {
        return m_value.FBCSessionTypePtr;
    }

    nvmlFBCSessionType_t const &AsFBCSessionType() const
    {
        return m_value.FBCSessionType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFBCStats_t *FBCStatsPtr, bool inHeap = false)
        : m_type(INJECTION_FBCSTATS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCStatsPtr = FBCStatsPtr;
    }
    InjectionArgument(nvmlFBCStats_t FBCStats)
        : m_type(INJECTION_FBCSTATS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCStats = FBCStats;
    }
    InjectionArgument(nvmlFBCStats_t *FBCStatsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FBCSTATS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FBCStatsPtr = FBCStatsPtr;
    }

    nvmlFBCStats_t *AsFBCStatsPtr() const
    {
        return m_value.FBCStatsPtr;
    }

    nvmlFBCStats_t const &AsFBCStats() const
    {
        return m_value.FBCStats;
    }

    nvmlFanControlPolicy_t *AsFanControlPolicyPtr() const
    {
        return static_cast<nvmlFanControlPolicy_t *>(m_value.UIntPtr);
    }

    nvmlFanControlPolicy_t AsFanControlPolicy() const
    {
        return static_cast<nvmlFanControlPolicy_t>(m_value.UInt);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFanSpeedInfo_t *FanSpeedInfoPtr, bool inHeap = false)
        : m_type(INJECTION_FANSPEEDINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FanSpeedInfoPtr = FanSpeedInfoPtr;
    }
    InjectionArgument(nvmlFanSpeedInfo_t FanSpeedInfo)
        : m_type(INJECTION_FANSPEEDINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FanSpeedInfo = FanSpeedInfo;
    }
    InjectionArgument(nvmlFanSpeedInfo_t *FanSpeedInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FANSPEEDINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FanSpeedInfoPtr = FanSpeedInfoPtr;
    }

    nvmlFanSpeedInfo_t *AsFanSpeedInfoPtr() const
    {
        return m_value.FanSpeedInfoPtr;
    }

    nvmlFanSpeedInfo_t const &AsFanSpeedInfo() const
    {
        return m_value.FanSpeedInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFanState_t *FanStatePtr, bool inHeap = false)
        : m_type(INJECTION_FANSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FanStatePtr = FanStatePtr;
    }
    InjectionArgument(nvmlFanState_t FanState)
        : m_type(INJECTION_FANSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FanState = FanState;
    }
    InjectionArgument(nvmlFanState_t *FanStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FANSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FanStatePtr = FanStatePtr;
    }

    nvmlFanState_t *AsFanStatePtr() const
    {
        return m_value.FanStatePtr;
    }

    nvmlFanState_t const &AsFanState() const
    {
        return m_value.FanState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlFieldValue_t *FieldValuePtr, bool inHeap = false)
        : m_type(INJECTION_FIELDVALUE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FieldValuePtr = FieldValuePtr;
    }
    InjectionArgument(nvmlFieldValue_t FieldValue)
        : m_type(INJECTION_FIELDVALUE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FieldValue = FieldValue;
    }
    InjectionArgument(nvmlFieldValue_t *FieldValuePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_FIELDVALUE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.FieldValuePtr = FieldValuePtr;
    }

    nvmlFieldValue_t *AsFieldValuePtr() const
    {
        return m_value.FieldValuePtr;
    }

    nvmlFieldValue_t const &AsFieldValue() const
    {
        return m_value.FieldValue;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmMetricId_t *GpmMetricIdPtr, bool inHeap = false)
        : m_type(INJECTION_GPMMETRICID_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricIdPtr = GpmMetricIdPtr;
    }
    InjectionArgument(nvmlGpmMetricId_t GpmMetricId)
        : m_type(INJECTION_GPMMETRICID)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricId = GpmMetricId;
    }
    InjectionArgument(nvmlGpmMetricId_t *GpmMetricIdPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMMETRICID_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricIdPtr = GpmMetricIdPtr;
    }

    nvmlGpmMetricId_t *AsGpmMetricIdPtr() const
    {
        return m_value.GpmMetricIdPtr;
    }

    nvmlGpmMetricId_t const &AsGpmMetricId() const
    {
        return m_value.GpmMetricId;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmMetric_t *GpmMetricPtr, bool inHeap = false)
        : m_type(INJECTION_GPMMETRIC_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricPtr = GpmMetricPtr;
    }
    InjectionArgument(nvmlGpmMetric_t GpmMetric)
        : m_type(INJECTION_GPMMETRIC)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetric = GpmMetric;
    }
    InjectionArgument(nvmlGpmMetric_t *GpmMetricPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMMETRIC_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricPtr = GpmMetricPtr;
    }

    nvmlGpmMetric_t *AsGpmMetricPtr() const
    {
        return m_value.GpmMetricPtr;
    }

    nvmlGpmMetric_t const &AsGpmMetric() const
    {
        return m_value.GpmMetric;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmMetricsGet_t *GpmMetricsGetPtr, bool inHeap = false)
        : m_type(INJECTION_GPMMETRICSGET_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricsGetPtr = GpmMetricsGetPtr;
    }
    InjectionArgument(nvmlGpmMetricsGet_t GpmMetricsGet)
        : m_type(INJECTION_GPMMETRICSGET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricsGet = GpmMetricsGet;
    }
    InjectionArgument(nvmlGpmMetricsGet_t *GpmMetricsGetPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMMETRICSGET_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmMetricsGetPtr = GpmMetricsGetPtr;
    }

    nvmlGpmMetricsGet_t *AsGpmMetricsGetPtr() const
    {
        return m_value.GpmMetricsGetPtr;
    }

    nvmlGpmMetricsGet_t const &AsGpmMetricsGet() const
    {
        return m_value.GpmMetricsGet;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmSample_t *GpmSamplePtr, bool inHeap = false)
        : m_type(INJECTION_GPMSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmSamplePtr = GpmSamplePtr;
    }
    InjectionArgument(nvmlGpmSample_t GpmSample)
        : m_type(INJECTION_GPMSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmSample = GpmSample;
    }
    InjectionArgument(nvmlGpmSample_t *GpmSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmSamplePtr = GpmSamplePtr;
    }

    nvmlGpmSample_t *AsGpmSamplePtr() const
    {
        return m_value.GpmSamplePtr;
    }

    nvmlGpmSample_t const &AsGpmSample() const
    {
        return m_value.GpmSample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpmSupport_t *GpmSupportPtr, bool inHeap = false)
        : m_type(INJECTION_GPMSUPPORT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmSupportPtr = GpmSupportPtr;
    }
    InjectionArgument(nvmlGpmSupport_t GpmSupport)
        : m_type(INJECTION_GPMSUPPORT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmSupport = GpmSupport;
    }
    InjectionArgument(nvmlGpmSupport_t *GpmSupportPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPMSUPPORT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpmSupportPtr = GpmSupportPtr;
    }

    nvmlGpmSupport_t *AsGpmSupportPtr() const
    {
        return m_value.GpmSupportPtr;
    }

    nvmlGpmSupport_t const &AsGpmSupport() const
    {
        return m_value.GpmSupport;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuDynamicPstatesInfo_t *GpuDynamicPstatesInfoPtr, bool inHeap = false)
        : m_type(INJECTION_GPUDYNAMICPSTATESINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuDynamicPstatesInfoPtr = GpuDynamicPstatesInfoPtr;
    }
    InjectionArgument(nvmlGpuDynamicPstatesInfo_t GpuDynamicPstatesInfo)
        : m_type(INJECTION_GPUDYNAMICPSTATESINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuDynamicPstatesInfo = GpuDynamicPstatesInfo;
    }
    InjectionArgument(nvmlGpuDynamicPstatesInfo_t *GpuDynamicPstatesInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUDYNAMICPSTATESINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuDynamicPstatesInfoPtr = GpuDynamicPstatesInfoPtr;
    }

    nvmlGpuDynamicPstatesInfo_t *AsGpuDynamicPstatesInfoPtr() const
    {
        return m_value.GpuDynamicPstatesInfoPtr;
    }

    nvmlGpuDynamicPstatesInfo_t const &AsGpuDynamicPstatesInfo() const
    {
        return m_value.GpuDynamicPstatesInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuFabricInfoV_t *GpuFabricInfoVPtr, bool inHeap = false)
        : m_type(INJECTION_GPUFABRICINFOV_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuFabricInfoVPtr = GpuFabricInfoVPtr;
    }
    InjectionArgument(nvmlGpuFabricInfoV_t GpuFabricInfoV)
        : m_type(INJECTION_GPUFABRICINFOV)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuFabricInfoV = GpuFabricInfoV;
    }
    InjectionArgument(nvmlGpuFabricInfoV_t *GpuFabricInfoVPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUFABRICINFOV_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuFabricInfoVPtr = GpuFabricInfoVPtr;
    }

    nvmlGpuFabricInfoV_t *AsGpuFabricInfoVPtr() const
    {
        return m_value.GpuFabricInfoVPtr;
    }

    nvmlGpuFabricInfoV_t const &AsGpuFabricInfoV() const
    {
        return m_value.GpuFabricInfoV;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuFabricInfo_t *GpuFabricInfoPtr, bool inHeap = false)
        : m_type(INJECTION_GPUFABRICINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuFabricInfoPtr = GpuFabricInfoPtr;
    }
    InjectionArgument(nvmlGpuFabricInfo_t GpuFabricInfo)
        : m_type(INJECTION_GPUFABRICINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuFabricInfo = GpuFabricInfo;
    }
    InjectionArgument(nvmlGpuFabricInfo_t *GpuFabricInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUFABRICINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuFabricInfoPtr = GpuFabricInfoPtr;
    }

    nvmlGpuFabricInfo_t *AsGpuFabricInfoPtr() const
    {
        return m_value.GpuFabricInfoPtr;
    }

    nvmlGpuFabricInfo_t const &AsGpuFabricInfo() const
    {
        return m_value.GpuFabricInfo;
    }

    nvmlGpuFabricState_t *AsGpuFabricStatePtr() const
    {
        return static_cast<nvmlGpuFabricState_t *>(m_value.UCharPtr);
    }

    nvmlGpuFabricState_t AsGpuFabricState() const
    {
        return static_cast<nvmlGpuFabricState_t>(m_value.UChar);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceInfo_t *GpuInstanceInfoPtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceInfoPtr = GpuInstanceInfoPtr;
    }
    InjectionArgument(nvmlGpuInstanceInfo_t GpuInstanceInfo)
        : m_type(INJECTION_GPUINSTANCEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceInfo = GpuInstanceInfo;
    }
    InjectionArgument(nvmlGpuInstanceInfo_t *GpuInstanceInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceInfoPtr = GpuInstanceInfoPtr;
    }

    nvmlGpuInstanceInfo_t *AsGpuInstanceInfoPtr() const
    {
        return m_value.GpuInstanceInfoPtr;
    }

    nvmlGpuInstanceInfo_t const &AsGpuInstanceInfo() const
    {
        return m_value.GpuInstanceInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstancePlacement_t *GpuInstancePlacementPtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPLACEMENT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstancePlacementPtr = GpuInstancePlacementPtr;
    }
    InjectionArgument(nvmlGpuInstancePlacement_t GpuInstancePlacement)
        : m_type(INJECTION_GPUINSTANCEPLACEMENT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstancePlacement = GpuInstancePlacement;
    }
    InjectionArgument(nvmlGpuInstancePlacement_t *GpuInstancePlacementPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPLACEMENT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstancePlacementPtr = GpuInstancePlacementPtr;
    }

    nvmlGpuInstancePlacement_t *AsGpuInstancePlacementPtr() const
    {
        return m_value.GpuInstancePlacementPtr;
    }

    nvmlGpuInstancePlacement_t const &AsGpuInstancePlacement() const
    {
        return m_value.GpuInstancePlacement;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceProfileInfo_t *GpuInstanceProfileInfoPtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfoPtr = GpuInstanceProfileInfoPtr;
    }
    InjectionArgument(nvmlGpuInstanceProfileInfo_t GpuInstanceProfileInfo)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfo = GpuInstanceProfileInfo;
    }
    InjectionArgument(nvmlGpuInstanceProfileInfo_t *GpuInstanceProfileInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfoPtr = GpuInstanceProfileInfoPtr;
    }

    nvmlGpuInstanceProfileInfo_t *AsGpuInstanceProfileInfoPtr() const
    {
        return m_value.GpuInstanceProfileInfoPtr;
    }

    nvmlGpuInstanceProfileInfo_t const &AsGpuInstanceProfileInfo() const
    {
        return m_value.GpuInstanceProfileInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceProfileInfo_v2_t *GpuInstanceProfileInfo_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfo_v2Ptr = GpuInstanceProfileInfo_v2Ptr;
    }
    InjectionArgument(nvmlGpuInstanceProfileInfo_v2_t GpuInstanceProfileInfo_v2)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfo_v2 = GpuInstanceProfileInfo_v2;
    }
    InjectionArgument(nvmlGpuInstanceProfileInfo_v2_t *GpuInstanceProfileInfo_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfo_v2Ptr = GpuInstanceProfileInfo_v2Ptr;
    }

    nvmlGpuInstanceProfileInfo_v2_t *AsGpuInstanceProfileInfo_v2Ptr() const
    {
        return m_value.GpuInstanceProfileInfo_v2Ptr;
    }

    nvmlGpuInstanceProfileInfo_v2_t const &AsGpuInstanceProfileInfo_v2() const
    {
        return m_value.GpuInstanceProfileInfo_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstanceProfileInfo_v3_t *GpuInstanceProfileInfo_v3Ptr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V3_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfo_v3Ptr = GpuInstanceProfileInfo_v3Ptr;
    }
    InjectionArgument(nvmlGpuInstanceProfileInfo_v3_t GpuInstanceProfileInfo_v3)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V3)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfo_v3 = GpuInstanceProfileInfo_v3;
    }
    InjectionArgument(nvmlGpuInstanceProfileInfo_v3_t *GpuInstanceProfileInfo_v3Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V3_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstanceProfileInfo_v3Ptr = GpuInstanceProfileInfo_v3Ptr;
    }

    nvmlGpuInstanceProfileInfo_v3_t *AsGpuInstanceProfileInfo_v3Ptr() const
    {
        return m_value.GpuInstanceProfileInfo_v3Ptr;
    }

    nvmlGpuInstanceProfileInfo_v3_t const &AsGpuInstanceProfileInfo_v3() const
    {
        return m_value.GpuInstanceProfileInfo_v3;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuInstance_t *GpuInstancePtr, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstancePtr = GpuInstancePtr;
    }
    InjectionArgument(nvmlGpuInstance_t GpuInstance)
        : m_type(INJECTION_GPUINSTANCE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstance = GpuInstance;
    }
    InjectionArgument(nvmlGpuInstance_t *GpuInstancePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUINSTANCE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuInstancePtr = GpuInstancePtr;
    }

    nvmlGpuInstance_t *AsGpuInstancePtr() const
    {
        return m_value.GpuInstancePtr;
    }

    nvmlGpuInstance_t const &AsGpuInstance() const
    {
        return m_value.GpuInstance;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuOperationMode_t *GpuOperationModePtr, bool inHeap = false)
        : m_type(INJECTION_GPUOPERATIONMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuOperationModePtr = GpuOperationModePtr;
    }
    InjectionArgument(nvmlGpuOperationMode_t GpuOperationMode)
        : m_type(INJECTION_GPUOPERATIONMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuOperationMode = GpuOperationMode;
    }
    InjectionArgument(nvmlGpuOperationMode_t *GpuOperationModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUOPERATIONMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuOperationModePtr = GpuOperationModePtr;
    }

    nvmlGpuOperationMode_t *AsGpuOperationModePtr() const
    {
        return m_value.GpuOperationModePtr;
    }

    nvmlGpuOperationMode_t const &AsGpuOperationMode() const
    {
        return m_value.GpuOperationMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuP2PCapsIndex_t *GpuP2PCapsIndexPtr, bool inHeap = false)
        : m_type(INJECTION_GPUP2PCAPSINDEX_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuP2PCapsIndexPtr = GpuP2PCapsIndexPtr;
    }
    InjectionArgument(nvmlGpuP2PCapsIndex_t GpuP2PCapsIndex)
        : m_type(INJECTION_GPUP2PCAPSINDEX)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuP2PCapsIndex = GpuP2PCapsIndex;
    }
    InjectionArgument(nvmlGpuP2PCapsIndex_t *GpuP2PCapsIndexPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUP2PCAPSINDEX_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuP2PCapsIndexPtr = GpuP2PCapsIndexPtr;
    }

    nvmlGpuP2PCapsIndex_t *AsGpuP2PCapsIndexPtr() const
    {
        return m_value.GpuP2PCapsIndexPtr;
    }

    nvmlGpuP2PCapsIndex_t const &AsGpuP2PCapsIndex() const
    {
        return m_value.GpuP2PCapsIndex;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuP2PStatus_t *GpuP2PStatusPtr, bool inHeap = false)
        : m_type(INJECTION_GPUP2PSTATUS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuP2PStatusPtr = GpuP2PStatusPtr;
    }
    InjectionArgument(nvmlGpuP2PStatus_t GpuP2PStatus)
        : m_type(INJECTION_GPUP2PSTATUS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuP2PStatus = GpuP2PStatus;
    }
    InjectionArgument(nvmlGpuP2PStatus_t *GpuP2PStatusPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUP2PSTATUS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuP2PStatusPtr = GpuP2PStatusPtr;
    }

    nvmlGpuP2PStatus_t *AsGpuP2PStatusPtr() const
    {
        return m_value.GpuP2PStatusPtr;
    }

    nvmlGpuP2PStatus_t const &AsGpuP2PStatus() const
    {
        return m_value.GpuP2PStatus;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuThermalSettings_t *GpuThermalSettingsPtr, bool inHeap = false)
        : m_type(INJECTION_GPUTHERMALSETTINGS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuThermalSettingsPtr = GpuThermalSettingsPtr;
    }
    InjectionArgument(nvmlGpuThermalSettings_t GpuThermalSettings)
        : m_type(INJECTION_GPUTHERMALSETTINGS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuThermalSettings = GpuThermalSettings;
    }
    InjectionArgument(nvmlGpuThermalSettings_t *GpuThermalSettingsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUTHERMALSETTINGS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuThermalSettingsPtr = GpuThermalSettingsPtr;
    }

    nvmlGpuThermalSettings_t *AsGpuThermalSettingsPtr() const
    {
        return m_value.GpuThermalSettingsPtr;
    }

    nvmlGpuThermalSettings_t const &AsGpuThermalSettings() const
    {
        return m_value.GpuThermalSettings;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuTopologyLevel_t *GpuTopologyLevelPtr, bool inHeap = false)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuTopologyLevelPtr = GpuTopologyLevelPtr;
    }
    InjectionArgument(nvmlGpuTopologyLevel_t GpuTopologyLevel)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuTopologyLevel = GpuTopologyLevel;
    }
    InjectionArgument(nvmlGpuTopologyLevel_t *GpuTopologyLevelPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuTopologyLevelPtr = GpuTopologyLevelPtr;
    }

    nvmlGpuTopologyLevel_t *AsGpuTopologyLevelPtr() const
    {
        return m_value.GpuTopologyLevelPtr;
    }

    nvmlGpuTopologyLevel_t const &AsGpuTopologyLevel() const
    {
        return m_value.GpuTopologyLevel;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuUtilizationDomainId_t *GpuUtilizationDomainIdPtr, bool inHeap = false)
        : m_type(INJECTION_GPUUTILIZATIONDOMAINID_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuUtilizationDomainIdPtr = GpuUtilizationDomainIdPtr;
    }
    InjectionArgument(nvmlGpuUtilizationDomainId_t GpuUtilizationDomainId)
        : m_type(INJECTION_GPUUTILIZATIONDOMAINID)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuUtilizationDomainId = GpuUtilizationDomainId;
    }
    InjectionArgument(nvmlGpuUtilizationDomainId_t *GpuUtilizationDomainIdPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUUTILIZATIONDOMAINID_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuUtilizationDomainIdPtr = GpuUtilizationDomainIdPtr;
    }

    nvmlGpuUtilizationDomainId_t *AsGpuUtilizationDomainIdPtr() const
    {
        return m_value.GpuUtilizationDomainIdPtr;
    }

    nvmlGpuUtilizationDomainId_t const &AsGpuUtilizationDomainId() const
    {
        return m_value.GpuUtilizationDomainId;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGpuVirtualizationMode_t *GpuVirtualizationModePtr, bool inHeap = false)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuVirtualizationModePtr = GpuVirtualizationModePtr;
    }
    InjectionArgument(nvmlGpuVirtualizationMode_t GpuVirtualizationMode)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuVirtualizationMode = GpuVirtualizationMode;
    }
    InjectionArgument(nvmlGpuVirtualizationMode_t *GpuVirtualizationModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GpuVirtualizationModePtr = GpuVirtualizationModePtr;
    }

    nvmlGpuVirtualizationMode_t *AsGpuVirtualizationModePtr() const
    {
        return m_value.GpuVirtualizationModePtr;
    }

    nvmlGpuVirtualizationMode_t const &AsGpuVirtualizationMode() const
    {
        return m_value.GpuVirtualizationMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGridLicensableFeature_t *GridLicensableFeaturePtr, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSABLEFEATURE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicensableFeaturePtr = GridLicensableFeaturePtr;
    }
    InjectionArgument(nvmlGridLicensableFeature_t GridLicensableFeature)
        : m_type(INJECTION_GRIDLICENSABLEFEATURE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicensableFeature = GridLicensableFeature;
    }
    InjectionArgument(nvmlGridLicensableFeature_t *GridLicensableFeaturePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSABLEFEATURE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicensableFeaturePtr = GridLicensableFeaturePtr;
    }

    nvmlGridLicensableFeature_t *AsGridLicensableFeaturePtr() const
    {
        return m_value.GridLicensableFeaturePtr;
    }

    nvmlGridLicensableFeature_t const &AsGridLicensableFeature() const
    {
        return m_value.GridLicensableFeature;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGridLicensableFeatures_t *GridLicensableFeaturesPtr, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSABLEFEATURES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicensableFeaturesPtr = GridLicensableFeaturesPtr;
    }
    InjectionArgument(nvmlGridLicensableFeatures_t GridLicensableFeatures)
        : m_type(INJECTION_GRIDLICENSABLEFEATURES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicensableFeatures = GridLicensableFeatures;
    }
    InjectionArgument(nvmlGridLicensableFeatures_t *GridLicensableFeaturesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSABLEFEATURES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicensableFeaturesPtr = GridLicensableFeaturesPtr;
    }

    nvmlGridLicensableFeatures_t *AsGridLicensableFeaturesPtr() const
    {
        return m_value.GridLicensableFeaturesPtr;
    }

    nvmlGridLicensableFeatures_t const &AsGridLicensableFeatures() const
    {
        return m_value.GridLicensableFeatures;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGridLicenseExpiry_t *GridLicenseExpiryPtr, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSEEXPIRY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicenseExpiryPtr = GridLicenseExpiryPtr;
    }
    InjectionArgument(nvmlGridLicenseExpiry_t GridLicenseExpiry)
        : m_type(INJECTION_GRIDLICENSEEXPIRY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicenseExpiry = GridLicenseExpiry;
    }
    InjectionArgument(nvmlGridLicenseExpiry_t *GridLicenseExpiryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSEEXPIRY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicenseExpiryPtr = GridLicenseExpiryPtr;
    }

    nvmlGridLicenseExpiry_t *AsGridLicenseExpiryPtr() const
    {
        return m_value.GridLicenseExpiryPtr;
    }

    nvmlGridLicenseExpiry_t const &AsGridLicenseExpiry() const
    {
        return m_value.GridLicenseExpiry;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlGridLicenseFeatureCode_t *GridLicenseFeatureCodePtr, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSEFEATURECODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicenseFeatureCodePtr = GridLicenseFeatureCodePtr;
    }
    InjectionArgument(nvmlGridLicenseFeatureCode_t GridLicenseFeatureCode)
        : m_type(INJECTION_GRIDLICENSEFEATURECODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicenseFeatureCode = GridLicenseFeatureCode;
    }
    InjectionArgument(nvmlGridLicenseFeatureCode_t *GridLicenseFeatureCodePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_GRIDLICENSEFEATURECODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.GridLicenseFeatureCodePtr = GridLicenseFeatureCodePtr;
    }

    nvmlGridLicenseFeatureCode_t *AsGridLicenseFeatureCodePtr() const
    {
        return m_value.GridLicenseFeatureCodePtr;
    }

    nvmlGridLicenseFeatureCode_t const &AsGridLicenseFeatureCode() const
    {
        return m_value.GridLicenseFeatureCode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlHostVgpuMode_t *HostVgpuModePtr, bool inHeap = false)
        : m_type(INJECTION_HOSTVGPUMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.HostVgpuModePtr = HostVgpuModePtr;
    }
    InjectionArgument(nvmlHostVgpuMode_t HostVgpuMode)
        : m_type(INJECTION_HOSTVGPUMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.HostVgpuMode = HostVgpuMode;
    }
    InjectionArgument(nvmlHostVgpuMode_t *HostVgpuModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_HOSTVGPUMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.HostVgpuModePtr = HostVgpuModePtr;
    }

    nvmlHostVgpuMode_t *AsHostVgpuModePtr() const
    {
        return m_value.HostVgpuModePtr;
    }

    nvmlHostVgpuMode_t const &AsHostVgpuMode() const
    {
        return m_value.HostVgpuMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlHwbcEntry_t *HwbcEntryPtr, bool inHeap = false)
        : m_type(INJECTION_HWBCENTRY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.HwbcEntryPtr = HwbcEntryPtr;
    }
    InjectionArgument(nvmlHwbcEntry_t HwbcEntry)
        : m_type(INJECTION_HWBCENTRY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.HwbcEntry = HwbcEntry;
    }
    InjectionArgument(nvmlHwbcEntry_t *HwbcEntryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_HWBCENTRY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.HwbcEntryPtr = HwbcEntryPtr;
    }

    nvmlHwbcEntry_t *AsHwbcEntryPtr() const
    {
        return m_value.HwbcEntryPtr;
    }

    nvmlHwbcEntry_t const &AsHwbcEntry() const
    {
        return m_value.HwbcEntry;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlInforomObject_t *InforomObjectPtr, bool inHeap = false)
        : m_type(INJECTION_INFOROMOBJECT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.InforomObjectPtr = InforomObjectPtr;
    }
    InjectionArgument(nvmlInforomObject_t InforomObject)
        : m_type(INJECTION_INFOROMOBJECT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.InforomObject = InforomObject;
    }
    InjectionArgument(nvmlInforomObject_t *InforomObjectPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_INFOROMOBJECT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.InforomObjectPtr = InforomObjectPtr;
    }

    nvmlInforomObject_t *AsInforomObjectPtr() const
    {
        return m_value.InforomObjectPtr;
    }

    nvmlInforomObject_t const &AsInforomObject() const
    {
        return m_value.InforomObject;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlIntNvLinkDeviceType_t *IntNvLinkDeviceTypePtr, bool inHeap = false)
        : m_type(INJECTION_INTNVLINKDEVICETYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.IntNvLinkDeviceTypePtr = IntNvLinkDeviceTypePtr;
    }
    InjectionArgument(nvmlIntNvLinkDeviceType_t IntNvLinkDeviceType)
        : m_type(INJECTION_INTNVLINKDEVICETYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.IntNvLinkDeviceType = IntNvLinkDeviceType;
    }
    InjectionArgument(nvmlIntNvLinkDeviceType_t *IntNvLinkDeviceTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_INTNVLINKDEVICETYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.IntNvLinkDeviceTypePtr = IntNvLinkDeviceTypePtr;
    }

    nvmlIntNvLinkDeviceType_t *AsIntNvLinkDeviceTypePtr() const
    {
        return m_value.IntNvLinkDeviceTypePtr;
    }

    nvmlIntNvLinkDeviceType_t const &AsIntNvLinkDeviceType() const
    {
        return m_value.IntNvLinkDeviceType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlLedColor_t *LedColorPtr, bool inHeap = false)
        : m_type(INJECTION_LEDCOLOR_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LedColorPtr = LedColorPtr;
    }
    InjectionArgument(nvmlLedColor_t LedColor)
        : m_type(INJECTION_LEDCOLOR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LedColor = LedColor;
    }
    InjectionArgument(nvmlLedColor_t *LedColorPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_LEDCOLOR_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LedColorPtr = LedColorPtr;
    }

    nvmlLedColor_t *AsLedColorPtr() const
    {
        return m_value.LedColorPtr;
    }

    nvmlLedColor_t const &AsLedColor() const
    {
        return m_value.LedColor;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlLedState_t *LedStatePtr, bool inHeap = false)
        : m_type(INJECTION_LEDSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LedStatePtr = LedStatePtr;
    }
    InjectionArgument(nvmlLedState_t LedState)
        : m_type(INJECTION_LEDSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LedState = LedState;
    }
    InjectionArgument(nvmlLedState_t *LedStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_LEDSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.LedStatePtr = LedStatePtr;
    }

    nvmlLedState_t *AsLedStatePtr() const
    {
        return m_value.LedStatePtr;
    }

    nvmlLedState_t const &AsLedState() const
    {
        return m_value.LedState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMask255_t *Mask255Ptr, bool inHeap = false)
        : m_type(INJECTION_MASK255_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Mask255Ptr = Mask255Ptr;
    }
    InjectionArgument(nvmlMask255_t Mask255)
        : m_type(INJECTION_MASK255)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Mask255 = Mask255;
    }
    InjectionArgument(nvmlMask255_t *Mask255Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_MASK255_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Mask255Ptr = Mask255Ptr;
    }

    nvmlMask255_t *AsMask255Ptr() const
    {
        return m_value.Mask255Ptr;
    }

    nvmlMask255_t const &AsMask255() const
    {
        return m_value.Mask255;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemoryErrorType_t *MemoryErrorTypePtr, bool inHeap = false)
        : m_type(INJECTION_MEMORYERRORTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryErrorTypePtr = MemoryErrorTypePtr;
    }
    InjectionArgument(nvmlMemoryErrorType_t MemoryErrorType)
        : m_type(INJECTION_MEMORYERRORTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryErrorType = MemoryErrorType;
    }
    InjectionArgument(nvmlMemoryErrorType_t *MemoryErrorTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_MEMORYERRORTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryErrorTypePtr = MemoryErrorTypePtr;
    }

    nvmlMemoryErrorType_t *AsMemoryErrorTypePtr() const
    {
        return m_value.MemoryErrorTypePtr;
    }

    nvmlMemoryErrorType_t const &AsMemoryErrorType() const
    {
        return m_value.MemoryErrorType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemoryLocation_t *MemoryLocationPtr, bool inHeap = false)
        : m_type(INJECTION_MEMORYLOCATION_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryLocationPtr = MemoryLocationPtr;
    }
    InjectionArgument(nvmlMemoryLocation_t MemoryLocation)
        : m_type(INJECTION_MEMORYLOCATION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryLocation = MemoryLocation;
    }
    InjectionArgument(nvmlMemoryLocation_t *MemoryLocationPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_MEMORYLOCATION_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryLocationPtr = MemoryLocationPtr;
    }

    nvmlMemoryLocation_t *AsMemoryLocationPtr() const
    {
        return m_value.MemoryLocationPtr;
    }

    nvmlMemoryLocation_t const &AsMemoryLocation() const
    {
        return m_value.MemoryLocation;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemory_t *MemoryPtr, bool inHeap = false)
        : m_type(INJECTION_MEMORY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryPtr = MemoryPtr;
    }
    InjectionArgument(nvmlMemory_t Memory)
        : m_type(INJECTION_MEMORY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Memory = Memory;
    }
    InjectionArgument(nvmlMemory_t *MemoryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_MEMORY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.MemoryPtr = MemoryPtr;
    }

    nvmlMemory_t *AsMemoryPtr() const
    {
        return m_value.MemoryPtr;
    }

    nvmlMemory_t const &AsMemory() const
    {
        return m_value.Memory;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlMemory_v2_t *Memory_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_MEMORY_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Memory_v2Ptr = Memory_v2Ptr;
    }
    InjectionArgument(nvmlMemory_v2_t Memory_v2)
        : m_type(INJECTION_MEMORY_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Memory_v2 = Memory_v2;
    }
    InjectionArgument(nvmlMemory_v2_t *Memory_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_MEMORY_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Memory_v2Ptr = Memory_v2Ptr;
    }

    nvmlMemory_v2_t *AsMemory_v2Ptr() const
    {
        return m_value.Memory_v2Ptr;
    }

    nvmlMemory_v2_t const &AsMemory_v2() const
    {
        return m_value.Memory_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkCapability_t *NvLinkCapabilityPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKCAPABILITY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkCapabilityPtr = NvLinkCapabilityPtr;
    }
    InjectionArgument(nvmlNvLinkCapability_t NvLinkCapability)
        : m_type(INJECTION_NVLINKCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkCapability = NvLinkCapability;
    }
    InjectionArgument(nvmlNvLinkCapability_t *NvLinkCapabilityPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKCAPABILITY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkCapabilityPtr = NvLinkCapabilityPtr;
    }

    nvmlNvLinkCapability_t *AsNvLinkCapabilityPtr() const
    {
        return m_value.NvLinkCapabilityPtr;
    }

    nvmlNvLinkCapability_t const &AsNvLinkCapability() const
    {
        return m_value.NvLinkCapability;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkErrorCounter_t *NvLinkErrorCounterPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKERRORCOUNTER_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkErrorCounterPtr = NvLinkErrorCounterPtr;
    }
    InjectionArgument(nvmlNvLinkErrorCounter_t NvLinkErrorCounter)
        : m_type(INJECTION_NVLINKERRORCOUNTER)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkErrorCounter = NvLinkErrorCounter;
    }
    InjectionArgument(nvmlNvLinkErrorCounter_t *NvLinkErrorCounterPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKERRORCOUNTER_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkErrorCounterPtr = NvLinkErrorCounterPtr;
    }

    nvmlNvLinkErrorCounter_t *AsNvLinkErrorCounterPtr() const
    {
        return m_value.NvLinkErrorCounterPtr;
    }

    nvmlNvLinkErrorCounter_t const &AsNvLinkErrorCounter() const
    {
        return m_value.NvLinkErrorCounter;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkPowerThres_t *NvLinkPowerThresPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKPOWERTHRES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkPowerThresPtr = NvLinkPowerThresPtr;
    }
    InjectionArgument(nvmlNvLinkPowerThres_t NvLinkPowerThres)
        : m_type(INJECTION_NVLINKPOWERTHRES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkPowerThres = NvLinkPowerThres;
    }
    InjectionArgument(nvmlNvLinkPowerThres_t *NvLinkPowerThresPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKPOWERTHRES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkPowerThresPtr = NvLinkPowerThresPtr;
    }

    nvmlNvLinkPowerThres_t *AsNvLinkPowerThresPtr() const
    {
        return m_value.NvLinkPowerThresPtr;
    }

    nvmlNvLinkPowerThres_t const &AsNvLinkPowerThres() const
    {
        return m_value.NvLinkPowerThres;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkUtilizationControl_t *NvLinkUtilizationControlPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCONTROL_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationControlPtr = NvLinkUtilizationControlPtr;
    }
    InjectionArgument(nvmlNvLinkUtilizationControl_t NvLinkUtilizationControl)
        : m_type(INJECTION_NVLINKUTILIZATIONCONTROL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationControl = NvLinkUtilizationControl;
    }
    InjectionArgument(nvmlNvLinkUtilizationControl_t *NvLinkUtilizationControlPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCONTROL_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationControlPtr = NvLinkUtilizationControlPtr;
    }

    nvmlNvLinkUtilizationControl_t *AsNvLinkUtilizationControlPtr() const
    {
        return m_value.NvLinkUtilizationControlPtr;
    }

    nvmlNvLinkUtilizationControl_t const &AsNvLinkUtilizationControl() const
    {
        return m_value.NvLinkUtilizationControl;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkUtilizationCountPktTypes_t *NvLinkUtilizationCountPktTypesPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCOUNTPKTTYPES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationCountPktTypesPtr = NvLinkUtilizationCountPktTypesPtr;
    }
    InjectionArgument(nvmlNvLinkUtilizationCountPktTypes_t NvLinkUtilizationCountPktTypes)
        : m_type(INJECTION_NVLINKUTILIZATIONCOUNTPKTTYPES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationCountPktTypes = NvLinkUtilizationCountPktTypes;
    }
    InjectionArgument(nvmlNvLinkUtilizationCountPktTypes_t *NvLinkUtilizationCountPktTypesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCOUNTPKTTYPES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationCountPktTypesPtr = NvLinkUtilizationCountPktTypesPtr;
    }

    nvmlNvLinkUtilizationCountPktTypes_t *AsNvLinkUtilizationCountPktTypesPtr() const
    {
        return m_value.NvLinkUtilizationCountPktTypesPtr;
    }

    nvmlNvLinkUtilizationCountPktTypes_t const &AsNvLinkUtilizationCountPktTypes() const
    {
        return m_value.NvLinkUtilizationCountPktTypes;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvLinkUtilizationCountUnits_t *NvLinkUtilizationCountUnitsPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCOUNTUNITS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationCountUnitsPtr = NvLinkUtilizationCountUnitsPtr;
    }
    InjectionArgument(nvmlNvLinkUtilizationCountUnits_t NvLinkUtilizationCountUnits)
        : m_type(INJECTION_NVLINKUTILIZATIONCOUNTUNITS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationCountUnits = NvLinkUtilizationCountUnits;
    }
    InjectionArgument(nvmlNvLinkUtilizationCountUnits_t *NvLinkUtilizationCountUnitsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKUTILIZATIONCOUNTUNITS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvLinkUtilizationCountUnitsPtr = NvLinkUtilizationCountUnitsPtr;
    }

    nvmlNvLinkUtilizationCountUnits_t *AsNvLinkUtilizationCountUnitsPtr() const
    {
        return m_value.NvLinkUtilizationCountUnitsPtr;
    }

    nvmlNvLinkUtilizationCountUnits_t const &AsNvLinkUtilizationCountUnits() const
    {
        return m_value.NvLinkUtilizationCountUnits;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlNvlinkVersion_t *NvlinkVersionPtr, bool inHeap = false)
        : m_type(INJECTION_NVLINKVERSION_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvlinkVersionPtr = NvlinkVersionPtr;
    }
    InjectionArgument(nvmlNvlinkVersion_t NvlinkVersion)
        : m_type(INJECTION_NVLINKVERSION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvlinkVersion = NvlinkVersion;
    }
    InjectionArgument(nvmlNvlinkVersion_t *NvlinkVersionPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_NVLINKVERSION_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.NvlinkVersionPtr = NvlinkVersionPtr;
    }

    nvmlNvlinkVersion_t *AsNvlinkVersionPtr() const
    {
        return m_value.NvlinkVersionPtr;
    }

    nvmlNvlinkVersion_t const &AsNvlinkVersion() const
    {
        return m_value.NvlinkVersion;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPSUInfo_t *PSUInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PSUINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PSUInfoPtr = PSUInfoPtr;
    }
    InjectionArgument(nvmlPSUInfo_t PSUInfo)
        : m_type(INJECTION_PSUINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PSUInfo = PSUInfo;
    }
    InjectionArgument(nvmlPSUInfo_t *PSUInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PSUINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PSUInfoPtr = PSUInfoPtr;
    }

    nvmlPSUInfo_t *AsPSUInfoPtr() const
    {
        return m_value.PSUInfoPtr;
    }

    nvmlPSUInfo_t const &AsPSUInfo() const
    {
        return m_value.PSUInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPageRetirementCause_t *PageRetirementCausePtr, bool inHeap = false)
        : m_type(INJECTION_PAGERETIREMENTCAUSE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PageRetirementCausePtr = PageRetirementCausePtr;
    }
    InjectionArgument(nvmlPageRetirementCause_t PageRetirementCause)
        : m_type(INJECTION_PAGERETIREMENTCAUSE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PageRetirementCause = PageRetirementCause;
    }
    InjectionArgument(nvmlPageRetirementCause_t *PageRetirementCausePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PAGERETIREMENTCAUSE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PageRetirementCausePtr = PageRetirementCausePtr;
    }

    nvmlPageRetirementCause_t *AsPageRetirementCausePtr() const
    {
        return m_value.PageRetirementCausePtr;
    }

    nvmlPageRetirementCause_t const &AsPageRetirementCause() const
    {
        return m_value.PageRetirementCause;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPciInfoExt_t *PciInfoExtPtr, bool inHeap = false)
        : m_type(INJECTION_PCIINFOEXT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PciInfoExtPtr = PciInfoExtPtr;
    }
    InjectionArgument(nvmlPciInfoExt_t PciInfoExt)
        : m_type(INJECTION_PCIINFOEXT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PciInfoExt = PciInfoExt;
    }
    InjectionArgument(nvmlPciInfoExt_t *PciInfoExtPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PCIINFOEXT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PciInfoExtPtr = PciInfoExtPtr;
    }

    nvmlPciInfoExt_t *AsPciInfoExtPtr() const
    {
        return m_value.PciInfoExtPtr;
    }

    nvmlPciInfoExt_t const &AsPciInfoExt() const
    {
        return m_value.PciInfoExt;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPciInfo_t *PciInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PCIINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PciInfoPtr = PciInfoPtr;
    }
    InjectionArgument(nvmlPciInfo_t PciInfo)
        : m_type(INJECTION_PCIINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PciInfo = PciInfo;
    }
    InjectionArgument(nvmlPciInfo_t *PciInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PCIINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PciInfoPtr = PciInfoPtr;
    }

    nvmlPciInfo_t *AsPciInfoPtr() const
    {
        return m_value.PciInfoPtr;
    }

    nvmlPciInfo_t const &AsPciInfo() const
    {
        return m_value.PciInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPcieLinkState_t *PcieLinkStatePtr, bool inHeap = false)
        : m_type(INJECTION_PCIELINKSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PcieLinkStatePtr = PcieLinkStatePtr;
    }
    InjectionArgument(nvmlPcieLinkState_t PcieLinkState)
        : m_type(INJECTION_PCIELINKSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PcieLinkState = PcieLinkState;
    }
    InjectionArgument(nvmlPcieLinkState_t *PcieLinkStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PCIELINKSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PcieLinkStatePtr = PcieLinkStatePtr;
    }

    nvmlPcieLinkState_t *AsPcieLinkStatePtr() const
    {
        return m_value.PcieLinkStatePtr;
    }

    nvmlPcieLinkState_t const &AsPcieLinkState() const
    {
        return m_value.PcieLinkState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPcieUtilCounter_t *PcieUtilCounterPtr, bool inHeap = false)
        : m_type(INJECTION_PCIEUTILCOUNTER_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PcieUtilCounterPtr = PcieUtilCounterPtr;
    }
    InjectionArgument(nvmlPcieUtilCounter_t PcieUtilCounter)
        : m_type(INJECTION_PCIEUTILCOUNTER)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PcieUtilCounter = PcieUtilCounter;
    }
    InjectionArgument(nvmlPcieUtilCounter_t *PcieUtilCounterPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PCIEUTILCOUNTER_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PcieUtilCounterPtr = PcieUtilCounterPtr;
    }

    nvmlPcieUtilCounter_t *AsPcieUtilCounterPtr() const
    {
        return m_value.PcieUtilCounterPtr;
    }

    nvmlPcieUtilCounter_t const &AsPcieUtilCounter() const
    {
        return m_value.PcieUtilCounter;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPerfPolicyType_t *PerfPolicyTypePtr, bool inHeap = false)
        : m_type(INJECTION_PERFPOLICYTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PerfPolicyTypePtr = PerfPolicyTypePtr;
    }
    InjectionArgument(nvmlPerfPolicyType_t PerfPolicyType)
        : m_type(INJECTION_PERFPOLICYTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PerfPolicyType = PerfPolicyType;
    }
    InjectionArgument(nvmlPerfPolicyType_t *PerfPolicyTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PERFPOLICYTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PerfPolicyTypePtr = PerfPolicyTypePtr;
    }

    nvmlPerfPolicyType_t *AsPerfPolicyTypePtr() const
    {
        return m_value.PerfPolicyTypePtr;
    }

    nvmlPerfPolicyType_t const &AsPerfPolicyType() const
    {
        return m_value.PerfPolicyType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPlatformInfo_t *PlatformInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PLATFORMINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PlatformInfoPtr = PlatformInfoPtr;
    }
    InjectionArgument(nvmlPlatformInfo_t PlatformInfo)
        : m_type(INJECTION_PLATFORMINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PlatformInfo = PlatformInfo;
    }
    InjectionArgument(nvmlPlatformInfo_t *PlatformInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PLATFORMINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PlatformInfoPtr = PlatformInfoPtr;
    }

    nvmlPlatformInfo_t *AsPlatformInfoPtr() const
    {
        return m_value.PlatformInfoPtr;
    }

    nvmlPlatformInfo_t const &AsPlatformInfo() const
    {
        return m_value.PlatformInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPowerProfileType_t *PowerProfileTypePtr, bool inHeap = false)
        : m_type(INJECTION_POWERPROFILETYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PowerProfileTypePtr = PowerProfileTypePtr;
    }
    InjectionArgument(nvmlPowerProfileType_t PowerProfileType)
        : m_type(INJECTION_POWERPROFILETYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PowerProfileType = PowerProfileType;
    }
    InjectionArgument(nvmlPowerProfileType_t *PowerProfileTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_POWERPROFILETYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PowerProfileTypePtr = PowerProfileTypePtr;
    }

    nvmlPowerProfileType_t *AsPowerProfileTypePtr() const
    {
        return m_value.PowerProfileTypePtr;
    }

    nvmlPowerProfileType_t const &AsPowerProfileType() const
    {
        return m_value.PowerProfileType;
    }

    nvmlPowerScopeType_t *AsPowerScopeTypePtr() const
    {
        return static_cast<nvmlPowerScopeType_t *>(m_value.UCharPtr);
    }

    nvmlPowerScopeType_t AsPowerScopeType() const
    {
        return static_cast<nvmlPowerScopeType_t>(m_value.UChar);
    }

    nvmlPowerSource_t *AsPowerSourcePtr() const
    {
        return static_cast<nvmlPowerSource_t *>(m_value.UIntPtr);
    }

    nvmlPowerSource_t AsPowerSource() const
    {
        return static_cast<nvmlPowerSource_t>(m_value.UInt);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPowerValue_v2_t *PowerValue_v2Ptr, bool inHeap = false)
        : m_type(INJECTION_POWERVALUE_V2_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PowerValue_v2Ptr = PowerValue_v2Ptr;
    }
    InjectionArgument(nvmlPowerValue_v2_t PowerValue_v2)
        : m_type(INJECTION_POWERVALUE_V2)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PowerValue_v2 = PowerValue_v2;
    }
    InjectionArgument(nvmlPowerValue_v2_t *PowerValue_v2Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_POWERVALUE_V2_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PowerValue_v2Ptr = PowerValue_v2Ptr;
    }

    nvmlPowerValue_v2_t *AsPowerValue_v2Ptr() const
    {
        return m_value.PowerValue_v2Ptr;
    }

    nvmlPowerValue_v2_t const &AsPowerValue_v2() const
    {
        return m_value.PowerValue_v2;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessDetailList_t *ProcessDetailListPtr, bool inHeap = false)
        : m_type(INJECTION_PROCESSDETAILLIST_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessDetailListPtr = ProcessDetailListPtr;
    }
    InjectionArgument(nvmlProcessDetailList_t ProcessDetailList)
        : m_type(INJECTION_PROCESSDETAILLIST)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessDetailList = ProcessDetailList;
    }
    InjectionArgument(nvmlProcessDetailList_t *ProcessDetailListPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSDETAILLIST_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessDetailListPtr = ProcessDetailListPtr;
    }

    nvmlProcessDetailList_t *AsProcessDetailListPtr() const
    {
        return m_value.ProcessDetailListPtr;
    }

    nvmlProcessDetailList_t const &AsProcessDetailList() const
    {
        return m_value.ProcessDetailList;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessDetail_v1_t *ProcessDetail_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_PROCESSDETAIL_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessDetail_v1Ptr = ProcessDetail_v1Ptr;
    }
    InjectionArgument(nvmlProcessDetail_v1_t ProcessDetail_v1)
        : m_type(INJECTION_PROCESSDETAIL_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessDetail_v1 = ProcessDetail_v1;
    }
    InjectionArgument(nvmlProcessDetail_v1_t *ProcessDetail_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSDETAIL_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessDetail_v1Ptr = ProcessDetail_v1Ptr;
    }

    nvmlProcessDetail_v1_t *AsProcessDetail_v1Ptr() const
    {
        return m_value.ProcessDetail_v1Ptr;
    }

    nvmlProcessDetail_v1_t const &AsProcessDetail_v1() const
    {
        return m_value.ProcessDetail_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_t *ProcessInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessInfoPtr = ProcessInfoPtr;
    }
    InjectionArgument(nvmlProcessInfo_t ProcessInfo)
        : m_type(INJECTION_PROCESSINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessInfo = ProcessInfo;
    }
    InjectionArgument(nvmlProcessInfo_t *ProcessInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessInfoPtr = ProcessInfoPtr;
    }

    nvmlProcessInfo_t *AsProcessInfoPtr() const
    {
        return m_value.ProcessInfoPtr;
    }

    nvmlProcessInfo_t const &AsProcessInfo() const
    {
        return m_value.ProcessInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessInfo_v1_t *ProcessInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessInfo_v1Ptr = ProcessInfo_v1Ptr;
    }
    InjectionArgument(nvmlProcessInfo_v1_t ProcessInfo_v1)
        : m_type(INJECTION_PROCESSINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessInfo_v1 = ProcessInfo_v1;
    }
    InjectionArgument(nvmlProcessInfo_v1_t *ProcessInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessInfo_v1Ptr = ProcessInfo_v1Ptr;
    }

    nvmlProcessInfo_v1_t *AsProcessInfo_v1Ptr() const
    {
        return m_value.ProcessInfo_v1Ptr;
    }

    nvmlProcessInfo_v1_t const &AsProcessInfo_v1() const
    {
        return m_value.ProcessInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessUtilizationInfo_v1_t *ProcessUtilizationInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_PROCESSUTILIZATIONINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessUtilizationInfo_v1Ptr = ProcessUtilizationInfo_v1Ptr;
    }
    InjectionArgument(nvmlProcessUtilizationInfo_v1_t ProcessUtilizationInfo_v1)
        : m_type(INJECTION_PROCESSUTILIZATIONINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessUtilizationInfo_v1 = ProcessUtilizationInfo_v1;
    }
    InjectionArgument(nvmlProcessUtilizationInfo_v1_t *ProcessUtilizationInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSUTILIZATIONINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessUtilizationInfo_v1Ptr = ProcessUtilizationInfo_v1Ptr;
    }

    nvmlProcessUtilizationInfo_v1_t *AsProcessUtilizationInfo_v1Ptr() const
    {
        return m_value.ProcessUtilizationInfo_v1Ptr;
    }

    nvmlProcessUtilizationInfo_v1_t const &AsProcessUtilizationInfo_v1() const
    {
        return m_value.ProcessUtilizationInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessUtilizationSample_t *ProcessUtilizationSamplePtr, bool inHeap = false)
        : m_type(INJECTION_PROCESSUTILIZATIONSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessUtilizationSamplePtr = ProcessUtilizationSamplePtr;
    }
    InjectionArgument(nvmlProcessUtilizationSample_t ProcessUtilizationSample)
        : m_type(INJECTION_PROCESSUTILIZATIONSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessUtilizationSample = ProcessUtilizationSample;
    }
    InjectionArgument(nvmlProcessUtilizationSample_t *ProcessUtilizationSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSUTILIZATIONSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessUtilizationSamplePtr = ProcessUtilizationSamplePtr;
    }

    nvmlProcessUtilizationSample_t *AsProcessUtilizationSamplePtr() const
    {
        return m_value.ProcessUtilizationSamplePtr;
    }

    nvmlProcessUtilizationSample_t const &AsProcessUtilizationSample() const
    {
        return m_value.ProcessUtilizationSample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlProcessesUtilizationInfo_t *ProcessesUtilizationInfoPtr, bool inHeap = false)
        : m_type(INJECTION_PROCESSESUTILIZATIONINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessesUtilizationInfoPtr = ProcessesUtilizationInfoPtr;
    }
    InjectionArgument(nvmlProcessesUtilizationInfo_t ProcessesUtilizationInfo)
        : m_type(INJECTION_PROCESSESUTILIZATIONINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessesUtilizationInfo = ProcessesUtilizationInfo;
    }
    InjectionArgument(nvmlProcessesUtilizationInfo_t *ProcessesUtilizationInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PROCESSESUTILIZATIONINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ProcessesUtilizationInfoPtr = ProcessesUtilizationInfoPtr;
    }

    nvmlProcessesUtilizationInfo_t *AsProcessesUtilizationInfoPtr() const
    {
        return m_value.ProcessesUtilizationInfoPtr;
    }

    nvmlProcessesUtilizationInfo_t const &AsProcessesUtilizationInfo() const
    {
        return m_value.ProcessesUtilizationInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlPstates_t *PstatesPtr, bool inHeap = false)
        : m_type(INJECTION_PSTATES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PstatesPtr = PstatesPtr;
    }
    InjectionArgument(nvmlPstates_t Pstates)
        : m_type(INJECTION_PSTATES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Pstates = Pstates;
    }
    InjectionArgument(nvmlPstates_t *PstatesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_PSTATES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.PstatesPtr = PstatesPtr;
    }

    nvmlPstates_t *AsPstatesPtr() const
    {
        return m_value.PstatesPtr;
    }

    nvmlPstates_t const &AsPstates() const
    {
        return m_value.Pstates;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlRestrictedAPI_t *RestrictedAPIPtr, bool inHeap = false)
        : m_type(INJECTION_RESTRICTEDAPI_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.RestrictedAPIPtr = RestrictedAPIPtr;
    }
    InjectionArgument(nvmlRestrictedAPI_t RestrictedAPI)
        : m_type(INJECTION_RESTRICTEDAPI)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.RestrictedAPI = RestrictedAPI;
    }
    InjectionArgument(nvmlRestrictedAPI_t *RestrictedAPIPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_RESTRICTEDAPI_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.RestrictedAPIPtr = RestrictedAPIPtr;
    }

    nvmlRestrictedAPI_t *AsRestrictedAPIPtr() const
    {
        return m_value.RestrictedAPIPtr;
    }

    nvmlRestrictedAPI_t const &AsRestrictedAPI() const
    {
        return m_value.RestrictedAPI;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlReturn_t *ReturnPtr, bool inHeap = false)
        : m_type(INJECTION_RETURN_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ReturnPtr = ReturnPtr;
    }
    InjectionArgument(nvmlReturn_t Return)
        : m_type(INJECTION_RETURN)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Return = Return;
    }
    InjectionArgument(nvmlReturn_t *ReturnPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_RETURN_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ReturnPtr = ReturnPtr;
    }

    nvmlReturn_t *AsReturnPtr() const
    {
        return m_value.ReturnPtr;
    }

    nvmlReturn_t const &AsReturn() const
    {
        return m_value.Return;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlRowRemapperHistogramValues_t *RowRemapperHistogramValuesPtr, bool inHeap = false)
        : m_type(INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.RowRemapperHistogramValuesPtr = RowRemapperHistogramValuesPtr;
    }
    InjectionArgument(nvmlRowRemapperHistogramValues_t RowRemapperHistogramValues)
        : m_type(INJECTION_ROWREMAPPERHISTOGRAMVALUES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.RowRemapperHistogramValues = RowRemapperHistogramValues;
    }
    InjectionArgument(nvmlRowRemapperHistogramValues_t *RowRemapperHistogramValuesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.RowRemapperHistogramValuesPtr = RowRemapperHistogramValuesPtr;
    }

    nvmlRowRemapperHistogramValues_t *AsRowRemapperHistogramValuesPtr() const
    {
        return m_value.RowRemapperHistogramValuesPtr;
    }

    nvmlRowRemapperHistogramValues_t const &AsRowRemapperHistogramValues() const
    {
        return m_value.RowRemapperHistogramValues;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlSample_t *SamplePtr, bool inHeap = false)
        : m_type(INJECTION_SAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SamplePtr = SamplePtr;
    }
    InjectionArgument(nvmlSample_t Sample)
        : m_type(INJECTION_SAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Sample = Sample;
    }
    InjectionArgument(nvmlSample_t *SamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_SAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SamplePtr = SamplePtr;
    }

    nvmlSample_t *AsSamplePtr() const
    {
        return m_value.SamplePtr;
    }

    nvmlSample_t const &AsSample() const
    {
        return m_value.Sample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlSamplingType_t *SamplingTypePtr, bool inHeap = false)
        : m_type(INJECTION_SAMPLINGTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SamplingTypePtr = SamplingTypePtr;
    }
    InjectionArgument(nvmlSamplingType_t SamplingType)
        : m_type(INJECTION_SAMPLINGTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SamplingType = SamplingType;
    }
    InjectionArgument(nvmlSamplingType_t *SamplingTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_SAMPLINGTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SamplingTypePtr = SamplingTypePtr;
    }

    nvmlSamplingType_t *AsSamplingTypePtr() const
    {
        return m_value.SamplingTypePtr;
    }

    nvmlSamplingType_t const &AsSamplingType() const
    {
        return m_value.SamplingType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlSystemConfComputeSettings_t *SystemConfComputeSettingsPtr, bool inHeap = false)
        : m_type(INJECTION_SYSTEMCONFCOMPUTESETTINGS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SystemConfComputeSettingsPtr = SystemConfComputeSettingsPtr;
    }
    InjectionArgument(nvmlSystemConfComputeSettings_t SystemConfComputeSettings)
        : m_type(INJECTION_SYSTEMCONFCOMPUTESETTINGS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SystemConfComputeSettings = SystemConfComputeSettings;
    }
    InjectionArgument(nvmlSystemConfComputeSettings_t *SystemConfComputeSettingsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_SYSTEMCONFCOMPUTESETTINGS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SystemConfComputeSettingsPtr = SystemConfComputeSettingsPtr;
    }

    nvmlSystemConfComputeSettings_t *AsSystemConfComputeSettingsPtr() const
    {
        return m_value.SystemConfComputeSettingsPtr;
    }

    nvmlSystemConfComputeSettings_t const &AsSystemConfComputeSettings() const
    {
        return m_value.SystemConfComputeSettings;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlSystemDriverBranchInfo_t *SystemDriverBranchInfoPtr, bool inHeap = false)
        : m_type(INJECTION_SYSTEMDRIVERBRANCHINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SystemDriverBranchInfoPtr = SystemDriverBranchInfoPtr;
    }
    InjectionArgument(nvmlSystemDriverBranchInfo_t SystemDriverBranchInfo)
        : m_type(INJECTION_SYSTEMDRIVERBRANCHINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SystemDriverBranchInfo = SystemDriverBranchInfo;
    }
    InjectionArgument(nvmlSystemDriverBranchInfo_t *SystemDriverBranchInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_SYSTEMDRIVERBRANCHINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.SystemDriverBranchInfoPtr = SystemDriverBranchInfoPtr;
    }

    nvmlSystemDriverBranchInfo_t *AsSystemDriverBranchInfoPtr() const
    {
        return m_value.SystemDriverBranchInfoPtr;
    }

    nvmlSystemDriverBranchInfo_t const &AsSystemDriverBranchInfo() const
    {
        return m_value.SystemDriverBranchInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlTemperatureSensors_t *TemperatureSensorsPtr, bool inHeap = false)
        : m_type(INJECTION_TEMPERATURESENSORS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperatureSensorsPtr = TemperatureSensorsPtr;
    }
    InjectionArgument(nvmlTemperatureSensors_t TemperatureSensors)
        : m_type(INJECTION_TEMPERATURESENSORS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperatureSensors = TemperatureSensors;
    }
    InjectionArgument(nvmlTemperatureSensors_t *TemperatureSensorsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_TEMPERATURESENSORS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperatureSensorsPtr = TemperatureSensorsPtr;
    }

    nvmlTemperatureSensors_t *AsTemperatureSensorsPtr() const
    {
        return m_value.TemperatureSensorsPtr;
    }

    nvmlTemperatureSensors_t const &AsTemperatureSensors() const
    {
        return m_value.TemperatureSensors;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlTemperatureThresholds_t *TemperatureThresholdsPtr, bool inHeap = false)
        : m_type(INJECTION_TEMPERATURETHRESHOLDS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperatureThresholdsPtr = TemperatureThresholdsPtr;
    }
    InjectionArgument(nvmlTemperatureThresholds_t TemperatureThresholds)
        : m_type(INJECTION_TEMPERATURETHRESHOLDS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperatureThresholds = TemperatureThresholds;
    }
    InjectionArgument(nvmlTemperatureThresholds_t *TemperatureThresholdsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_TEMPERATURETHRESHOLDS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperatureThresholdsPtr = TemperatureThresholdsPtr;
    }

    nvmlTemperatureThresholds_t *AsTemperatureThresholdsPtr() const
    {
        return m_value.TemperatureThresholdsPtr;
    }

    nvmlTemperatureThresholds_t const &AsTemperatureThresholds() const
    {
        return m_value.TemperatureThresholds;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlTemperature_t *TemperaturePtr, bool inHeap = false)
        : m_type(INJECTION_TEMPERATURE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperaturePtr = TemperaturePtr;
    }
    InjectionArgument(nvmlTemperature_t Temperature)
        : m_type(INJECTION_TEMPERATURE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Temperature = Temperature;
    }
    InjectionArgument(nvmlTemperature_t *TemperaturePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_TEMPERATURE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.TemperaturePtr = TemperaturePtr;
    }

    nvmlTemperature_t *AsTemperaturePtr() const
    {
        return m_value.TemperaturePtr;
    }

    nvmlTemperature_t const &AsTemperature() const
    {
        return m_value.Temperature;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlThermalController_t *ThermalControllerPtr, bool inHeap = false)
        : m_type(INJECTION_THERMALCONTROLLER_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ThermalControllerPtr = ThermalControllerPtr;
    }
    InjectionArgument(nvmlThermalController_t ThermalController)
        : m_type(INJECTION_THERMALCONTROLLER)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ThermalController = ThermalController;
    }
    InjectionArgument(nvmlThermalController_t *ThermalControllerPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_THERMALCONTROLLER_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ThermalControllerPtr = ThermalControllerPtr;
    }

    nvmlThermalController_t *AsThermalControllerPtr() const
    {
        return m_value.ThermalControllerPtr;
    }

    nvmlThermalController_t const &AsThermalController() const
    {
        return m_value.ThermalController;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlThermalTarget_t *ThermalTargetPtr, bool inHeap = false)
        : m_type(INJECTION_THERMALTARGET_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ThermalTargetPtr = ThermalTargetPtr;
    }
    InjectionArgument(nvmlThermalTarget_t ThermalTarget)
        : m_type(INJECTION_THERMALTARGET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ThermalTarget = ThermalTarget;
    }
    InjectionArgument(nvmlThermalTarget_t *ThermalTargetPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_THERMALTARGET_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ThermalTargetPtr = ThermalTargetPtr;
    }

    nvmlThermalTarget_t *AsThermalTargetPtr() const
    {
        return m_value.ThermalTargetPtr;
    }

    nvmlThermalTarget_t const &AsThermalTarget() const
    {
        return m_value.ThermalTarget;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnitFanInfo_t *UnitFanInfoPtr, bool inHeap = false)
        : m_type(INJECTION_UNITFANINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitFanInfoPtr = UnitFanInfoPtr;
    }
    InjectionArgument(nvmlUnitFanInfo_t UnitFanInfo)
        : m_type(INJECTION_UNITFANINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitFanInfo = UnitFanInfo;
    }
    InjectionArgument(nvmlUnitFanInfo_t *UnitFanInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UNITFANINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitFanInfoPtr = UnitFanInfoPtr;
    }

    nvmlUnitFanInfo_t *AsUnitFanInfoPtr() const
    {
        return m_value.UnitFanInfoPtr;
    }

    nvmlUnitFanInfo_t const &AsUnitFanInfo() const
    {
        return m_value.UnitFanInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnitFanSpeeds_t *UnitFanSpeedsPtr, bool inHeap = false)
        : m_type(INJECTION_UNITFANSPEEDS_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitFanSpeedsPtr = UnitFanSpeedsPtr;
    }
    InjectionArgument(nvmlUnitFanSpeeds_t UnitFanSpeeds)
        : m_type(INJECTION_UNITFANSPEEDS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitFanSpeeds = UnitFanSpeeds;
    }
    InjectionArgument(nvmlUnitFanSpeeds_t *UnitFanSpeedsPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UNITFANSPEEDS_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitFanSpeedsPtr = UnitFanSpeedsPtr;
    }

    nvmlUnitFanSpeeds_t *AsUnitFanSpeedsPtr() const
    {
        return m_value.UnitFanSpeedsPtr;
    }

    nvmlUnitFanSpeeds_t const &AsUnitFanSpeeds() const
    {
        return m_value.UnitFanSpeeds;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnitInfo_t *UnitInfoPtr, bool inHeap = false)
        : m_type(INJECTION_UNITINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitInfoPtr = UnitInfoPtr;
    }
    InjectionArgument(nvmlUnitInfo_t UnitInfo)
        : m_type(INJECTION_UNITINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitInfo = UnitInfo;
    }
    InjectionArgument(nvmlUnitInfo_t *UnitInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UNITINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitInfoPtr = UnitInfoPtr;
    }

    nvmlUnitInfo_t *AsUnitInfoPtr() const
    {
        return m_value.UnitInfoPtr;
    }

    nvmlUnitInfo_t const &AsUnitInfo() const
    {
        return m_value.UnitInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUnit_t *UnitPtr, bool inHeap = false)
        : m_type(INJECTION_UNIT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitPtr = UnitPtr;
    }
    InjectionArgument(nvmlUnit_t Unit)
        : m_type(INJECTION_UNIT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Unit = Unit;
    }
    InjectionArgument(nvmlUnit_t *UnitPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UNIT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UnitPtr = UnitPtr;
    }

    nvmlUnit_t *AsUnitPtr() const
    {
        return m_value.UnitPtr;
    }

    nvmlUnit_t const &AsUnit() const
    {
        return m_value.Unit;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlUtilization_t *UtilizationPtr, bool inHeap = false)
        : m_type(INJECTION_UTILIZATION_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UtilizationPtr = UtilizationPtr;
    }
    InjectionArgument(nvmlUtilization_t Utilization)
        : m_type(INJECTION_UTILIZATION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Utilization = Utilization;
    }
    InjectionArgument(nvmlUtilization_t *UtilizationPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UTILIZATION_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UtilizationPtr = UtilizationPtr;
    }

    nvmlUtilization_t *AsUtilizationPtr() const
    {
        return m_value.UtilizationPtr;
    }

    nvmlUtilization_t const &AsUtilization() const
    {
        return m_value.Utilization;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlValueType_t *ValueTypePtr, bool inHeap = false)
        : m_type(INJECTION_VALUETYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ValueTypePtr = ValueTypePtr;
    }
    InjectionArgument(nvmlValueType_t ValueType)
        : m_type(INJECTION_VALUETYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ValueType = ValueType;
    }
    InjectionArgument(nvmlValueType_t *ValueTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VALUETYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ValueTypePtr = ValueTypePtr;
    }

    nvmlValueType_t *AsValueTypePtr() const
    {
        return m_value.ValueTypePtr;
    }

    nvmlValueType_t const &AsValueType() const
    {
        return m_value.ValueType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuCapability_t *VgpuCapabilityPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUCAPABILITY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuCapabilityPtr = VgpuCapabilityPtr;
    }
    InjectionArgument(nvmlVgpuCapability_t VgpuCapability)
        : m_type(INJECTION_VGPUCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuCapability = VgpuCapability;
    }
    InjectionArgument(nvmlVgpuCapability_t *VgpuCapabilityPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUCAPABILITY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuCapabilityPtr = VgpuCapabilityPtr;
    }

    nvmlVgpuCapability_t *AsVgpuCapabilityPtr() const
    {
        return m_value.VgpuCapabilityPtr;
    }

    nvmlVgpuCapability_t const &AsVgpuCapability() const
    {
        return m_value.VgpuCapability;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuDriverCapability_t *VgpuDriverCapabilityPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUDRIVERCAPABILITY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuDriverCapabilityPtr = VgpuDriverCapabilityPtr;
    }
    InjectionArgument(nvmlVgpuDriverCapability_t VgpuDriverCapability)
        : m_type(INJECTION_VGPUDRIVERCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuDriverCapability = VgpuDriverCapability;
    }
    InjectionArgument(nvmlVgpuDriverCapability_t *VgpuDriverCapabilityPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUDRIVERCAPABILITY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuDriverCapabilityPtr = VgpuDriverCapabilityPtr;
    }

    nvmlVgpuDriverCapability_t *AsVgpuDriverCapabilityPtr() const
    {
        return m_value.VgpuDriverCapabilityPtr;
    }

    nvmlVgpuDriverCapability_t const &AsVgpuDriverCapability() const
    {
        return m_value.VgpuDriverCapability;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuGuestInfoState_t *VgpuGuestInfoStatePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUGUESTINFOSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuGuestInfoStatePtr = VgpuGuestInfoStatePtr;
    }
    InjectionArgument(nvmlVgpuGuestInfoState_t VgpuGuestInfoState)
        : m_type(INJECTION_VGPUGUESTINFOSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuGuestInfoState = VgpuGuestInfoState;
    }
    InjectionArgument(nvmlVgpuGuestInfoState_t *VgpuGuestInfoStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUGUESTINFOSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuGuestInfoStatePtr = VgpuGuestInfoStatePtr;
    }

    nvmlVgpuGuestInfoState_t *AsVgpuGuestInfoStatePtr() const
    {
        return m_value.VgpuGuestInfoStatePtr;
    }

    nvmlVgpuGuestInfoState_t const &AsVgpuGuestInfoState() const
    {
        return m_value.VgpuGuestInfoState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuHeterogeneousMode_t *VgpuHeterogeneousModePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUHETEROGENEOUSMODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuHeterogeneousModePtr = VgpuHeterogeneousModePtr;
    }
    InjectionArgument(nvmlVgpuHeterogeneousMode_t VgpuHeterogeneousMode)
        : m_type(INJECTION_VGPUHETEROGENEOUSMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuHeterogeneousMode = VgpuHeterogeneousMode;
    }
    InjectionArgument(nvmlVgpuHeterogeneousMode_t *VgpuHeterogeneousModePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUHETEROGENEOUSMODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuHeterogeneousModePtr = VgpuHeterogeneousModePtr;
    }

    nvmlVgpuHeterogeneousMode_t *AsVgpuHeterogeneousModePtr() const
    {
        return m_value.VgpuHeterogeneousModePtr;
    }

    nvmlVgpuHeterogeneousMode_t const &AsVgpuHeterogeneousMode() const
    {
        return m_value.VgpuHeterogeneousMode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuInstanceUtilizationInfo_v1_t *VgpuInstanceUtilizationInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstanceUtilizationInfo_v1Ptr = VgpuInstanceUtilizationInfo_v1Ptr;
    }
    InjectionArgument(nvmlVgpuInstanceUtilizationInfo_v1_t VgpuInstanceUtilizationInfo_v1)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstanceUtilizationInfo_v1 = VgpuInstanceUtilizationInfo_v1;
    }
    InjectionArgument(nvmlVgpuInstanceUtilizationInfo_v1_t *VgpuInstanceUtilizationInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstanceUtilizationInfo_v1Ptr = VgpuInstanceUtilizationInfo_v1Ptr;
    }

    nvmlVgpuInstanceUtilizationInfo_v1_t *AsVgpuInstanceUtilizationInfo_v1Ptr() const
    {
        return m_value.VgpuInstanceUtilizationInfo_v1Ptr;
    }

    nvmlVgpuInstanceUtilizationInfo_v1_t const &AsVgpuInstanceUtilizationInfo_v1() const
    {
        return m_value.VgpuInstanceUtilizationInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuInstanceUtilizationSample_t *VgpuInstanceUtilizationSamplePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstanceUtilizationSamplePtr = VgpuInstanceUtilizationSamplePtr;
    }
    InjectionArgument(nvmlVgpuInstanceUtilizationSample_t VgpuInstanceUtilizationSample)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstanceUtilizationSample = VgpuInstanceUtilizationSample;
    }
    InjectionArgument(nvmlVgpuInstanceUtilizationSample_t *VgpuInstanceUtilizationSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstanceUtilizationSamplePtr = VgpuInstanceUtilizationSamplePtr;
    }

    nvmlVgpuInstanceUtilizationSample_t *AsVgpuInstanceUtilizationSamplePtr() const
    {
        return m_value.VgpuInstanceUtilizationSamplePtr;
    }

    nvmlVgpuInstanceUtilizationSample_t const &AsVgpuInstanceUtilizationSample() const
    {
        return m_value.VgpuInstanceUtilizationSample;
    }

    nvmlVgpuInstance_t *AsVgpuInstancePtr() const
    {
        return static_cast<nvmlVgpuInstance_t *>(m_value.UIntPtr);
    }

    nvmlVgpuInstance_t AsVgpuInstance() const
    {
        return static_cast<nvmlVgpuInstance_t>(m_value.UInt);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuInstancesUtilizationInfo_t *VgpuInstancesUtilizationInfoPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCESUTILIZATIONINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstancesUtilizationInfoPtr = VgpuInstancesUtilizationInfoPtr;
    }
    InjectionArgument(nvmlVgpuInstancesUtilizationInfo_t VgpuInstancesUtilizationInfo)
        : m_type(INJECTION_VGPUINSTANCESUTILIZATIONINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstancesUtilizationInfo = VgpuInstancesUtilizationInfo;
    }
    InjectionArgument(nvmlVgpuInstancesUtilizationInfo_t *VgpuInstancesUtilizationInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUINSTANCESUTILIZATIONINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuInstancesUtilizationInfoPtr = VgpuInstancesUtilizationInfoPtr;
    }

    nvmlVgpuInstancesUtilizationInfo_t *AsVgpuInstancesUtilizationInfoPtr() const
    {
        return m_value.VgpuInstancesUtilizationInfoPtr;
    }

    nvmlVgpuInstancesUtilizationInfo_t const &AsVgpuInstancesUtilizationInfo() const
    {
        return m_value.VgpuInstancesUtilizationInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuLicenseExpiry_t *VgpuLicenseExpiryPtr, bool inHeap = false)
        : m_type(INJECTION_VGPULICENSEEXPIRY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuLicenseExpiryPtr = VgpuLicenseExpiryPtr;
    }
    InjectionArgument(nvmlVgpuLicenseExpiry_t VgpuLicenseExpiry)
        : m_type(INJECTION_VGPULICENSEEXPIRY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuLicenseExpiry = VgpuLicenseExpiry;
    }
    InjectionArgument(nvmlVgpuLicenseExpiry_t *VgpuLicenseExpiryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPULICENSEEXPIRY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuLicenseExpiryPtr = VgpuLicenseExpiryPtr;
    }

    nvmlVgpuLicenseExpiry_t *AsVgpuLicenseExpiryPtr() const
    {
        return m_value.VgpuLicenseExpiryPtr;
    }

    nvmlVgpuLicenseExpiry_t const &AsVgpuLicenseExpiry() const
    {
        return m_value.VgpuLicenseExpiry;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuLicenseInfo_t *VgpuLicenseInfoPtr, bool inHeap = false)
        : m_type(INJECTION_VGPULICENSEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuLicenseInfoPtr = VgpuLicenseInfoPtr;
    }
    InjectionArgument(nvmlVgpuLicenseInfo_t VgpuLicenseInfo)
        : m_type(INJECTION_VGPULICENSEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuLicenseInfo = VgpuLicenseInfo;
    }
    InjectionArgument(nvmlVgpuLicenseInfo_t *VgpuLicenseInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPULICENSEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuLicenseInfoPtr = VgpuLicenseInfoPtr;
    }

    nvmlVgpuLicenseInfo_t *AsVgpuLicenseInfoPtr() const
    {
        return m_value.VgpuLicenseInfoPtr;
    }

    nvmlVgpuLicenseInfo_t const &AsVgpuLicenseInfo() const
    {
        return m_value.VgpuLicenseInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuMetadata_t *VgpuMetadataPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUMETADATA_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuMetadataPtr = VgpuMetadataPtr;
    }
    InjectionArgument(nvmlVgpuMetadata_t VgpuMetadata)
        : m_type(INJECTION_VGPUMETADATA)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuMetadata = VgpuMetadata;
    }
    InjectionArgument(nvmlVgpuMetadata_t *VgpuMetadataPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUMETADATA_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuMetadataPtr = VgpuMetadataPtr;
    }

    nvmlVgpuMetadata_t *AsVgpuMetadataPtr() const
    {
        return m_value.VgpuMetadataPtr;
    }

    nvmlVgpuMetadata_t const &AsVgpuMetadata() const
    {
        return m_value.VgpuMetadata;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPgpuCompatibilityLimitCode_t *VgpuPgpuCompatibilityLimitCodePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITYLIMITCODE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuCompatibilityLimitCodePtr = VgpuPgpuCompatibilityLimitCodePtr;
    }
    InjectionArgument(nvmlVgpuPgpuCompatibilityLimitCode_t VgpuPgpuCompatibilityLimitCode)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITYLIMITCODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuCompatibilityLimitCode = VgpuPgpuCompatibilityLimitCode;
    }
    InjectionArgument(nvmlVgpuPgpuCompatibilityLimitCode_t *VgpuPgpuCompatibilityLimitCodePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITYLIMITCODE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuCompatibilityLimitCodePtr = VgpuPgpuCompatibilityLimitCodePtr;
    }

    nvmlVgpuPgpuCompatibilityLimitCode_t *AsVgpuPgpuCompatibilityLimitCodePtr() const
    {
        return m_value.VgpuPgpuCompatibilityLimitCodePtr;
    }

    nvmlVgpuPgpuCompatibilityLimitCode_t const &AsVgpuPgpuCompatibilityLimitCode() const
    {
        return m_value.VgpuPgpuCompatibilityLimitCode;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPgpuCompatibility_t *VgpuPgpuCompatibilityPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuCompatibilityPtr = VgpuPgpuCompatibilityPtr;
    }
    InjectionArgument(nvmlVgpuPgpuCompatibility_t VgpuPgpuCompatibility)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuCompatibility = VgpuPgpuCompatibility;
    }
    InjectionArgument(nvmlVgpuPgpuCompatibility_t *VgpuPgpuCompatibilityPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuCompatibilityPtr = VgpuPgpuCompatibilityPtr;
    }

    nvmlVgpuPgpuCompatibility_t *AsVgpuPgpuCompatibilityPtr() const
    {
        return m_value.VgpuPgpuCompatibilityPtr;
    }

    nvmlVgpuPgpuCompatibility_t const &AsVgpuPgpuCompatibility() const
    {
        return m_value.VgpuPgpuCompatibility;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPgpuMetadata_t *VgpuPgpuMetadataPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUMETADATA_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuMetadataPtr = VgpuPgpuMetadataPtr;
    }
    InjectionArgument(nvmlVgpuPgpuMetadata_t VgpuPgpuMetadata)
        : m_type(INJECTION_VGPUPGPUMETADATA)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuMetadata = VgpuPgpuMetadata;
    }
    InjectionArgument(nvmlVgpuPgpuMetadata_t *VgpuPgpuMetadataPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPGPUMETADATA_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPgpuMetadataPtr = VgpuPgpuMetadataPtr;
    }

    nvmlVgpuPgpuMetadata_t *AsVgpuPgpuMetadataPtr() const
    {
        return m_value.VgpuPgpuMetadataPtr;
    }

    nvmlVgpuPgpuMetadata_t const &AsVgpuPgpuMetadata() const
    {
        return m_value.VgpuPgpuMetadata;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPlacementId_t *VgpuPlacementIdPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPLACEMENTID_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementIdPtr = VgpuPlacementIdPtr;
    }
    InjectionArgument(nvmlVgpuPlacementId_t VgpuPlacementId)
        : m_type(INJECTION_VGPUPLACEMENTID)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementId = VgpuPlacementId;
    }
    InjectionArgument(nvmlVgpuPlacementId_t *VgpuPlacementIdPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPLACEMENTID_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementIdPtr = VgpuPlacementIdPtr;
    }

    nvmlVgpuPlacementId_t *AsVgpuPlacementIdPtr() const
    {
        return m_value.VgpuPlacementIdPtr;
    }

    nvmlVgpuPlacementId_t const &AsVgpuPlacementId() const
    {
        return m_value.VgpuPlacementId;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPlacementList_t *VgpuPlacementListPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPLACEMENTLIST_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementListPtr = VgpuPlacementListPtr;
    }
    InjectionArgument(nvmlVgpuPlacementList_t VgpuPlacementList)
        : m_type(INJECTION_VGPUPLACEMENTLIST)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementList = VgpuPlacementList;
    }
    InjectionArgument(nvmlVgpuPlacementList_t *VgpuPlacementListPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPLACEMENTLIST_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementListPtr = VgpuPlacementListPtr;
    }

    nvmlVgpuPlacementList_t *AsVgpuPlacementListPtr() const
    {
        return m_value.VgpuPlacementListPtr;
    }

    nvmlVgpuPlacementList_t const &AsVgpuPlacementList() const
    {
        return m_value.VgpuPlacementList;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuPlacementList_v1_t *VgpuPlacementList_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_VGPUPLACEMENTLIST_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementList_v1Ptr = VgpuPlacementList_v1Ptr;
    }
    InjectionArgument(nvmlVgpuPlacementList_v1_t VgpuPlacementList_v1)
        : m_type(INJECTION_VGPUPLACEMENTLIST_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementList_v1 = VgpuPlacementList_v1;
    }
    InjectionArgument(nvmlVgpuPlacementList_v1_t *VgpuPlacementList_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPLACEMENTLIST_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuPlacementList_v1Ptr = VgpuPlacementList_v1Ptr;
    }

    nvmlVgpuPlacementList_v1_t *AsVgpuPlacementList_v1Ptr() const
    {
        return m_value.VgpuPlacementList_v1Ptr;
    }

    nvmlVgpuPlacementList_v1_t const &AsVgpuPlacementList_v1() const
    {
        return m_value.VgpuPlacementList_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuProcessUtilizationInfo_v1_t *VgpuProcessUtilizationInfo_v1Ptr, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONINFO_V1_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessUtilizationInfo_v1Ptr = VgpuProcessUtilizationInfo_v1Ptr;
    }
    InjectionArgument(nvmlVgpuProcessUtilizationInfo_v1_t VgpuProcessUtilizationInfo_v1)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONINFO_V1)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessUtilizationInfo_v1 = VgpuProcessUtilizationInfo_v1;
    }
    InjectionArgument(nvmlVgpuProcessUtilizationInfo_v1_t *VgpuProcessUtilizationInfo_v1Ptr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONINFO_V1_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessUtilizationInfo_v1Ptr = VgpuProcessUtilizationInfo_v1Ptr;
    }

    nvmlVgpuProcessUtilizationInfo_v1_t *AsVgpuProcessUtilizationInfo_v1Ptr() const
    {
        return m_value.VgpuProcessUtilizationInfo_v1Ptr;
    }

    nvmlVgpuProcessUtilizationInfo_v1_t const &AsVgpuProcessUtilizationInfo_v1() const
    {
        return m_value.VgpuProcessUtilizationInfo_v1;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuProcessUtilizationSample_t *VgpuProcessUtilizationSamplePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessUtilizationSamplePtr = VgpuProcessUtilizationSamplePtr;
    }
    InjectionArgument(nvmlVgpuProcessUtilizationSample_t VgpuProcessUtilizationSample)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessUtilizationSample = VgpuProcessUtilizationSample;
    }
    InjectionArgument(nvmlVgpuProcessUtilizationSample_t *VgpuProcessUtilizationSamplePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessUtilizationSamplePtr = VgpuProcessUtilizationSamplePtr;
    }

    nvmlVgpuProcessUtilizationSample_t *AsVgpuProcessUtilizationSamplePtr() const
    {
        return m_value.VgpuProcessUtilizationSamplePtr;
    }

    nvmlVgpuProcessUtilizationSample_t const &AsVgpuProcessUtilizationSample() const
    {
        return m_value.VgpuProcessUtilizationSample;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuProcessesUtilizationInfo_t *VgpuProcessesUtilizationInfoPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSESUTILIZATIONINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessesUtilizationInfoPtr = VgpuProcessesUtilizationInfoPtr;
    }
    InjectionArgument(nvmlVgpuProcessesUtilizationInfo_t VgpuProcessesUtilizationInfo)
        : m_type(INJECTION_VGPUPROCESSESUTILIZATIONINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessesUtilizationInfo = VgpuProcessesUtilizationInfo;
    }
    InjectionArgument(nvmlVgpuProcessesUtilizationInfo_t *VgpuProcessesUtilizationInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUPROCESSESUTILIZATIONINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuProcessesUtilizationInfoPtr = VgpuProcessesUtilizationInfoPtr;
    }

    nvmlVgpuProcessesUtilizationInfo_t *AsVgpuProcessesUtilizationInfoPtr() const
    {
        return m_value.VgpuProcessesUtilizationInfoPtr;
    }

    nvmlVgpuProcessesUtilizationInfo_t const &AsVgpuProcessesUtilizationInfo() const
    {
        return m_value.VgpuProcessesUtilizationInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuSchedulerCapabilities_t *VgpuSchedulerCapabilitiesPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERCAPABILITIES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerCapabilitiesPtr = VgpuSchedulerCapabilitiesPtr;
    }
    InjectionArgument(nvmlVgpuSchedulerCapabilities_t VgpuSchedulerCapabilities)
        : m_type(INJECTION_VGPUSCHEDULERCAPABILITIES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerCapabilities = VgpuSchedulerCapabilities;
    }
    InjectionArgument(nvmlVgpuSchedulerCapabilities_t *VgpuSchedulerCapabilitiesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERCAPABILITIES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerCapabilitiesPtr = VgpuSchedulerCapabilitiesPtr;
    }

    nvmlVgpuSchedulerCapabilities_t *AsVgpuSchedulerCapabilitiesPtr() const
    {
        return m_value.VgpuSchedulerCapabilitiesPtr;
    }

    nvmlVgpuSchedulerCapabilities_t const &AsVgpuSchedulerCapabilities() const
    {
        return m_value.VgpuSchedulerCapabilities;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuSchedulerGetState_t *VgpuSchedulerGetStatePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERGETSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerGetStatePtr = VgpuSchedulerGetStatePtr;
    }
    InjectionArgument(nvmlVgpuSchedulerGetState_t VgpuSchedulerGetState)
        : m_type(INJECTION_VGPUSCHEDULERGETSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerGetState = VgpuSchedulerGetState;
    }
    InjectionArgument(nvmlVgpuSchedulerGetState_t *VgpuSchedulerGetStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERGETSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerGetStatePtr = VgpuSchedulerGetStatePtr;
    }

    nvmlVgpuSchedulerGetState_t *AsVgpuSchedulerGetStatePtr() const
    {
        return m_value.VgpuSchedulerGetStatePtr;
    }

    nvmlVgpuSchedulerGetState_t const &AsVgpuSchedulerGetState() const
    {
        return m_value.VgpuSchedulerGetState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuSchedulerLogEntry_t *VgpuSchedulerLogEntryPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERLOGENTRY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerLogEntryPtr = VgpuSchedulerLogEntryPtr;
    }
    InjectionArgument(nvmlVgpuSchedulerLogEntry_t VgpuSchedulerLogEntry)
        : m_type(INJECTION_VGPUSCHEDULERLOGENTRY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerLogEntry = VgpuSchedulerLogEntry;
    }
    InjectionArgument(nvmlVgpuSchedulerLogEntry_t *VgpuSchedulerLogEntryPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERLOGENTRY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerLogEntryPtr = VgpuSchedulerLogEntryPtr;
    }

    nvmlVgpuSchedulerLogEntry_t *AsVgpuSchedulerLogEntryPtr() const
    {
        return m_value.VgpuSchedulerLogEntryPtr;
    }

    nvmlVgpuSchedulerLogEntry_t const &AsVgpuSchedulerLogEntry() const
    {
        return m_value.VgpuSchedulerLogEntry;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuSchedulerLog_t *VgpuSchedulerLogPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERLOG_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerLogPtr = VgpuSchedulerLogPtr;
    }
    InjectionArgument(nvmlVgpuSchedulerLog_t VgpuSchedulerLog)
        : m_type(INJECTION_VGPUSCHEDULERLOG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerLog = VgpuSchedulerLog;
    }
    InjectionArgument(nvmlVgpuSchedulerLog_t *VgpuSchedulerLogPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERLOG_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerLogPtr = VgpuSchedulerLogPtr;
    }

    nvmlVgpuSchedulerLog_t *AsVgpuSchedulerLogPtr() const
    {
        return m_value.VgpuSchedulerLogPtr;
    }

    nvmlVgpuSchedulerLog_t const &AsVgpuSchedulerLog() const
    {
        return m_value.VgpuSchedulerLog;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuSchedulerSetState_t *VgpuSchedulerSetStatePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERSETSTATE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerSetStatePtr = VgpuSchedulerSetStatePtr;
    }
    InjectionArgument(nvmlVgpuSchedulerSetState_t VgpuSchedulerSetState)
        : m_type(INJECTION_VGPUSCHEDULERSETSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerSetState = VgpuSchedulerSetState;
    }
    InjectionArgument(nvmlVgpuSchedulerSetState_t *VgpuSchedulerSetStatePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUSCHEDULERSETSTATE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuSchedulerSetStatePtr = VgpuSchedulerSetStatePtr;
    }

    nvmlVgpuSchedulerSetState_t *AsVgpuSchedulerSetStatePtr() const
    {
        return m_value.VgpuSchedulerSetStatePtr;
    }

    nvmlVgpuSchedulerSetState_t const &AsVgpuSchedulerSetState() const
    {
        return m_value.VgpuSchedulerSetState;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuTypeBar1Info_t *VgpuTypeBar1InfoPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUTYPEBAR1INFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuTypeBar1InfoPtr = VgpuTypeBar1InfoPtr;
    }
    InjectionArgument(nvmlVgpuTypeBar1Info_t VgpuTypeBar1Info)
        : m_type(INJECTION_VGPUTYPEBAR1INFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuTypeBar1Info = VgpuTypeBar1Info;
    }
    InjectionArgument(nvmlVgpuTypeBar1Info_t *VgpuTypeBar1InfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUTYPEBAR1INFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuTypeBar1InfoPtr = VgpuTypeBar1InfoPtr;
    }

    nvmlVgpuTypeBar1Info_t *AsVgpuTypeBar1InfoPtr() const
    {
        return m_value.VgpuTypeBar1InfoPtr;
    }

    nvmlVgpuTypeBar1Info_t const &AsVgpuTypeBar1Info() const
    {
        return m_value.VgpuTypeBar1Info;
    }

    nvmlVgpuTypeId_t *AsVgpuTypeIdPtr() const
    {
        return static_cast<nvmlVgpuTypeId_t *>(m_value.UIntPtr);
    }

    nvmlVgpuTypeId_t AsVgpuTypeId() const
    {
        return static_cast<nvmlVgpuTypeId_t>(m_value.UInt);
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuVersion_t *VgpuVersionPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUVERSION_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVersionPtr = VgpuVersionPtr;
    }
    InjectionArgument(nvmlVgpuVersion_t VgpuVersion)
        : m_type(INJECTION_VGPUVERSION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVersion = VgpuVersion;
    }
    InjectionArgument(nvmlVgpuVersion_t *VgpuVersionPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUVERSION_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVersionPtr = VgpuVersionPtr;
    }

    nvmlVgpuVersion_t *AsVgpuVersionPtr() const
    {
        return m_value.VgpuVersionPtr;
    }

    nvmlVgpuVersion_t const &AsVgpuVersion() const
    {
        return m_value.VgpuVersion;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuVmCompatibility_t *VgpuVmCompatibilityPtr, bool inHeap = false)
        : m_type(INJECTION_VGPUVMCOMPATIBILITY_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVmCompatibilityPtr = VgpuVmCompatibilityPtr;
    }
    InjectionArgument(nvmlVgpuVmCompatibility_t VgpuVmCompatibility)
        : m_type(INJECTION_VGPUVMCOMPATIBILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVmCompatibility = VgpuVmCompatibility;
    }
    InjectionArgument(nvmlVgpuVmCompatibility_t *VgpuVmCompatibilityPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUVMCOMPATIBILITY_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVmCompatibilityPtr = VgpuVmCompatibilityPtr;
    }

    nvmlVgpuVmCompatibility_t *AsVgpuVmCompatibilityPtr() const
    {
        return m_value.VgpuVmCompatibilityPtr;
    }

    nvmlVgpuVmCompatibility_t const &AsVgpuVmCompatibility() const
    {
        return m_value.VgpuVmCompatibility;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlVgpuVmIdType_t *VgpuVmIdTypePtr, bool inHeap = false)
        : m_type(INJECTION_VGPUVMIDTYPE_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVmIdTypePtr = VgpuVmIdTypePtr;
    }
    InjectionArgument(nvmlVgpuVmIdType_t VgpuVmIdType)
        : m_type(INJECTION_VGPUVMIDTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVmIdType = VgpuVmIdType;
    }
    InjectionArgument(nvmlVgpuVmIdType_t *VgpuVmIdTypePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VGPUVMIDTYPE_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.VgpuVmIdTypePtr = VgpuVmIdTypePtr;
    }

    nvmlVgpuVmIdType_t *AsVgpuVmIdTypePtr() const
    {
        return m_value.VgpuVmIdTypePtr;
    }

    nvmlVgpuVmIdType_t const &AsVgpuVmIdType() const
    {
        return m_value.VgpuVmIdType;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlViolationTime_t *ViolationTimePtr, bool inHeap = false)
        : m_type(INJECTION_VIOLATIONTIME_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ViolationTimePtr = ViolationTimePtr;
    }
    InjectionArgument(nvmlViolationTime_t ViolationTime)
        : m_type(INJECTION_VIOLATIONTIME)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ViolationTime = ViolationTime;
    }
    InjectionArgument(nvmlViolationTime_t *ViolationTimePtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_VIOLATIONTIME_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ViolationTimePtr = ViolationTimePtr;
    }

    nvmlViolationTime_t *AsViolationTimePtr() const
    {
        return m_value.ViolationTimePtr;
    }

    nvmlViolationTime_t const &AsViolationTime() const
    {
        return m_value.ViolationTime;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlWorkloadPowerProfileCurrentProfiles_t *WorkloadPowerProfileCurrentProfilesPtr, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILECURRENTPROFILES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileCurrentProfilesPtr = WorkloadPowerProfileCurrentProfilesPtr;
    }
    InjectionArgument(nvmlWorkloadPowerProfileCurrentProfiles_t WorkloadPowerProfileCurrentProfiles)
        : m_type(INJECTION_WORKLOADPOWERPROFILECURRENTPROFILES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileCurrentProfiles = WorkloadPowerProfileCurrentProfiles;
    }
    InjectionArgument(nvmlWorkloadPowerProfileCurrentProfiles_t *WorkloadPowerProfileCurrentProfilesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILECURRENTPROFILES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileCurrentProfilesPtr = WorkloadPowerProfileCurrentProfilesPtr;
    }

    nvmlWorkloadPowerProfileCurrentProfiles_t *AsWorkloadPowerProfileCurrentProfilesPtr() const
    {
        return m_value.WorkloadPowerProfileCurrentProfilesPtr;
    }

    nvmlWorkloadPowerProfileCurrentProfiles_t const &AsWorkloadPowerProfileCurrentProfiles() const
    {
        return m_value.WorkloadPowerProfileCurrentProfiles;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlWorkloadPowerProfileInfo_t *WorkloadPowerProfileInfoPtr, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILEINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileInfoPtr = WorkloadPowerProfileInfoPtr;
    }
    InjectionArgument(nvmlWorkloadPowerProfileInfo_t WorkloadPowerProfileInfo)
        : m_type(INJECTION_WORKLOADPOWERPROFILEINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileInfo = WorkloadPowerProfileInfo;
    }
    InjectionArgument(nvmlWorkloadPowerProfileInfo_t *WorkloadPowerProfileInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILEINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileInfoPtr = WorkloadPowerProfileInfoPtr;
    }

    nvmlWorkloadPowerProfileInfo_t *AsWorkloadPowerProfileInfoPtr() const
    {
        return m_value.WorkloadPowerProfileInfoPtr;
    }

    nvmlWorkloadPowerProfileInfo_t const &AsWorkloadPowerProfileInfo() const
    {
        return m_value.WorkloadPowerProfileInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlWorkloadPowerProfileProfilesInfo_t *WorkloadPowerProfileProfilesInfoPtr, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILEPROFILESINFO_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileProfilesInfoPtr = WorkloadPowerProfileProfilesInfoPtr;
    }
    InjectionArgument(nvmlWorkloadPowerProfileProfilesInfo_t WorkloadPowerProfileProfilesInfo)
        : m_type(INJECTION_WORKLOADPOWERPROFILEPROFILESINFO)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileProfilesInfo = WorkloadPowerProfileProfilesInfo;
    }
    InjectionArgument(nvmlWorkloadPowerProfileProfilesInfo_t *WorkloadPowerProfileProfilesInfoPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILEPROFILESINFO_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileProfilesInfoPtr = WorkloadPowerProfileProfilesInfoPtr;
    }

    nvmlWorkloadPowerProfileProfilesInfo_t *AsWorkloadPowerProfileProfilesInfoPtr() const
    {
        return m_value.WorkloadPowerProfileProfilesInfoPtr;
    }

    nvmlWorkloadPowerProfileProfilesInfo_t const &AsWorkloadPowerProfileProfilesInfo() const
    {
        return m_value.WorkloadPowerProfileProfilesInfo;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(nvmlWorkloadPowerProfileRequestedProfiles_t *WorkloadPowerProfileRequestedProfilesPtr, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILEREQUESTEDPROFILES_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileRequestedProfilesPtr = WorkloadPowerProfileRequestedProfilesPtr;
    }
    InjectionArgument(nvmlWorkloadPowerProfileRequestedProfiles_t WorkloadPowerProfileRequestedProfiles)
        : m_type(INJECTION_WORKLOADPOWERPROFILEREQUESTEDPROFILES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileRequestedProfiles = WorkloadPowerProfileRequestedProfiles;
    }
    InjectionArgument(nvmlWorkloadPowerProfileRequestedProfiles_t *WorkloadPowerProfileRequestedProfilesPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_WORKLOADPOWERPROFILEREQUESTEDPROFILES_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.WorkloadPowerProfileRequestedProfilesPtr = WorkloadPowerProfileRequestedProfilesPtr;
    }

    nvmlWorkloadPowerProfileRequestedProfiles_t *AsWorkloadPowerProfileRequestedProfilesPtr() const
    {
        return m_value.WorkloadPowerProfileRequestedProfilesPtr;
    }

    nvmlWorkloadPowerProfileRequestedProfiles_t const &AsWorkloadPowerProfileRequestedProfiles() const
    {
        return m_value.WorkloadPowerProfileRequestedProfiles;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(short *ShortPtr, bool inHeap = false)
        : m_type(INJECTION_SHORT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ShortPtr = ShortPtr;
    }
    InjectionArgument(short Short)
        : m_type(INJECTION_SHORT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.Short = Short;
    }
    InjectionArgument(short *ShortPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_SHORT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ShortPtr = ShortPtr;
    }

    short *AsShortPtr() const
    {
        return m_value.ShortPtr;
    }

    short const &AsShort() const
    {
        return m_value.Short;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned char *UCharPtr, bool inHeap = false)
        : m_type(INJECTION_UCHAR_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UCharPtr = UCharPtr;
    }
    InjectionArgument(unsigned char UChar)
        : m_type(INJECTION_UCHAR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UChar = UChar;
    }
    InjectionArgument(unsigned char *UCharPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UCHAR_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UCharPtr = UCharPtr;
    }

    unsigned char *AsUCharPtr() const
    {
        return m_value.UCharPtr;
    }

    unsigned char const &AsUChar() const
    {
        return m_value.UChar;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned int *UIntPtr, bool inHeap = false)
        : m_type(INJECTION_UINT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UIntPtr = UIntPtr;
    }
    InjectionArgument(unsigned int UInt)
        : m_type(INJECTION_UINT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UInt = UInt;
    }
    InjectionArgument(unsigned int *UIntPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_UINT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UIntPtr = UIntPtr;
    }

    unsigned int *AsUIntPtr() const
    {
        return m_value.UIntPtr;
    }

    unsigned int const &AsUInt() const
    {
        return m_value.UInt;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned long *ULongPtr, bool inHeap = false)
        : m_type(INJECTION_ULONG_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ULongPtr = ULongPtr;
    }
    InjectionArgument(unsigned long ULong)
        : m_type(INJECTION_ULONG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ULong = ULong;
    }
    InjectionArgument(unsigned long *ULongPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ULONG_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ULongPtr = ULongPtr;
    }

    unsigned long *AsULongPtr() const
    {
        return m_value.ULongPtr;
    }

    unsigned long const &AsULong() const
    {
        return m_value.ULong;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned long long *ULongLongPtr, bool inHeap = false)
        : m_type(INJECTION_ULONG_LONG_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ULongLongPtr = ULongLongPtr;
    }
    InjectionArgument(unsigned long long ULongLong)
        : m_type(INJECTION_ULONG_LONG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ULongLong = ULongLong;
    }
    InjectionArgument(unsigned long long *ULongLongPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_ULONG_LONG_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ULongLongPtr = ULongLongPtr;
    }

    unsigned long long *AsULongLongPtr() const
    {
        return m_value.ULongLongPtr;
    }

    unsigned long long const &AsULongLong() const
    {
        return m_value.ULongLong;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(unsigned short *UShortPtr, bool inHeap = false)
        : m_type(INJECTION_USHORT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UShortPtr = UShortPtr;
    }
    InjectionArgument(unsigned short UShort)
        : m_type(INJECTION_USHORT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UShort = UShort;
    }
    InjectionArgument(unsigned short *UShortPtr, unsigned int arrLen, bool inHeap = false)
        : m_type(INJECTION_USHORT_PTR), m_isArray(true), m_arrLen(arrLen), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.UShortPtr = UShortPtr;
    }

    unsigned short *AsUShortPtr() const
    {
        return m_value.UShortPtr;
    }

    unsigned short const &AsUShort() const
    {
        return m_value.UShort;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(const nvmlGpuInstancePlacement_t *ConstGpuInstancePlacementPtr, bool inHeap = false)
        : m_type(INJECTION_CONST_GPUINSTANCEPLACEMENT_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConstGpuInstancePlacementPtr = ConstGpuInstancePlacementPtr;
    }
    const nvmlGpuInstancePlacement_t *AsConstGpuInstancePlacementPtr() const
    {
        return m_value.ConstGpuInstancePlacementPtr;
    }

    // The following snippet is generated from write_injection_argument_header
    InjectionArgument(const char *ConstStr, bool inHeap = false)
        : m_type(INJECTION_CONST_CHAR_PTR), m_inHeap(inHeap)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ConstStr = ConstStr;
    }
    const char *AsConstStr() const
    {
        return m_value.ConstStr;
    }

    // The following snippet is generated from write_injection_argument_copy_constructor
    InjectionArgument &operator=(const InjectionArgument &other)
    {
        DeepCopy(other);
        return *this;
    }

    // The following snippet is generated from write_injection_argument_copy_constructor
    InjectionArgument(const InjectionArgument &other)
    {
        DeepCopy(other);
    }

    ~InjectionArgument();

    InjectionArgument(const std::string &val)
        : m_type(INJECTION_STRING)
        , m_str(val)
    {
        memset(&m_value, 0, sizeof(m_value));
    }
    std::string AsString() const
    {
        switch (m_type)
        {
            case INJECTION_STRING:
            {
                return m_str;
            }
                break;
            case INJECTION_CHAR_PTR:
            {
                if (m_value.Str != nullptr)
                {
                    return std::string(m_value.Str);
                }
                break;
            }
            case INJECTION_CONST_CHAR_PTR:
            {
                if (m_value.ConstStr != nullptr)
                {
                    return std::string(m_value.ConstStr);
                }
                break;
            }
            default:
                break;
        }
        return "";
    }
};
