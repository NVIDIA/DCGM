/*
 * NOTE: This code is auto-generated by generate_nvml_stubs.py
 * DO NOT EDIT MANUALLY
 */


#pragma once

#include <cstring>
#include <nvml.h>
#include <string>

#include "nvml_injection_structs.h"

class InjectionArgument
{
private:
    injectionArgType_t m_type;
    simpleValue_t m_value;
    std::string m_str;

public:
    InjectionArgument()
        : m_type(InjectionArgCount)
    {
        Clear();
    }

    InjectionArgument(const injectNvmlVal_t &value)
        : m_type(value.type)
        , m_value(value.value)
    {}

    /**
     * SetValueFrom - Sets this injection argument based other's value
     * @param other - the InjectionArgument whose value we flexibly copy if possible.
     *
     * @return 0 if we could set from other's value, 1 if incompatible
     **/
    nvmlReturn_t SetValueFrom(const InjectionArgument &other);

    injectionArgType_t GetType() const
    {
        return m_type;
    }

    simpleValue_t GetSimpleValue() const
    {
        return m_value;
    }

    void Clear()
    {
        memset(&m_value, 0, sizeof(m_value));
    }
    int Compare(const InjectionArgument &other) const
    {
        if (m_type < other.m_type)
        {
            return -1;
        }
        else if (m_type > other.m_type)
        {
            return 1;
        }
        else
        {
            if (m_type == INJECTION_STRING)
            {
                if (m_str < other.m_str)
                {
                    return -1;
                }
                else if (m_str > other.m_str)
                {
                    return 1;
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                switch (m_type)
                {
                    case INJECTION_CHAR_PTR:
                    {
                        return strcmp(m_value.str, other.m_value.str);
                        break; // NOT REACHED
                    }
                    case INJECTION_CONST_CHAR_PTR:
                    {
                        return strcmp(m_value.const_str, other.m_value.const_str);
                        break; // NOT REACHED
                    }
                    case INJECTION_CONST_NVMLGPUINSTANCEPLACEMENT_T_PTR:
                    {
                        return memcmp(m_value.cnPtr, other.m_value.cnPtr, sizeof(*m_value.cnPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_INT:
                    {
                        if (m_value.i < other.m_value.i)
                        {
                            return -1;
                        }
                        else if (m_value.i > other.m_value.i)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_INT_PTR:
                    {
                        return memcmp(m_value.iPtr, other.m_value.iPtr, sizeof(*m_value.iPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ACCOUNTINGSTATS_PTR:
                    {
                        return memcmp(m_value.accountingStatsPtr,
                                      other.m_value.accountingStatsPtr,
                                      sizeof(*m_value.accountingStatsPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_BAR1MEMORY_PTR:
                    {
                        return memcmp(
                            m_value.bar1MemoryPtr, other.m_value.bar1MemoryPtr, sizeof(*m_value.bar1MemoryPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_BRANDTYPE_PTR:
                    {
                        return memcmp(m_value.brandTypePtr, other.m_value.brandTypePtr, sizeof(*m_value.brandTypePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_BRIDGECHIPHIERARCHY_PTR:
                    {
                        return memcmp(m_value.bridgeChipHierarchyPtr,
                                      other.m_value.bridgeChipHierarchyPtr,
                                      sizeof(*m_value.bridgeChipHierarchyPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_CLOCKID:
                    {
                        if (m_value.clockId < other.m_value.clockId)
                        {
                            return -1;
                        }
                        else if (m_value.clockId > other.m_value.clockId)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_CLOCKTYPE:
                    {
                        if (m_value.clockType < other.m_value.clockType)
                        {
                            return -1;
                        }
                        else if (m_value.clockType > other.m_value.clockType)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_COMPUTEINSTANCEINFO_PTR:
                    {
                        return memcmp(m_value.computeInstanceInfoPtr,
                                      other.m_value.computeInstanceInfoPtr,
                                      sizeof(*m_value.computeInstanceInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR:
                    {
                        return memcmp(m_value.computeInstanceProfileInfoPtr,
                                      other.m_value.computeInstanceProfileInfoPtr,
                                      sizeof(*m_value.computeInstanceProfileInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR:
                    {
                        return memcmp(m_value.computeInstanceProfileInfo_v2Ptr,
                                      other.m_value.computeInstanceProfileInfo_v2Ptr,
                                      sizeof(*m_value.computeInstanceProfileInfo_v2Ptr));
                        break; // NOT REACHED
                    }
                    case INJECTION_COMPUTEINSTANCE:
                    {
                        if (m_value.computeInstance < other.m_value.computeInstance)
                        {
                            return -1;
                        }
                        else if (m_value.computeInstance > other.m_value.computeInstance)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_COMPUTEINSTANCE_PTR:
                    {
                        return memcmp(m_value.computeInstancePtr,
                                      other.m_value.computeInstancePtr,
                                      sizeof(*m_value.computeInstancePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_COMPUTEMODE:
                    {
                        if (m_value.computeMode < other.m_value.computeMode)
                        {
                            return -1;
                        }
                        else if (m_value.computeMode > other.m_value.computeMode)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_COMPUTEMODE_PTR:
                    {
                        return memcmp(
                            m_value.computeModePtr, other.m_value.computeModePtr, sizeof(*m_value.computeModePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_CONFCOMPUTESYSTEMSTATE_PTR:
                    {
                        return memcmp(m_value.confComputeSystemStatePtr,
                                      other.m_value.confComputeSystemStatePtr,
                                      sizeof(*m_value.confComputeSystemStatePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_DETACHGPUSTATE:
                    {
                        if (m_value.detachGpuState < other.m_value.detachGpuState)
                        {
                            return -1;
                        }
                        else if (m_value.detachGpuState > other.m_value.detachGpuState)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_DEVICEATTRIBUTES_PTR:
                    {
                        return memcmp(m_value.deviceAttributesPtr,
                                      other.m_value.deviceAttributesPtr,
                                      sizeof(*m_value.deviceAttributesPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_DEVICE:
                    {
                        if (m_value.device < other.m_value.device)
                        {
                            return -1;
                        }
                        else if (m_value.device > other.m_value.device)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_DEVICE_PTR:
                    {
                        return memcmp(m_value.devicePtr, other.m_value.devicePtr, sizeof(*m_value.devicePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_DRIVERMODEL:
                    {
                        if (m_value.driverModel < other.m_value.driverModel)
                        {
                            return -1;
                        }
                        else if (m_value.driverModel > other.m_value.driverModel)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_DRIVERMODEL_PTR:
                    {
                        return memcmp(
                            m_value.driverModelPtr, other.m_value.driverModelPtr, sizeof(*m_value.driverModelPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ECCCOUNTERTYPE:
                    {
                        if (m_value.eccCounterType < other.m_value.eccCounterType)
                        {
                            return -1;
                        }
                        else if (m_value.eccCounterType > other.m_value.eccCounterType)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_ECCERRORCOUNTS_PTR:
                    {
                        return memcmp(m_value.eccErrorCountsPtr,
                                      other.m_value.eccErrorCountsPtr,
                                      sizeof(*m_value.eccErrorCountsPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ENABLESTATE:
                    {
                        if (m_value.enableState < other.m_value.enableState)
                        {
                            return -1;
                        }
                        else if (m_value.enableState > other.m_value.enableState)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_ENABLESTATE_PTR:
                    {
                        return memcmp(
                            m_value.enableStatePtr, other.m_value.enableStatePtr, sizeof(*m_value.enableStatePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ENCODERSESSIONINFO_PTR:
                    {
                        return memcmp(m_value.encoderSessionInfoPtr,
                                      other.m_value.encoderSessionInfoPtr,
                                      sizeof(*m_value.encoderSessionInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ENCODERTYPE:
                    {
                        if (m_value.encoderType < other.m_value.encoderType)
                        {
                            return -1;
                        }
                        else if (m_value.encoderType > other.m_value.encoderType)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_EVENTDATA_PTR:
                    {
                        return memcmp(m_value.eventDataPtr, other.m_value.eventDataPtr, sizeof(*m_value.eventDataPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_EVENTSET:
                    {
                        if (m_value.eventSet < other.m_value.eventSet)
                        {
                            return -1;
                        }
                        else if (m_value.eventSet > other.m_value.eventSet)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_EVENTSET_PTR:
                    {
                        return memcmp(m_value.eventSetPtr, other.m_value.eventSetPtr, sizeof(*m_value.eventSetPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_EXCLUDEDDEVICEINFO_PTR:
                    {
                        return memcmp(m_value.excludedDeviceInfoPtr,
                                      other.m_value.excludedDeviceInfoPtr,
                                      sizeof(*m_value.excludedDeviceInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_FBCSESSIONINFO_PTR:
                    {
                        return memcmp(m_value.fBCSessionInfoPtr,
                                      other.m_value.fBCSessionInfoPtr,
                                      sizeof(*m_value.fBCSessionInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_FBCSTATS_PTR:
                    {
                        return memcmp(m_value.fBCStatsPtr, other.m_value.fBCStatsPtr, sizeof(*m_value.fBCStatsPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_FIELDVALUE_PTR:
                    {
                        return memcmp(
                            m_value.fieldValuePtr, other.m_value.fieldValuePtr, sizeof(*m_value.fieldValuePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPMMETRICSGET_PTR:
                    {
                        return memcmp(m_value.gpmMetricsGetPtr,
                                      other.m_value.gpmMetricsGetPtr,
                                      sizeof(*m_value.gpmMetricsGetPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPMSAMPLE:
                    {
                        if (m_value.gpmSample < other.m_value.gpmSample)
                        {
                            return -1;
                        }
                        else if (m_value.gpmSample > other.m_value.gpmSample)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_GPMSAMPLE_PTR:
                    {
                        return memcmp(m_value.gpmSamplePtr, other.m_value.gpmSamplePtr, sizeof(*m_value.gpmSamplePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPMSUPPORT_PTR:
                    {
                        return memcmp(
                            m_value.gpmSupportPtr, other.m_value.gpmSupportPtr, sizeof(*m_value.gpmSupportPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUDYNAMICPSTATESINFO_PTR:
                    {
                        return memcmp(m_value.gpuDynamicPstatesInfoPtr,
                                      other.m_value.gpuDynamicPstatesInfoPtr,
                                      sizeof(*m_value.gpuDynamicPstatesInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUINSTANCEINFO_PTR:
                    {
                        return memcmp(m_value.gpuInstanceInfoPtr,
                                      other.m_value.gpuInstanceInfoPtr,
                                      sizeof(*m_value.gpuInstanceInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUINSTANCEPLACEMENT_PTR:
                    {
                        return memcmp(m_value.gpuInstancePlacementPtr,
                                      other.m_value.gpuInstancePlacementPtr,
                                      sizeof(*m_value.gpuInstancePlacementPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUINSTANCEPROFILEINFO_PTR:
                    {
                        return memcmp(m_value.gpuInstanceProfileInfoPtr,
                                      other.m_value.gpuInstanceProfileInfoPtr,
                                      sizeof(*m_value.gpuInstanceProfileInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR:
                    {
                        return memcmp(m_value.gpuInstanceProfileInfo_v2Ptr,
                                      other.m_value.gpuInstanceProfileInfo_v2Ptr,
                                      sizeof(*m_value.gpuInstanceProfileInfo_v2Ptr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUINSTANCE:
                    {
                        if (m_value.gpuInstance < other.m_value.gpuInstance)
                        {
                            return -1;
                        }
                        else if (m_value.gpuInstance > other.m_value.gpuInstance)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUINSTANCE_PTR:
                    {
                        return memcmp(
                            m_value.gpuInstancePtr, other.m_value.gpuInstancePtr, sizeof(*m_value.gpuInstancePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUOPERATIONMODE:
                    {
                        if (m_value.gpuOperationMode < other.m_value.gpuOperationMode)
                        {
                            return -1;
                        }
                        else if (m_value.gpuOperationMode > other.m_value.gpuOperationMode)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUOPERATIONMODE_PTR:
                    {
                        return memcmp(m_value.gpuOperationModePtr,
                                      other.m_value.gpuOperationModePtr,
                                      sizeof(*m_value.gpuOperationModePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUP2PCAPSINDEX:
                    {
                        if (m_value.gpuP2PCapsIndex < other.m_value.gpuP2PCapsIndex)
                        {
                            return -1;
                        }
                        else if (m_value.gpuP2PCapsIndex > other.m_value.gpuP2PCapsIndex)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUP2PSTATUS_PTR:
                    {
                        return memcmp(
                            m_value.gpuP2PStatusPtr, other.m_value.gpuP2PStatusPtr, sizeof(*m_value.gpuP2PStatusPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUTHERMALSETTINGS_PTR:
                    {
                        return memcmp(m_value.gpuThermalSettingsPtr,
                                      other.m_value.gpuThermalSettingsPtr,
                                      sizeof(*m_value.gpuThermalSettingsPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUTOPOLOGYLEVEL:
                    {
                        if (m_value.gpuTopologyLevel < other.m_value.gpuTopologyLevel)
                        {
                            return -1;
                        }
                        else if (m_value.gpuTopologyLevel > other.m_value.gpuTopologyLevel)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUTOPOLOGYLEVEL_PTR:
                    {
                        return memcmp(m_value.gpuTopologyLevelPtr,
                                      other.m_value.gpuTopologyLevelPtr,
                                      sizeof(*m_value.gpuTopologyLevelPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUVIRTUALIZATIONMODE:
                    {
                        if (m_value.gpuVirtualizationMode < other.m_value.gpuVirtualizationMode)
                        {
                            return -1;
                        }
                        else if (m_value.gpuVirtualizationMode > other.m_value.gpuVirtualizationMode)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_GPUVIRTUALIZATIONMODE_PTR:
                    {
                        return memcmp(m_value.gpuVirtualizationModePtr,
                                      other.m_value.gpuVirtualizationModePtr,
                                      sizeof(*m_value.gpuVirtualizationModePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_GRIDLICENSABLEFEATURES_PTR:
                    {
                        return memcmp(m_value.gridLicensableFeaturesPtr,
                                      other.m_value.gridLicensableFeaturesPtr,
                                      sizeof(*m_value.gridLicensableFeaturesPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_HOSTVGPUMODE_PTR:
                    {
                        return memcmp(
                            m_value.hostVgpuModePtr, other.m_value.hostVgpuModePtr, sizeof(*m_value.hostVgpuModePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_HWBCENTRY_PTR:
                    {
                        return memcmp(m_value.hwbcEntryPtr, other.m_value.hwbcEntryPtr, sizeof(*m_value.hwbcEntryPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_INFOROMOBJECT:
                    {
                        if (m_value.inforomObject < other.m_value.inforomObject)
                        {
                            return -1;
                        }
                        else if (m_value.inforomObject > other.m_value.inforomObject)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_INTNVLINKDEVICETYPE_PTR:
                    {
                        return memcmp(m_value.intNvLinkDeviceTypePtr,
                                      other.m_value.intNvLinkDeviceTypePtr,
                                      sizeof(*m_value.intNvLinkDeviceTypePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_LEDCOLOR:
                    {
                        if (m_value.ledColor < other.m_value.ledColor)
                        {
                            return -1;
                        }
                        else if (m_value.ledColor > other.m_value.ledColor)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_LEDSTATE_PTR:
                    {
                        return memcmp(m_value.ledStatePtr, other.m_value.ledStatePtr, sizeof(*m_value.ledStatePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_MEMORYERRORTYPE:
                    {
                        if (m_value.memoryErrorType < other.m_value.memoryErrorType)
                        {
                            return -1;
                        }
                        else if (m_value.memoryErrorType > other.m_value.memoryErrorType)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_MEMORYLOCATION:
                    {
                        if (m_value.memoryLocation < other.m_value.memoryLocation)
                        {
                            return -1;
                        }
                        else if (m_value.memoryLocation > other.m_value.memoryLocation)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_MEMORY_PTR:
                    {
                        return memcmp(m_value.memoryPtr, other.m_value.memoryPtr, sizeof(*m_value.memoryPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_MEMORY_V2_PTR:
                    {
                        return memcmp(m_value.memory_v2Ptr, other.m_value.memory_v2Ptr, sizeof(*m_value.memory_v2Ptr));
                        break; // NOT REACHED
                    }
                    case INJECTION_NVLINKCAPABILITY:
                    {
                        if (m_value.nvLinkCapability < other.m_value.nvLinkCapability)
                        {
                            return -1;
                        }
                        else if (m_value.nvLinkCapability > other.m_value.nvLinkCapability)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_NVLINKERRORCOUNTER:
                    {
                        if (m_value.nvLinkErrorCounter < other.m_value.nvLinkErrorCounter)
                        {
                            return -1;
                        }
                        else if (m_value.nvLinkErrorCounter > other.m_value.nvLinkErrorCounter)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_NVLINKUTILIZATIONCONTROL_PTR:
                    {
                        return memcmp(m_value.nvLinkUtilizationControlPtr,
                                      other.m_value.nvLinkUtilizationControlPtr,
                                      sizeof(*m_value.nvLinkUtilizationControlPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_PSUINFO_PTR:
                    {
                        return memcmp(m_value.pSUInfoPtr, other.m_value.pSUInfoPtr, sizeof(*m_value.pSUInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_PAGERETIREMENTCAUSE:
                    {
                        if (m_value.pageRetirementCause < other.m_value.pageRetirementCause)
                        {
                            return -1;
                        }
                        else if (m_value.pageRetirementCause > other.m_value.pageRetirementCause)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_PCIINFO_PTR:
                    {
                        return memcmp(m_value.pciInfoPtr, other.m_value.pciInfoPtr, sizeof(*m_value.pciInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_PCIELINKSTATE:
                    {
                        if (m_value.pcieLinkState < other.m_value.pcieLinkState)
                        {
                            return -1;
                        }
                        else if (m_value.pcieLinkState > other.m_value.pcieLinkState)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_PCIEUTILCOUNTER:
                    {
                        if (m_value.pcieUtilCounter < other.m_value.pcieUtilCounter)
                        {
                            return -1;
                        }
                        else if (m_value.pcieUtilCounter > other.m_value.pcieUtilCounter)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_PERFPOLICYTYPE:
                    {
                        if (m_value.perfPolicyType < other.m_value.perfPolicyType)
                        {
                            return -1;
                        }
                        else if (m_value.perfPolicyType > other.m_value.perfPolicyType)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_PROCESSINFO_PTR:
                    {
                        return memcmp(
                            m_value.processInfoPtr, other.m_value.processInfoPtr, sizeof(*m_value.processInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_PROCESSINFO_V1_PTR:
                    {
                        return memcmp(m_value.processInfo_v1Ptr,
                                      other.m_value.processInfo_v1Ptr,
                                      sizeof(*m_value.processInfo_v1Ptr));
                        break; // NOT REACHED
                    }
                    case INJECTION_PROCESSINFO_V2_PTR:
                    {
                        return memcmp(m_value.processInfo_v2Ptr,
                                      other.m_value.processInfo_v2Ptr,
                                      sizeof(*m_value.processInfo_v2Ptr));
                        break; // NOT REACHED
                    }
                    case INJECTION_PROCESSUTILIZATIONSAMPLE_PTR:
                    {
                        return memcmp(m_value.processUtilizationSamplePtr,
                                      other.m_value.processUtilizationSamplePtr,
                                      sizeof(*m_value.processUtilizationSamplePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_PSTATES:
                    {
                        if (m_value.pstates < other.m_value.pstates)
                        {
                            return -1;
                        }
                        else if (m_value.pstates > other.m_value.pstates)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_PSTATES_PTR:
                    {
                        return memcmp(m_value.pstatesPtr, other.m_value.pstatesPtr, sizeof(*m_value.pstatesPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_RESTRICTEDAPI:
                    {
                        if (m_value.restrictedAPI < other.m_value.restrictedAPI)
                        {
                            return -1;
                        }
                        else if (m_value.restrictedAPI > other.m_value.restrictedAPI)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_RETURN_PTR:
                    {
                        return memcmp(m_value.returnPtr, other.m_value.returnPtr, sizeof(*m_value.returnPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR:
                    {
                        return memcmp(m_value.rowRemapperHistogramValuesPtr,
                                      other.m_value.rowRemapperHistogramValuesPtr,
                                      sizeof(*m_value.rowRemapperHistogramValuesPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_SAMPLE_PTR:
                    {
                        return memcmp(m_value.samplePtr, other.m_value.samplePtr, sizeof(*m_value.samplePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_SAMPLINGTYPE:
                    {
                        if (m_value.samplingType < other.m_value.samplingType)
                        {
                            return -1;
                        }
                        else if (m_value.samplingType > other.m_value.samplingType)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_TEMPERATURESENSORS:
                    {
                        if (m_value.temperatureSensors < other.m_value.temperatureSensors)
                        {
                            return -1;
                        }
                        else if (m_value.temperatureSensors > other.m_value.temperatureSensors)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_TEMPERATURETHRESHOLDS:
                    {
                        if (m_value.temperatureThresholds < other.m_value.temperatureThresholds)
                        {
                            return -1;
                        }
                        else if (m_value.temperatureThresholds > other.m_value.temperatureThresholds)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_UNITFANSPEEDS_PTR:
                    {
                        return memcmp(m_value.unitFanSpeedsPtr,
                                      other.m_value.unitFanSpeedsPtr,
                                      sizeof(*m_value.unitFanSpeedsPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_UNITINFO_PTR:
                    {
                        return memcmp(m_value.unitInfoPtr, other.m_value.unitInfoPtr, sizeof(*m_value.unitInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_UNIT:
                    {
                        if (m_value.unit < other.m_value.unit)
                        {
                            return -1;
                        }
                        else if (m_value.unit > other.m_value.unit)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_UNIT_PTR:
                    {
                        return memcmp(m_value.unitPtr, other.m_value.unitPtr, sizeof(*m_value.unitPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_UTILIZATION_PTR:
                    {
                        return memcmp(
                            m_value.utilizationPtr, other.m_value.utilizationPtr, sizeof(*m_value.utilizationPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VALUETYPE_PTR:
                    {
                        return memcmp(m_value.valueTypePtr, other.m_value.valueTypePtr, sizeof(*m_value.valueTypePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUCAPABILITY:
                    {
                        if (m_value.vgpuCapability < other.m_value.vgpuCapability)
                        {
                            return -1;
                        }
                        else if (m_value.vgpuCapability > other.m_value.vgpuCapability)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR:
                    {
                        return memcmp(m_value.vgpuInstanceUtilizationSamplePtr,
                                      other.m_value.vgpuInstanceUtilizationSamplePtr,
                                      sizeof(*m_value.vgpuInstanceUtilizationSamplePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPULICENSEINFO_PTR:
                    {
                        return memcmp(m_value.vgpuLicenseInfoPtr,
                                      other.m_value.vgpuLicenseInfoPtr,
                                      sizeof(*m_value.vgpuLicenseInfoPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUMETADATA_PTR:
                    {
                        return memcmp(
                            m_value.vgpuMetadataPtr, other.m_value.vgpuMetadataPtr, sizeof(*m_value.vgpuMetadataPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUPGPUCOMPATIBILITY_PTR:
                    {
                        return memcmp(m_value.vgpuPgpuCompatibilityPtr,
                                      other.m_value.vgpuPgpuCompatibilityPtr,
                                      sizeof(*m_value.vgpuPgpuCompatibilityPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUPGPUMETADATA_PTR:
                    {
                        return memcmp(m_value.vgpuPgpuMetadataPtr,
                                      other.m_value.vgpuPgpuMetadataPtr,
                                      sizeof(*m_value.vgpuPgpuMetadataPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR:
                    {
                        return memcmp(m_value.vgpuProcessUtilizationSamplePtr,
                                      other.m_value.vgpuProcessUtilizationSamplePtr,
                                      sizeof(*m_value.vgpuProcessUtilizationSamplePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUVERSION_PTR:
                    {
                        return memcmp(
                            m_value.vgpuVersionPtr, other.m_value.vgpuVersionPtr, sizeof(*m_value.vgpuVersionPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VGPUVMIDTYPE_PTR:
                    {
                        return memcmp(
                            m_value.vgpuVmIdTypePtr, other.m_value.vgpuVmIdTypePtr, sizeof(*m_value.vgpuVmIdTypePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_VIOLATIONTIME_PTR:
                    {
                        return memcmp(m_value.violationTimePtr,
                                      other.m_value.violationTimePtr,
                                      sizeof(*m_value.violationTimePtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_UINT:
                    {
                        if (m_value.ui < other.m_value.ui)
                        {
                            return -1;
                        }
                        else if (m_value.ui > other.m_value.ui)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_UINT_PTR:
                    {
                        return memcmp(m_value.uiPtr, other.m_value.uiPtr, sizeof(*m_value.uiPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ULONG_PTR:
                    {
                        return memcmp(m_value.ulPtr, other.m_value.ulPtr, sizeof(*m_value.ulPtr));
                        break; // NOT REACHED
                    }
                    case INJECTION_ULONG_LONG:
                    {
                        if (m_value.ull < other.m_value.ull)
                        {
                            return -1;
                        }
                        else if (m_value.ull > other.m_value.ull)
                        {
                            return 1;
                        }
                        else
                        {
                            return 0;
                        }
                        break; // NOT REACHED
                    }
                    case INJECTION_ULONG_LONG_PTR:
                    {
                        return memcmp(m_value.ullPtr, other.m_value.ullPtr, sizeof(*m_value.ullPtr));
                        break; // NOT REACHED
                    }
                    default:
                        break;
                }
            }
        }
        return true;
    }
    bool operator<(const InjectionArgument &other) const
    {
        return this->Compare(other) == -1;
    }

    bool operator==(const InjectionArgument &other) const
    {
        return this->Compare(other) == 0;
    }

    bool IsEmpty() const
    {
        return m_type == InjectionArgCount;
    }

    InjectionArgument(char *str)
        : m_type(INJECTION_CHAR_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.str = str;
    }
    char *AsStr() const
    {
        return m_value.str;
    }

    InjectionArgument(const char *const_str)
        : m_type(INJECTION_CONST_CHAR_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.const_str = const_str;
    }
    const char *AsConstStr() const
    {
        return m_value.const_str;
    }

    InjectionArgument(const nvmlGpuInstancePlacement_t *cnPtr)
        : m_type(INJECTION_CONST_NVMLGPUINSTANCEPLACEMENT_T_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.cnPtr = cnPtr;
    }
    const nvmlGpuInstancePlacement_t *AsConstNvmlGpuInstancePlacement_tPtr() const
    {
        return m_value.cnPtr;
    }

    InjectionArgument(int i)
        : m_type(INJECTION_INT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.i = i;
    }
    int AsInt() const
    {
        return m_value.i;
    }

    InjectionArgument(int *iPtr)
        : m_type(INJECTION_INT_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.iPtr = iPtr;
    }
    int *AsIntPtr() const
    {
        return m_value.iPtr;
    }

    InjectionArgument(nvmlAccountingStats_t *accountingStatsPtr)
        : m_type(INJECTION_ACCOUNTINGSTATS_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.accountingStatsPtr = accountingStatsPtr;
    }
    nvmlAccountingStats_t *AsAccountingStatsPtr() const
    {
        return m_value.accountingStatsPtr;
    }

    InjectionArgument(nvmlBAR1Memory_t *bar1MemoryPtr)
        : m_type(INJECTION_BAR1MEMORY_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bar1MemoryPtr = bar1MemoryPtr;
    }
    nvmlBAR1Memory_t *AsBAR1MemoryPtr() const
    {
        return m_value.bar1MemoryPtr;
    }

    InjectionArgument(nvmlBrandType_t *brandTypePtr)
        : m_type(INJECTION_BRANDTYPE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.brandTypePtr = brandTypePtr;
    }
    nvmlBrandType_t *AsBrandTypePtr() const
    {
        return m_value.brandTypePtr;
    }

    InjectionArgument(nvmlBridgeChipHierarchy_t *bridgeChipHierarchyPtr)
        : m_type(INJECTION_BRIDGECHIPHIERARCHY_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.bridgeChipHierarchyPtr = bridgeChipHierarchyPtr;
    }
    nvmlBridgeChipHierarchy_t *AsBridgeChipHierarchyPtr() const
    {
        return m_value.bridgeChipHierarchyPtr;
    }

    InjectionArgument(nvmlClockId_t clockId)
        : m_type(INJECTION_CLOCKID)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.clockId = clockId;
    }
    nvmlClockId_t AsClockId() const
    {
        return m_value.clockId;
    }

    InjectionArgument(nvmlClockType_t clockType)
        : m_type(INJECTION_CLOCKTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.clockType = clockType;
    }
    nvmlClockType_t AsClockType() const
    {
        return m_value.clockType;
    }

    InjectionArgument(nvmlComputeInstanceInfo_t *computeInstanceInfoPtr)
        : m_type(INJECTION_COMPUTEINSTANCEINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceInfoPtr = computeInstanceInfoPtr;
    }
    nvmlComputeInstanceInfo_t *AsComputeInstanceInfoPtr() const
    {
        return m_value.computeInstanceInfoPtr;
    }

    InjectionArgument(nvmlComputeInstanceProfileInfo_t *computeInstanceProfileInfoPtr)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfoPtr = computeInstanceProfileInfoPtr;
    }
    nvmlComputeInstanceProfileInfo_t *AsComputeInstanceProfileInfoPtr() const
    {
        return m_value.computeInstanceProfileInfoPtr;
    }

    InjectionArgument(nvmlComputeInstanceProfileInfo_v2_t *computeInstanceProfileInfo_v2Ptr)
        : m_type(INJECTION_COMPUTEINSTANCEPROFILEINFO_V2_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstanceProfileInfo_v2Ptr = computeInstanceProfileInfo_v2Ptr;
    }
    nvmlComputeInstanceProfileInfo_v2_t *AsComputeInstanceProfileInfo_v2Ptr() const
    {
        return m_value.computeInstanceProfileInfo_v2Ptr;
    }

    InjectionArgument(nvmlComputeInstance_t computeInstance)
        : m_type(INJECTION_COMPUTEINSTANCE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstance = computeInstance;
    }
    nvmlComputeInstance_t AsComputeInstance() const
    {
        return m_value.computeInstance;
    }

    InjectionArgument(nvmlComputeInstance_t *computeInstancePtr)
        : m_type(INJECTION_COMPUTEINSTANCE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeInstancePtr = computeInstancePtr;
    }
    nvmlComputeInstance_t *AsComputeInstancePtr() const
    {
        return m_value.computeInstancePtr;
    }

    InjectionArgument(nvmlComputeMode_t computeMode)
        : m_type(INJECTION_COMPUTEMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeMode = computeMode;
    }
    nvmlComputeMode_t AsComputeMode() const
    {
        return m_value.computeMode;
    }

    InjectionArgument(nvmlComputeMode_t *computeModePtr)
        : m_type(INJECTION_COMPUTEMODE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.computeModePtr = computeModePtr;
    }
    nvmlComputeMode_t *AsComputeModePtr() const
    {
        return m_value.computeModePtr;
    }

    InjectionArgument(nvmlConfComputeSystemState_t *confComputeSystemStatePtr)
        : m_type(INJECTION_CONFCOMPUTESYSTEMSTATE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.confComputeSystemStatePtr = confComputeSystemStatePtr;
    }
    nvmlConfComputeSystemState_t *AsConfComputeSystemStatePtr() const
    {
        return m_value.confComputeSystemStatePtr;
    }

    InjectionArgument(nvmlDetachGpuState_t detachGpuState)
        : m_type(INJECTION_DETACHGPUSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.detachGpuState = detachGpuState;
    }
    nvmlDetachGpuState_t AsDetachGpuState() const
    {
        return m_value.detachGpuState;
    }

    InjectionArgument(nvmlDeviceAttributes_t *deviceAttributesPtr)
        : m_type(INJECTION_DEVICEATTRIBUTES_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.deviceAttributesPtr = deviceAttributesPtr;
    }
    nvmlDeviceAttributes_t *AsDeviceAttributesPtr() const
    {
        return m_value.deviceAttributesPtr;
    }

    InjectionArgument(nvmlDevice_t device)
        : m_type(INJECTION_DEVICE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.device = device;
    }
    nvmlDevice_t AsDevice() const
    {
        return m_value.device;
    }

    InjectionArgument(nvmlDevice_t *devicePtr)
        : m_type(INJECTION_DEVICE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.devicePtr = devicePtr;
    }
    nvmlDevice_t *AsDevicePtr() const
    {
        return m_value.devicePtr;
    }

    InjectionArgument(nvmlDriverModel_t driverModel)
        : m_type(INJECTION_DRIVERMODEL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.driverModel = driverModel;
    }
    nvmlDriverModel_t AsDriverModel() const
    {
        return m_value.driverModel;
    }

    InjectionArgument(nvmlDriverModel_t *driverModelPtr)
        : m_type(INJECTION_DRIVERMODEL_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.driverModelPtr = driverModelPtr;
    }
    nvmlDriverModel_t *AsDriverModelPtr() const
    {
        return m_value.driverModelPtr;
    }

    InjectionArgument(nvmlEccCounterType_t eccCounterType)
        : m_type(INJECTION_ECCCOUNTERTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eccCounterType = eccCounterType;
    }
    nvmlEccCounterType_t AsEccCounterType() const
    {
        return m_value.eccCounterType;
    }

    InjectionArgument(nvmlEccErrorCounts_t *eccErrorCountsPtr)
        : m_type(INJECTION_ECCERRORCOUNTS_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eccErrorCountsPtr = eccErrorCountsPtr;
    }
    nvmlEccErrorCounts_t *AsEccErrorCountsPtr() const
    {
        return m_value.eccErrorCountsPtr;
    }

    InjectionArgument(nvmlEnableState_t enableState)
        : m_type(INJECTION_ENABLESTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.enableState = enableState;
    }
    nvmlEnableState_t AsEnableState() const
    {
        return m_value.enableState;
    }

    InjectionArgument(nvmlEnableState_t *enableStatePtr)
        : m_type(INJECTION_ENABLESTATE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.enableStatePtr = enableStatePtr;
    }
    nvmlEnableState_t *AsEnableStatePtr() const
    {
        return m_value.enableStatePtr;
    }

    InjectionArgument(nvmlEncoderSessionInfo_t *encoderSessionInfoPtr)
        : m_type(INJECTION_ENCODERSESSIONINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.encoderSessionInfoPtr = encoderSessionInfoPtr;
    }
    nvmlEncoderSessionInfo_t *AsEncoderSessionInfoPtr() const
    {
        return m_value.encoderSessionInfoPtr;
    }

    InjectionArgument(nvmlEncoderType_t encoderType)
        : m_type(INJECTION_ENCODERTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.encoderType = encoderType;
    }
    nvmlEncoderType_t AsEncoderType() const
    {
        return m_value.encoderType;
    }

    InjectionArgument(nvmlEventData_t *eventDataPtr)
        : m_type(INJECTION_EVENTDATA_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventDataPtr = eventDataPtr;
    }
    nvmlEventData_t *AsEventDataPtr() const
    {
        return m_value.eventDataPtr;
    }

    InjectionArgument(nvmlEventSet_t eventSet)
        : m_type(INJECTION_EVENTSET)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventSet = eventSet;
    }
    nvmlEventSet_t AsEventSet() const
    {
        return m_value.eventSet;
    }

    InjectionArgument(nvmlEventSet_t *eventSetPtr)
        : m_type(INJECTION_EVENTSET_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.eventSetPtr = eventSetPtr;
    }
    nvmlEventSet_t *AsEventSetPtr() const
    {
        return m_value.eventSetPtr;
    }

    InjectionArgument(nvmlExcludedDeviceInfo_t *excludedDeviceInfoPtr)
        : m_type(INJECTION_EXCLUDEDDEVICEINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.excludedDeviceInfoPtr = excludedDeviceInfoPtr;
    }
    nvmlExcludedDeviceInfo_t *AsExcludedDeviceInfoPtr() const
    {
        return m_value.excludedDeviceInfoPtr;
    }

    InjectionArgument(nvmlFBCSessionInfo_t *fBCSessionInfoPtr)
        : m_type(INJECTION_FBCSESSIONINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCSessionInfoPtr = fBCSessionInfoPtr;
    }
    nvmlFBCSessionInfo_t *AsFBCSessionInfoPtr() const
    {
        return m_value.fBCSessionInfoPtr;
    }

    InjectionArgument(nvmlFBCStats_t *fBCStatsPtr)
        : m_type(INJECTION_FBCSTATS_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fBCStatsPtr = fBCStatsPtr;
    }
    nvmlFBCStats_t *AsFBCStatsPtr() const
    {
        return m_value.fBCStatsPtr;
    }

    InjectionArgument(nvmlFieldValue_t *fieldValuePtr)
        : m_type(INJECTION_FIELDVALUE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.fieldValuePtr = fieldValuePtr;
    }
    nvmlFieldValue_t *AsFieldValuePtr() const
    {
        return m_value.fieldValuePtr;
    }

    InjectionArgument(nvmlGpmMetricsGet_t *gpmMetricsGetPtr)
        : m_type(INJECTION_GPMMETRICSGET_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmMetricsGetPtr = gpmMetricsGetPtr;
    }
    nvmlGpmMetricsGet_t *AsGpmMetricsGetPtr() const
    {
        return m_value.gpmMetricsGetPtr;
    }

    InjectionArgument(nvmlGpmSample_t gpmSample)
        : m_type(INJECTION_GPMSAMPLE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSample = gpmSample;
    }
    nvmlGpmSample_t AsGpmSample() const
    {
        return m_value.gpmSample;
    }

    InjectionArgument(nvmlGpmSample_t *gpmSamplePtr)
        : m_type(INJECTION_GPMSAMPLE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSamplePtr = gpmSamplePtr;
    }
    nvmlGpmSample_t *AsGpmSamplePtr() const
    {
        return m_value.gpmSamplePtr;
    }

    InjectionArgument(nvmlGpmSupport_t *gpmSupportPtr)
        : m_type(INJECTION_GPMSUPPORT_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpmSupportPtr = gpmSupportPtr;
    }
    nvmlGpmSupport_t *AsGpmSupportPtr() const
    {
        return m_value.gpmSupportPtr;
    }

    InjectionArgument(nvmlGpuDynamicPstatesInfo_t *gpuDynamicPstatesInfoPtr)
        : m_type(INJECTION_GPUDYNAMICPSTATESINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuDynamicPstatesInfoPtr = gpuDynamicPstatesInfoPtr;
    }
    nvmlGpuDynamicPstatesInfo_t *AsGpuDynamicPstatesInfoPtr() const
    {
        return m_value.gpuDynamicPstatesInfoPtr;
    }

    InjectionArgument(nvmlGpuInstanceInfo_t *gpuInstanceInfoPtr)
        : m_type(INJECTION_GPUINSTANCEINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceInfoPtr = gpuInstanceInfoPtr;
    }
    nvmlGpuInstanceInfo_t *AsGpuInstanceInfoPtr() const
    {
        return m_value.gpuInstanceInfoPtr;
    }

    InjectionArgument(nvmlGpuInstancePlacement_t *gpuInstancePlacementPtr)
        : m_type(INJECTION_GPUINSTANCEPLACEMENT_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstancePlacementPtr = gpuInstancePlacementPtr;
    }
    nvmlGpuInstancePlacement_t *AsGpuInstancePlacementPtr() const
    {
        return m_value.gpuInstancePlacementPtr;
    }

    InjectionArgument(nvmlGpuInstanceProfileInfo_t *gpuInstanceProfileInfoPtr)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfoPtr = gpuInstanceProfileInfoPtr;
    }
    nvmlGpuInstanceProfileInfo_t *AsGpuInstanceProfileInfoPtr() const
    {
        return m_value.gpuInstanceProfileInfoPtr;
    }

    InjectionArgument(nvmlGpuInstanceProfileInfo_v2_t *gpuInstanceProfileInfo_v2Ptr)
        : m_type(INJECTION_GPUINSTANCEPROFILEINFO_V2_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstanceProfileInfo_v2Ptr = gpuInstanceProfileInfo_v2Ptr;
    }
    nvmlGpuInstanceProfileInfo_v2_t *AsGpuInstanceProfileInfo_v2Ptr() const
    {
        return m_value.gpuInstanceProfileInfo_v2Ptr;
    }

    InjectionArgument(nvmlGpuInstance_t gpuInstance)
        : m_type(INJECTION_GPUINSTANCE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstance = gpuInstance;
    }
    nvmlGpuInstance_t AsGpuInstance() const
    {
        return m_value.gpuInstance;
    }

    InjectionArgument(nvmlGpuInstance_t *gpuInstancePtr)
        : m_type(INJECTION_GPUINSTANCE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuInstancePtr = gpuInstancePtr;
    }
    nvmlGpuInstance_t *AsGpuInstancePtr() const
    {
        return m_value.gpuInstancePtr;
    }

    InjectionArgument(nvmlGpuOperationMode_t gpuOperationMode)
        : m_type(INJECTION_GPUOPERATIONMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuOperationMode = gpuOperationMode;
    }
    nvmlGpuOperationMode_t AsGpuOperationMode() const
    {
        return m_value.gpuOperationMode;
    }

    InjectionArgument(nvmlGpuOperationMode_t *gpuOperationModePtr)
        : m_type(INJECTION_GPUOPERATIONMODE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuOperationModePtr = gpuOperationModePtr;
    }
    nvmlGpuOperationMode_t *AsGpuOperationModePtr() const
    {
        return m_value.gpuOperationModePtr;
    }

    InjectionArgument(nvmlGpuP2PCapsIndex_t gpuP2PCapsIndex)
        : m_type(INJECTION_GPUP2PCAPSINDEX)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuP2PCapsIndex = gpuP2PCapsIndex;
    }
    nvmlGpuP2PCapsIndex_t AsGpuP2PCapsIndex() const
    {
        return m_value.gpuP2PCapsIndex;
    }

    InjectionArgument(nvmlGpuP2PStatus_t *gpuP2PStatusPtr)
        : m_type(INJECTION_GPUP2PSTATUS_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuP2PStatusPtr = gpuP2PStatusPtr;
    }
    nvmlGpuP2PStatus_t *AsGpuP2PStatusPtr() const
    {
        return m_value.gpuP2PStatusPtr;
    }

    InjectionArgument(nvmlGpuThermalSettings_t *gpuThermalSettingsPtr)
        : m_type(INJECTION_GPUTHERMALSETTINGS_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuThermalSettingsPtr = gpuThermalSettingsPtr;
    }
    nvmlGpuThermalSettings_t *AsGpuThermalSettingsPtr() const
    {
        return m_value.gpuThermalSettingsPtr;
    }

    InjectionArgument(nvmlGpuTopologyLevel_t gpuTopologyLevel)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuTopologyLevel = gpuTopologyLevel;
    }
    nvmlGpuTopologyLevel_t AsGpuTopologyLevel() const
    {
        return m_value.gpuTopologyLevel;
    }

    InjectionArgument(nvmlGpuTopologyLevel_t *gpuTopologyLevelPtr)
        : m_type(INJECTION_GPUTOPOLOGYLEVEL_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuTopologyLevelPtr = gpuTopologyLevelPtr;
    }
    nvmlGpuTopologyLevel_t *AsGpuTopologyLevelPtr() const
    {
        return m_value.gpuTopologyLevelPtr;
    }

    InjectionArgument(nvmlGpuVirtualizationMode_t gpuVirtualizationMode)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuVirtualizationMode = gpuVirtualizationMode;
    }
    nvmlGpuVirtualizationMode_t AsGpuVirtualizationMode() const
    {
        return m_value.gpuVirtualizationMode;
    }

    InjectionArgument(nvmlGpuVirtualizationMode_t *gpuVirtualizationModePtr)
        : m_type(INJECTION_GPUVIRTUALIZATIONMODE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gpuVirtualizationModePtr = gpuVirtualizationModePtr;
    }
    nvmlGpuVirtualizationMode_t *AsGpuVirtualizationModePtr() const
    {
        return m_value.gpuVirtualizationModePtr;
    }

    InjectionArgument(nvmlGridLicensableFeatures_t *gridLicensableFeaturesPtr)
        : m_type(INJECTION_GRIDLICENSABLEFEATURES_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.gridLicensableFeaturesPtr = gridLicensableFeaturesPtr;
    }
    nvmlGridLicensableFeatures_t *AsGridLicensableFeaturesPtr() const
    {
        return m_value.gridLicensableFeaturesPtr;
    }

    InjectionArgument(nvmlHostVgpuMode_t *hostVgpuModePtr)
        : m_type(INJECTION_HOSTVGPUMODE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hostVgpuModePtr = hostVgpuModePtr;
    }
    nvmlHostVgpuMode_t *AsHostVgpuModePtr() const
    {
        return m_value.hostVgpuModePtr;
    }

    InjectionArgument(nvmlHwbcEntry_t *hwbcEntryPtr)
        : m_type(INJECTION_HWBCENTRY_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.hwbcEntryPtr = hwbcEntryPtr;
    }
    nvmlHwbcEntry_t *AsHwbcEntryPtr() const
    {
        return m_value.hwbcEntryPtr;
    }

    InjectionArgument(nvmlInforomObject_t inforomObject)
        : m_type(INJECTION_INFOROMOBJECT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.inforomObject = inforomObject;
    }
    nvmlInforomObject_t AsInforomObject() const
    {
        return m_value.inforomObject;
    }

    InjectionArgument(nvmlIntNvLinkDeviceType_t *intNvLinkDeviceTypePtr)
        : m_type(INJECTION_INTNVLINKDEVICETYPE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.intNvLinkDeviceTypePtr = intNvLinkDeviceTypePtr;
    }
    nvmlIntNvLinkDeviceType_t *AsIntNvLinkDeviceTypePtr() const
    {
        return m_value.intNvLinkDeviceTypePtr;
    }

    InjectionArgument(nvmlLedColor_t ledColor)
        : m_type(INJECTION_LEDCOLOR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ledColor = ledColor;
    }
    nvmlLedColor_t AsLedColor() const
    {
        return m_value.ledColor;
    }

    InjectionArgument(nvmlLedState_t *ledStatePtr)
        : m_type(INJECTION_LEDSTATE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ledStatePtr = ledStatePtr;
    }
    nvmlLedState_t *AsLedStatePtr() const
    {
        return m_value.ledStatePtr;
    }

    InjectionArgument(nvmlMemoryErrorType_t memoryErrorType)
        : m_type(INJECTION_MEMORYERRORTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memoryErrorType = memoryErrorType;
    }
    nvmlMemoryErrorType_t AsMemoryErrorType() const
    {
        return m_value.memoryErrorType;
    }

    InjectionArgument(nvmlMemoryLocation_t memoryLocation)
        : m_type(INJECTION_MEMORYLOCATION)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memoryLocation = memoryLocation;
    }
    nvmlMemoryLocation_t AsMemoryLocation() const
    {
        return m_value.memoryLocation;
    }

    InjectionArgument(nvmlMemory_t *memoryPtr)
        : m_type(INJECTION_MEMORY_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memoryPtr = memoryPtr;
    }
    nvmlMemory_t *AsMemoryPtr() const
    {
        return m_value.memoryPtr;
    }

    InjectionArgument(nvmlMemory_v2_t *memory_v2Ptr)
        : m_type(INJECTION_MEMORY_V2_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.memory_v2Ptr = memory_v2Ptr;
    }
    nvmlMemory_v2_t *AsMemory_v2Ptr() const
    {
        return m_value.memory_v2Ptr;
    }

    InjectionArgument(nvmlNvLinkCapability_t nvLinkCapability)
        : m_type(INJECTION_NVLINKCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkCapability = nvLinkCapability;
    }
    nvmlNvLinkCapability_t AsNvLinkCapability() const
    {
        return m_value.nvLinkCapability;
    }

    InjectionArgument(nvmlNvLinkErrorCounter_t nvLinkErrorCounter)
        : m_type(INJECTION_NVLINKERRORCOUNTER)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkErrorCounter = nvLinkErrorCounter;
    }
    nvmlNvLinkErrorCounter_t AsNvLinkErrorCounter() const
    {
        return m_value.nvLinkErrorCounter;
    }

    InjectionArgument(nvmlNvLinkUtilizationControl_t *nvLinkUtilizationControlPtr)
        : m_type(INJECTION_NVLINKUTILIZATIONCONTROL_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.nvLinkUtilizationControlPtr = nvLinkUtilizationControlPtr;
    }
    nvmlNvLinkUtilizationControl_t *AsNvLinkUtilizationControlPtr() const
    {
        return m_value.nvLinkUtilizationControlPtr;
    }

    InjectionArgument(nvmlPSUInfo_t *pSUInfoPtr)
        : m_type(INJECTION_PSUINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pSUInfoPtr = pSUInfoPtr;
    }
    nvmlPSUInfo_t *AsPSUInfoPtr() const
    {
        return m_value.pSUInfoPtr;
    }

    InjectionArgument(nvmlPageRetirementCause_t pageRetirementCause)
        : m_type(INJECTION_PAGERETIREMENTCAUSE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pageRetirementCause = pageRetirementCause;
    }
    nvmlPageRetirementCause_t AsPageRetirementCause() const
    {
        return m_value.pageRetirementCause;
    }

    InjectionArgument(nvmlPciInfo_t *pciInfoPtr)
        : m_type(INJECTION_PCIINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pciInfoPtr = pciInfoPtr;
    }
    nvmlPciInfo_t *AsPciInfoPtr() const
    {
        return m_value.pciInfoPtr;
    }

    InjectionArgument(nvmlPcieLinkState_t pcieLinkState)
        : m_type(INJECTION_PCIELINKSTATE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pcieLinkState = pcieLinkState;
    }
    nvmlPcieLinkState_t AsPcieLinkState() const
    {
        return m_value.pcieLinkState;
    }

    InjectionArgument(nvmlPcieUtilCounter_t pcieUtilCounter)
        : m_type(INJECTION_PCIEUTILCOUNTER)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pcieUtilCounter = pcieUtilCounter;
    }
    nvmlPcieUtilCounter_t AsPcieUtilCounter() const
    {
        return m_value.pcieUtilCounter;
    }

    InjectionArgument(nvmlPerfPolicyType_t perfPolicyType)
        : m_type(INJECTION_PERFPOLICYTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.perfPolicyType = perfPolicyType;
    }
    nvmlPerfPolicyType_t AsPerfPolicyType() const
    {
        return m_value.perfPolicyType;
    }

    InjectionArgument(nvmlProcessInfo_t *processInfoPtr)
        : m_type(INJECTION_PROCESSINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfoPtr = processInfoPtr;
    }
    nvmlProcessInfo_t *AsProcessInfoPtr() const
    {
        return m_value.processInfoPtr;
    }

    InjectionArgument(nvmlProcessInfo_v1_t *processInfo_v1Ptr)
        : m_type(INJECTION_PROCESSINFO_V1_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v1Ptr = processInfo_v1Ptr;
    }
    nvmlProcessInfo_v1_t *AsProcessInfo_v1Ptr() const
    {
        return m_value.processInfo_v1Ptr;
    }

  /*
nvml-injection/include/InjectionArgument.h:2042:5: error: ‘InjectionArgument::InjectionArgument(nvmlProcessInfo_v2_t*)’ cannot be overloaded with ‘InjectionArgument::InjectionArgument(nvmlProcessInfo_t*)’
 2042 |     InjectionArgument(nvmlProcessInfo_v2_t *processInfo_v2Ptr)
      |     ^~~~~~~~~~~~~~~~~

    InjectionArgument(nvmlProcessInfo_v2_t *processInfo_v2Ptr)
        : m_type(INJECTION_PROCESSINFO_V2_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processInfo_v2Ptr = processInfo_v2Ptr;
    }
  */
    nvmlProcessInfo_v2_t *AsProcessInfo_v2Ptr() const
    {
        return m_value.processInfo_v2Ptr;
    }

    InjectionArgument(nvmlProcessUtilizationSample_t *processUtilizationSamplePtr)
        : m_type(INJECTION_PROCESSUTILIZATIONSAMPLE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.processUtilizationSamplePtr = processUtilizationSamplePtr;
    }
    nvmlProcessUtilizationSample_t *AsProcessUtilizationSamplePtr() const
    {
        return m_value.processUtilizationSamplePtr;
    }

    InjectionArgument(nvmlPstates_t pstates)
        : m_type(INJECTION_PSTATES)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pstates = pstates;
    }
    nvmlPstates_t AsPstates() const
    {
        return m_value.pstates;
    }

    InjectionArgument(nvmlPstates_t *pstatesPtr)
        : m_type(INJECTION_PSTATES_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.pstatesPtr = pstatesPtr;
    }
    nvmlPstates_t *AsPstatesPtr() const
    {
        return m_value.pstatesPtr;
    }

    InjectionArgument(nvmlRestrictedAPI_t restrictedAPI)
        : m_type(INJECTION_RESTRICTEDAPI)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.restrictedAPI = restrictedAPI;
    }
    nvmlRestrictedAPI_t AsRestrictedAPI() const
    {
        return m_value.restrictedAPI;
    }

    InjectionArgument(nvmlReturn_t *returnPtr)
        : m_type(INJECTION_RETURN_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.returnPtr = returnPtr;
    }
    nvmlReturn_t *AsReturnPtr() const
    {
        return m_value.returnPtr;
    }

    InjectionArgument(nvmlRowRemapperHistogramValues_t *rowRemapperHistogramValuesPtr)
        : m_type(INJECTION_ROWREMAPPERHISTOGRAMVALUES_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.rowRemapperHistogramValuesPtr = rowRemapperHistogramValuesPtr;
    }
    nvmlRowRemapperHistogramValues_t *AsRowRemapperHistogramValuesPtr() const
    {
        return m_value.rowRemapperHistogramValuesPtr;
    }

    InjectionArgument(nvmlSample_t *samplePtr)
        : m_type(INJECTION_SAMPLE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.samplePtr = samplePtr;
    }
    nvmlSample_t *AsSamplePtr() const
    {
        return m_value.samplePtr;
    }

    InjectionArgument(nvmlSamplingType_t samplingType)
        : m_type(INJECTION_SAMPLINGTYPE)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.samplingType = samplingType;
    }
    nvmlSamplingType_t AsSamplingType() const
    {
        return m_value.samplingType;
    }

    InjectionArgument(nvmlTemperatureSensors_t temperatureSensors)
        : m_type(INJECTION_TEMPERATURESENSORS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.temperatureSensors = temperatureSensors;
    }
    nvmlTemperatureSensors_t AsTemperatureSensors() const
    {
        return m_value.temperatureSensors;
    }

    InjectionArgument(nvmlTemperatureThresholds_t temperatureThresholds)
        : m_type(INJECTION_TEMPERATURETHRESHOLDS)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.temperatureThresholds = temperatureThresholds;
    }
    nvmlTemperatureThresholds_t AsTemperatureThresholds() const
    {
        return m_value.temperatureThresholds;
    }

    InjectionArgument(nvmlUnitFanSpeeds_t *unitFanSpeedsPtr)
        : m_type(INJECTION_UNITFANSPEEDS_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitFanSpeedsPtr = unitFanSpeedsPtr;
    }
    nvmlUnitFanSpeeds_t *AsUnitFanSpeedsPtr() const
    {
        return m_value.unitFanSpeedsPtr;
    }

    InjectionArgument(nvmlUnitInfo_t *unitInfoPtr)
        : m_type(INJECTION_UNITINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitInfoPtr = unitInfoPtr;
    }
    nvmlUnitInfo_t *AsUnitInfoPtr() const
    {
        return m_value.unitInfoPtr;
    }

    InjectionArgument(nvmlUnit_t unit)
        : m_type(INJECTION_UNIT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unit = unit;
    }
    nvmlUnit_t AsUnit() const
    {
        return m_value.unit;
    }

    InjectionArgument(nvmlUnit_t *unitPtr)
        : m_type(INJECTION_UNIT_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.unitPtr = unitPtr;
    }
    nvmlUnit_t *AsUnitPtr() const
    {
        return m_value.unitPtr;
    }

    InjectionArgument(nvmlUtilization_t *utilizationPtr)
        : m_type(INJECTION_UTILIZATION_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.utilizationPtr = utilizationPtr;
    }
    nvmlUtilization_t *AsUtilizationPtr() const
    {
        return m_value.utilizationPtr;
    }

    InjectionArgument(nvmlValueType_t *valueTypePtr)
        : m_type(INJECTION_VALUETYPE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.valueTypePtr = valueTypePtr;
    }
    nvmlValueType_t *AsValueTypePtr() const
    {
        return m_value.valueTypePtr;
    }

    InjectionArgument(nvmlVgpuCapability_t vgpuCapability)
        : m_type(INJECTION_VGPUCAPABILITY)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuCapability = vgpuCapability;
    }
    nvmlVgpuCapability_t AsVgpuCapability() const
    {
        return m_value.vgpuCapability;
    }

    InjectionArgument(nvmlVgpuInstanceUtilizationSample_t *vgpuInstanceUtilizationSamplePtr)
        : m_type(INJECTION_VGPUINSTANCEUTILIZATIONSAMPLE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuInstanceUtilizationSamplePtr = vgpuInstanceUtilizationSamplePtr;
    }
    nvmlVgpuInstanceUtilizationSample_t *AsVgpuInstanceUtilizationSamplePtr() const
    {
        return m_value.vgpuInstanceUtilizationSamplePtr;
    }

    InjectionArgument(nvmlVgpuLicenseInfo_t *vgpuLicenseInfoPtr)
        : m_type(INJECTION_VGPULICENSEINFO_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuLicenseInfoPtr = vgpuLicenseInfoPtr;
    }
    nvmlVgpuLicenseInfo_t *AsVgpuLicenseInfoPtr() const
    {
        return m_value.vgpuLicenseInfoPtr;
    }

    InjectionArgument(nvmlVgpuMetadata_t *vgpuMetadataPtr)
        : m_type(INJECTION_VGPUMETADATA_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuMetadataPtr = vgpuMetadataPtr;
    }
    nvmlVgpuMetadata_t *AsVgpuMetadataPtr() const
    {
        return m_value.vgpuMetadataPtr;
    }

    InjectionArgument(nvmlVgpuPgpuCompatibility_t *vgpuPgpuCompatibilityPtr)
        : m_type(INJECTION_VGPUPGPUCOMPATIBILITY_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuCompatibilityPtr = vgpuPgpuCompatibilityPtr;
    }
    nvmlVgpuPgpuCompatibility_t *AsVgpuPgpuCompatibilityPtr() const
    {
        return m_value.vgpuPgpuCompatibilityPtr;
    }

    InjectionArgument(nvmlVgpuPgpuMetadata_t *vgpuPgpuMetadataPtr)
        : m_type(INJECTION_VGPUPGPUMETADATA_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuPgpuMetadataPtr = vgpuPgpuMetadataPtr;
    }
    nvmlVgpuPgpuMetadata_t *AsVgpuPgpuMetadataPtr() const
    {
        return m_value.vgpuPgpuMetadataPtr;
    }

    InjectionArgument(nvmlVgpuProcessUtilizationSample_t *vgpuProcessUtilizationSamplePtr)
        : m_type(INJECTION_VGPUPROCESSUTILIZATIONSAMPLE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuProcessUtilizationSamplePtr = vgpuProcessUtilizationSamplePtr;
    }
    nvmlVgpuProcessUtilizationSample_t *AsVgpuProcessUtilizationSamplePtr() const
    {
        return m_value.vgpuProcessUtilizationSamplePtr;
    }

    InjectionArgument(nvmlVgpuVersion_t *vgpuVersionPtr)
        : m_type(INJECTION_VGPUVERSION_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVersionPtr = vgpuVersionPtr;
    }
    nvmlVgpuVersion_t *AsVgpuVersionPtr() const
    {
        return m_value.vgpuVersionPtr;
    }

    InjectionArgument(nvmlVgpuVmIdType_t *vgpuVmIdTypePtr)
        : m_type(INJECTION_VGPUVMIDTYPE_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.vgpuVmIdTypePtr = vgpuVmIdTypePtr;
    }
    nvmlVgpuVmIdType_t *AsVgpuVmIdTypePtr() const
    {
        return m_value.vgpuVmIdTypePtr;
    }

    InjectionArgument(nvmlViolationTime_t *violationTimePtr)
        : m_type(INJECTION_VIOLATIONTIME_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.violationTimePtr = violationTimePtr;
    }
    nvmlViolationTime_t *AsViolationTimePtr() const
    {
        return m_value.violationTimePtr;
    }

    InjectionArgument(unsigned int ui)
        : m_type(INJECTION_UINT)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ui = ui;
    }
    unsigned int AsUInt() const
    {
        return m_value.ui;
    }

    InjectionArgument(unsigned int *uiPtr)
        : m_type(INJECTION_UINT_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.uiPtr = uiPtr;
    }
    unsigned int *AsUIntPtr() const
    {
        return m_value.uiPtr;
    }

    InjectionArgument(unsigned long *ulPtr)
        : m_type(INJECTION_ULONG_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ulPtr = ulPtr;
    }
    unsigned long *AsULongPtr() const
    {
        return m_value.ulPtr;
    }

    InjectionArgument(unsigned long long ull)
        : m_type(INJECTION_ULONG_LONG)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ull = ull;
    }
    unsigned long long AsULongLong() const
    {
        return m_value.ull;
    }

    InjectionArgument(unsigned long long *ullPtr)
        : m_type(INJECTION_ULONG_LONG_PTR)
    {
        memset(&m_value, 0, sizeof(m_value));
        m_value.ullPtr = ullPtr;
    }
    unsigned long long *AsULongLongPtr() const
    {
        return m_value.ullPtr;
    }

    InjectionArgument(const std::string &val)
        : m_type(INJECTION_STRING)
        , m_str(val)
    {
        memset(&m_value, 0, sizeof(m_value));
    }
    std::string AsString() const
    {
        switch (m_type)
        {
            case INJECTION_STRING:
            {
                return m_str;
            }
            break;
            case INJECTION_CHAR_PTR:
            {
                if (m_value.str != nullptr)
                {
                    return std::string(m_value.str);
                }
                break;
            }
            case INJECTION_CONST_CHAR_PTR:
            {
                if (m_value.const_str != nullptr)
                {
                    return std::string(m_value.const_str);
                }
                break;
            }
            default:
                break;
        }
        return "";
    }
};
